/**
 *  Mode melee
 */

#Extends "Modes/ShootMania/ModeGuerro.Script.txt"

#Const  CompatibleMapTypes  "gesArena, HeroesArena, EliteArena"
#Const  Version       "2015-09-27"
#Const  ScriptName      "Champions.Script.txt"

#Include "Libs/Nadeo/Markers.Script.txt" as Markers
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo1/ShootMania/SpawnScreen.Script.txt" as SpawnScreen1
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Time.Script.txt" as Chrono
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/CH_UI.Script.txt" as CH_UI
#Include "Libs/CH_WP.Script.txt" as WP
#Include "Libs/CH_Events.Script.txt" as Events
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "Libs/Nadeo/ShootMania/Draft.Script.txt" as Draft

#Include "Libs/Nadeo/Layers.Script.txt" as O_Layers

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_LoosePoints 0 as "<hidden>"
#Setting S_Separator0 0 as _("$o$s$i$49f-- --> $fffMode $49f<--- --")   ///
#Setting S_Mode 1 as _("Mode$o$49f|")
#Setting S_Turn 10 as _("Number of rounds$o$49f|")
#Setting S_TurnMax 20 as _("Rounds max$o$49f|")
#Setting S_TurnGap 2 as "<hidden>"
#Setting S_MatchPoints 2 as _("Number of maps to win$o$49f|")
#Setting S_Gameplay True as _("Use the new gameplay$o$49f|")
#Setting S_SecondsGain 10 as _("Second to gain when capture$o$49f| $888(Only in the new gameplay!)")
#Setting S_Separator1 0 as _("$o$s$i$f00-- --> $fffTime $f00<--- --")   ///
#Setting S_TimeLimit  70 as _("$sTime before capture$o$f00|")    ///
#Setting S_TimeCapture  40 as _("$sTime to capture$o$f00|")   ///
#Setting S_GoalTime 5 as _("$sTime before the capture of the last goal$o$f00| $888(Only in the new gameplay!)")
#Setting S_Capture  1 as _("$sCapture time$o$f00|")   ///
#Setting S_TimeRespawn 10 as _("$sTime to respawn$o$f00|")
#Setting S_ShieldTime 8 as _("Max seconds for Shield$o$f00|")
#Setting S_Separator2 0 as _("$o$s$i$0f0-- --> $fffUseful things $0f0<--- --")    ///
#Setting S_NbPlayersPerTeam 4 as _("Number of players per team max$o$0f0|")
#Setting S_WarmUpDuration 40 as _("$888Warmup duration$o$0f0|")
#Setting S_UseClublinks True as _("Use clublinks$o$0f0|")
#Setting S_Dev False as "<hidden>"
#Setting S_Quick False as "Fast time between rounds$o$0f0|"
#Setting S_Separator3 0 as """--> $o$i$888Tournament Mode $fff$n(use this only in official match!) $z<--"""
#Setting S_Tournoi False as "$i$888Champions mode ( Tournament )$o$888|||"
#Setting S_CountDownElimination 20 as _("$i$888Capture time limit after defense elimination$o$888|||")
#Setting S_TeamLife False as "<hidden>"
#Setting S_Armors 5 as "<hidden>"

#Const Description _("TYPE: Team Versus Team\nOBJECTIVE: Capture when you are the Champion, defend when you are a defender.")

#Const C_WURocketAmmoMax      4 ///< Rocket ammo max
#Const C_WURocketAmmoGain     1.  ///< Rocket ammo regen speed
#Const C_WULaserAmmoMax       1 ///< Laser ammo max
#Const C_WULaserAmmoGain      1.  ///< Laser ammo regen speed
#Const C_WUNucleusAmmoMax     1 ///< Nucleus ammo max
#Const C_WUNucleusAmmoGain      1.3 ///< Nucleus ammo regen speed
#Const C_DefStaminaMaxMultiplier  0.7 ///< Stamina amount multiplier for the defense
#Const C_AtkStaminaMaxMultiplier  1.  ///< Stamina amount multiplier for the attack

#Const C_ModeClassic  0
#Const C_ModeFree   1

#Const C_Interface [
  "ST" => CUILayer::EUILayerType::ScoresTable,
  "Markers" => CUILayer::EUILayerType::Markers
]

#Const C_DescSpawn ""

#Const C_UI_Colors [
	"BG"		=> "222d",
	"Separator"	=> "eeef",
	"Text"		=> "fffc"
]

#Const C_RequiW 3
#Const C_RequiAtk 3
#Const C_RequiMiss 8

#Command Command_ForceWarmUp        (Boolean) as _("Set pause")
#Command Command_ForceClublinkReload    (Boolean) as _("Force clublink reload")

#Const C_Blink    300   ///< Gimp blink frequency

#Const C_DurationSpec 5000

#Const C_Nuc "Defender_Nuc"

#Const C_SequenceWarmUp			1	///< Scores table mode warm up
#Const C_SequencePlaying		2	///< Scores table mode playing
#Const C_SequencePodium			3	///< Scores table mode podium

#Const	C_ST_ColId_Accuracy		"Accuracy"

// ---------------------------------- //
// Globales variables
// ---------------------------------- //
declare Integer Anim_;
declare Integer CurrentTimeLimit;
declare Boolean G_Override_NeedWarmUp;
declare Boolean G_Override_ForceClublinkReload; 
declare Real  G_LongestRailDistance;      ///< Distance of the longest Laser hit
declare Text  G_LongestRailName;        ///< Name of the player with the longest Laser hit.
declare Integer G_AtkClan;            ///< Define wich Clan is currently attacking (1 player)
declare Integer G_DefClan;            ///< Define wich Clan is currently defending (3 players)
declare Integer PoleTime;
// Slot attacks
declare Integer[Integer] G_RocketSlot;				///< Current atk slot
declare Integer[Integer] G_LaserSlot;				///< Current atk slot
declare Ident G_RocketPlayerId;
declare Ident G_LaserPlayerId;
declare Integer G_Override_FirstAtkClan;
declare Ident G_Nuc;
declare Ident G_Shield;
declare CSmPlayer G_ShieldPlayer;
declare Boolean Anoloop;
declare Boolean Bnoloop;
declare Boolean Cnoloop;
declare Integer Game_SectionNb;

declare Text[]	G_TempAllies;					///< Logins list of matchmaking temporary allies
declare Ident[]	G_PrevMapUsersIds;				///< The list of users from the previous map 
declare Boolean Tournament;
declare Integer Life;
declare Boolean Cap_A;
declare Integer Ready_Nb1;
declare Integer Ready_Nb2;
declare Integer	G_LastSpecUpdate;				///< Last time the spectators were updated
declare Vec3	G_MapSpecCamDirection;			///< Spectator camera orientation
declare Boolean G_BreakDown;
// ---------------------------------- //
// Extend
// ---------------------------------- //

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(SpawnScreen1::GetScriptName(), SpawnScreen1::GetScriptVersion());
***

// ---------------------------------- //
// Set rules
// ---------------------------------- //
***Rules***
***
// ---------------------------------- //
// Create rules
declare SleepMultiplier = 1.;		///< Multiply the different sleept times of the script by this value
declare ModeName = "$f60Cham$fffPions";
SpawnScreen1::ResetRulesSection();

SpawnScreen1::SetModeColor("29f");

SpawnScreen1::AddSubsection(_("Type"), _("Two teams - 2 vs 4 ( or 2 vs 3 )"), 0.);
SpawnScreen1::AddSubsection(
    _("Objectives"), 
    TextLib::Compose(_("$<%11. $>The game is divided in rounds of two turns each. During a round each team plays one turn in attack and one turn in defense.\n$<%12. $>The attackers need to eliminate all defenders or capture with his ally the pole between %2 seconds and %3 seconds. The defenders must eliminate the attacker or prevent them from capturing the pole.\n$<%13. $>The team in attack plays with 2 players (Rocket Champion got 3 lifes, Laser Champion got 1 life). The team in defense plays with players using rockets.\n $<%14. $>The Rocket Champion can switch (armors, weapons) with the Laser Champion, The defender with nucleus can apply a shield to his allies."), "$"^SpawnScreen1::GetModeColor(), TextLib::ToText(S_TimeLimit - S_TimeCapture), TextLib::ToText(S_TimeLimit)), 20.);
SpawnScreen1::AddSubsection(
    _("Important"), 
    TextLib::Compose(_("$<%11. $>The team that wins the turn scores 1 point.\n$<%12. $>The winning team is the first one to score at least %2 points with %3 ahead of its opponents."), "$"^SpawnScreen1::GetModeColor() , TextLib::ToText(S_Turn), TextLib::ToText(S_TurnGap)), 70.);    

SpawnScreen1::CreatePrettyRules(ModeName);

ModeStatusMessage = _("TYPE: Team versus Team (2 vs 4)\nOBJECTIVE: Capture the pole when you are the attacker. Defend the pole when you are a defender.");
***

***InitServer***
***
declare IsRematch = False;			///< Do the players want a rematch ?
declare RematchNb = 0;				///< Number of consecutive rematch
Markers::Load();
Layers::Create("TopBar", Info());
Layers::Create("TopBar2", Info2());
Layers::SetType("TopBar2", CUILayer::EUILayerType::ScreenIn3d );
Layers::Attach("TopBar2");
Layers::Create("Ready", Ready_Layer());
Settings::Load();
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***StartServer***
***
main_function("Server");
Layers::Create("Checkpoint");
Layers::Attach("Checkpoint");
MB_UsePlayerClublinks	= S_UseClublinks;
UseProtectClanmates = True;
UsePlayerTagging = True;
Gameplay = CSmMode::EGameplay::Mp3Beta0;
// Scores table
UIManager.UIAll.ScoreTableOnlyManialink = True;

// Task overload

MB_Sleep(1);

Chrono::Load();

Layers::Create("Bouclier", Bouclier());
Layers::Create("Laser", Laser());
Layers::Create("Rocket", Rocket());
Layers::Create("TimeSpawn", TimeSpawn());
Layers::Create("Info", CreateLayerInfo());
foreach (Player in Players)
CH_UI::Rules(Player);

CustomUI::Load();
CustomUI::Add("Checkpoint", <0., 72.>, <30., 12.>, "center", "center", True, True);
CustomUI::Add("Elite_AtkArmor", <156., -88.>, <15., 10.>, "bottom", "right");
CustomUI::Add("Elite_AtkWinProbability", <140., -88.>, <15., 10.>, "bottom", "right");
CustomUI::Add("Elite_Sponsors", <80., -88.>, <40., 20.>, "bottom", "left");
CustomUI::Build();

declare Script_Section = "[]";
declare FirstAtk = MathLib::Rand(1, 2);
G_LongestRailName = "-";
G_LongestRailDistance = 0.;
G_RocketSlot = [1 => 1, 2 => 1];
G_LaserSlot = [1 => 2, 2 => 2];
//MB_UseSectionRound = True;
UseRounds(True);
// ---------------------------------- //
// Set mode options
UseClans = True;

// Init some spawns rules

---LobbyCH---

// ---------------------------------- //
// Create the rules
---Rules---

// ---------------------------------- //
// Initialize UI

// ---------------------------------- //
// Create the scores table


ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMWithLegends");
ST2::SetStyle("LibST_SMBasePoints");
ST2::CreateCol("LibST_SMPoints", _("|Substantive|Hit"), "0", 3., 100.);
ST2::SetColTextAlign("LibST_SMPoints", CMlControl::AlignHorizontal::Right);
ST2::CreateCol("AtkPoints", _("|Attack,Substantive|Atk"), "0", 3., 110.);
ST2::SetColTextAlign("AtkPoints", CMlControl::AlignHorizontal::Right);
ST2::SetColTextSize("AtkPoints", 3.);
ST2::CreateCol(C_ST_ColId_Accuracy, _("|Accuracy|Acc."), "-", 2.8, 80.);

MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::Build("SM");

UIManager.UIAll.ScoreTableOnlyManialink = True;
WarmUp2::Load();
WarmUp2::CreateGroup("Clan1", S_NbPlayersPerTeam);
WarmUp2::CreateGroup("Clan2", S_NbPlayersPerTeam);
WarmUp2::DisplayClanSelection(True);

	/* -------------------------------------- */
	// Create the UI layers
	declare LayerAttached = False;
	declare LayerUpdated = False;
	declare LayerDestroyed = False;

declare LayerMarkersId	= O_Layers::Create("Markers");
O_Layers::GetFromId(LayerMarkersId).Type = CUILayer::EUILayerType::Markers;
declare LayerMarkersPlayersId	= O_Layers::Create("Marker_Players");
O_Layers::GetFromId(LayerMarkersPlayersId).Type = CUILayer::EUILayerType::Markers;
LayerAttached = O_Layers::Attach("Markers", NullId);
LayerAttached = O_Layers::Attach("Marker_Players", NullId);

// /////////	
// Markers
declare LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
UIManager.UIAll.UILayers.add(LayerMarkers);
***



***InitMap***
***


ClearGoals();
declare PrevPointsLimit = -1;
Script_Section = "InitMap";
declare CH_Gameplay = BooleanToInteger(S_Gameplay);

UpdateMarkers(0);

Header("");
***


// ---------------------------------- //
// Map start
// ---------------------------------- //
***StartMap***
***
Layers::Update("TopBar", Info());
Layers::Update("TopBar2", Info2());
main_function("Game");
---UpdateLayerScoresTable---
// Matchmaking : allow substitutes

LayerMarkers.ManialinkPage = Get_FrameMarkers();
foreach (Player in Players) {
CH_UI::Init(Player);
declare Hits for Player = 0;
declare BeHits for Player = 0;
declare LaserHit for Player = 0;
declare Shoots for Player = 0;

Hits = 0;
BeHits = 0;
LaserHit = 0;
Shoots = 0;
}

InitGoal("Goal A", "Goal B", "Goal C");

log(Goals.count);

G_BreakDown = False;

declare Tournament = Boolean;
declare MidGame_Time = Now + 5000;
declare MidGame = False;
declare Blink_Start = Now;
declare Blink = False;
declare Blink_Duration = 0;
Game_SectionNb = 0;
//AtkPoints = 0;
declare Need_Spawn = 0;
declare NotCaptured = "Goal A";
declare ThisOneCanBeCap = Now + 1000;
declare ACanBeCap = True;
declare BCanBeCap = True;
declare CCanBeCap = True;
declare NbGoalsCaptured = 0;
    declare MaxDef = S_NbPlayersPerTeam;
    declare MaxAtk = 2;
declare Elimination = False;
    declare PoleCap = 0;
    declare DefSpawned = 0;
    declare AtkSpawned = 0;
declare GoalCanBeCaptured = False;
foreach (Player in Players) {
declare UI <=> UIManager.GetUI(Player);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}
if (ServerLogin == "guerro")
Users_SetNbFakeUsers(1 , 2);
Score::MatchBegin();
Score::RoundBegin();
SM::SetupDefaultVisibility();





G_AtkClan = FirstAtk;
G_DefClan = 3 - FirstAtk;
FirstAtk = G_DefClan; // Swap for next map.

declare netwrite Boolean Net_RocketPlayer for Teams[0];
declare netwrite Boolean Net_LaserPlayer for Teams[0];

declare ModeTime = Now + 5000;

// ---------------------------------- //
// Init bases
foreach (Base in MapBases) {
  Base.Clan = 0;
  Base.IsActive = True;
}

// ---------------------------------- //
// Init scores
MB_Sleep(1); ///< Allow the scores array to be sorted
foreach (Score in Scores) {
  declare Integer LastPoint for Score;
  LastPoint = 0;
}

Tournament = S_Tournoi;
Interface::CreatePlayersLists("Medium", 0.67, 10, 1);
if (!Tournament) MB_AutoTeamBalance();
// ---------------------------------- //
// New map sound
UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::StartRound, 0);

if (MB_SectionMatchNb > 0) Script_Section = "Match";

if (Script_Section == "Match") WarmUp();

else Script_Section = "Warm-Up";

UpdateMarkers(0);
declare CanEndC = Now + 10000;

if (!Tournament) Header(""); else Header("");

Script_Section = "Init";

UseForcedClans = False;

foreach (Player in Players) {
    declare PlayerClan for Player.User = 0;
PlayerClan = Player.CurrentClan;
}

***
***StartMatch***
***
Victory::MatchBegin();
G_Override_NeedWarmUp = False;
UpdateMarkers(0);

***

***InitRound***
***
ST2::SetScale(0.95);
ST2::Build("SM");
foreach (Player in Players) {
Layers::Detach("Ready", Player);
    declare PlayerClan for Player.User = 0;
PlayerClan = Player.CurrentClan;
}
main_function("Game");

---UpdateLayerScoresTable---

Clublink::DefineTeamAuto();
CH_UI::Loop();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
Spectators();
UpdateMarkers(0);
foreach (Player in Players) {
  declare UI <=> UIManager.GetUI(Player);
  if (UI != Null) {
declare netwrite Integer SettingTimer for UI = S_TimeRespawn; } }
Message::CleanAllMessages();
G_RocketPlayerId = NullId;
G_LaserPlayerId = NullId;
G_Shield = NullId;
if (Script_Section == "Game") {
CH_Gameplay = BooleanToInteger(S_Gameplay);
PoleTime = 0;
GoalCanBeCaptured = False;
// ---------------------------------- //
// Init goals
foreach (Goal in Goals) {
  Goal.Gauge.Clan = G_DefClan;
  Goal.Gauge.Max = PoleTime;
  Goal.Gauge.Speed = -1;
  Goal.Gauge.Value = Goal.Gauge.Max;
  Goal.Gauge.Captured = False;
     } 


}

Interface::CreatePlayersLists("Medium", 0.67, 10, 1);

AReal = 0.;
***



***StartRound***
***
Layers::Update("TopBar", Info());
Layers::Update("TopBar2", Info2());
declare CSmPlayer Player1;
declare CSmPlayer Player2;

InitBasesColor();
CH_UI::Loop();
Need_Spawn = 0;
  declare netwrite Integer Net_GatesCapturedUpdate for Teams[0];
  declare netwrite Integer[] Net_GatesCaptured for Teams[0];
  Net_GatesCaptured.clear();
  
UpdateMarkers(0);
Interface::CreatePlayersLists("Medium", 0.67, 10, 1);
if (!Tournament) Header(""); else Header("");
log(Script_Section);
if (Script_Section == "Warm-Up") {
//ClanMatchPoints1 = 0;
//ClanMatchPoints2 = 0;
WarmUp();
InitGoalValue(100 , True);
declare ClansOrder = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];

UpdateMarkers(0);
} else if (Script_Section == "Init") {


} else if (Script_Section == "Game") {
Spectators(True);
if (!S_Quick) UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
Cap_A = False;
Game_SectionNb += 1;
log(Game_SectionNb);
NotCaptured = "//";
NbGoalsCaptured = 0;
  foreach (Player in Players) {
    SetPlayerClan(Player, MM_GetRequestedClan(Player));
    if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
    else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
  }
ThisOneCanBeCap = Now + 1000;
//MB_Sleep(3000);
declare ClansOrder = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
foreach (Goal in Goals) {
Goal.Gauge.Max = (S_TimeLimit - S_TimeCapture) * 1000;
Goal.Gauge.Value = Goal.Gauge.Max;
Goal.Gauge.Speed = -1;
}

WarmUp2::Fill();

Anoloop = False;
Bnoloop = False;
Cnoloop = False;

Life = S_Armors * 100;

Elimination = False;

foreach(Player in Players) Init(Player);

if (G_Override_FirstAtkClan == 1 || G_Override_FirstAtkClan == 2) {
  FirstAtk = G_Override_FirstAtkClan;
  if (MB_SectionTurnNb % 2 == 0) {
    G_AtkClan = 3 - G_Override_FirstAtkClan;
    G_DefClan = G_Override_FirstAtkClan;
  } else {
    G_AtkClan = G_Override_FirstAtkClan;
    G_DefClan = 3 - G_Override_FirstAtkClan;
  }
  G_Override_FirstAtkClan = -1;
}

if (MB_SectionRoundNb > 1) {
if (G_AtkClan == 1) { G_DefClan = 1; G_AtkClan = 2; }
else if (G_AtkClan == 2) { G_DefClan = 2; G_AtkClan = 1; }
}

declare netwrite GoalsCount for Teams[0] = Goals.count;
GoalsCount = Goals.count;

if (Game_SectionNb == 1) 
{
SleepPresentation(3000);
}

sleep(200);

Announce("Attack");
declare netwrite Anim for Teams[0] = 0;
Anim = Now + 6000;
Anim_ = 6000;
declare name = Teams[G_AtkClan - 1].ColorizedName;
//ML_Play(name^" attack!", True);

ModeTime = Now + 5000;
// SLOT 2 - Attack
GoalCanBeCaptured = False;
if (!S_Quick) UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;

if (!S_Quick) MB_Sleep(500);

PlaySound(CUIConfig::EUISound::PhaseChange, 0);
  
MB_Sleep(2000);



StartTime = Now;
if (S_TimeLimit > 0) EndTime = StartTime + (S_TimeLimit * 1000);
else EndTime = -1;
MB_Sleep(500);
declare CurrentTimeLimit = S_TimeLimit;



UpdateSlot();
MB_Sleep(1000);

if (!S_Quick) MB_Sleep(500);

PoleTime = (StartTime + (S_TimeLimit - S_TimeCapture) * 1000);

// ---------------------------------- //
// Init goals
foreach (Goal in MapLandmarks_Gauge) {
log(Goal.Tag);
  Goal.Gauge.Clan = G_DefClan;
  Goal.Gauge.Max = PoleTime - Now;
  Goal.Gauge.Speed = -1;
  Goal.Gauge.Value = Goal.Gauge.Max;
  Goal.Gauge.Captured = False;
}

main_function("Game");

foreach (Player in Players) {
---SpawnAtk---
---SpawnDef---
}
MB_Sleep(100);
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UpdateMarkers(1);
UIManager.UIAll.CountdownEndTime = PoleTime;
CanEndC = Now + 3000;
Layers::Attach("Info");
Layers::Update("Info", CreateLayerInfo());
Layers::Update("TopBar", Info());
Layers::Update("TopBar2", Info2());

if (ClansNbPlayers[1] < 2 || ClansNbPlayers[2] < 2) { MB_StopRound = True; G_Override_NeedWarmUp = True; CheckClans(False); }
//else if (S_Tournoi && (ClansNbPlayers[1] < S_NbPlayersPerTeam || ClansNbPlayers[2] < S_NbPlayersPerTeam)) { MB_StopRound = True; G_Override_NeedWarmUp = True; CheckClans(False); }
MidGame_Time = Now + 5000;
MidGame = False;

}
if (!S_Quick) MB_Sleep(500);

Layers::Detach("ML_Play");

Clublink::DefineTeamAuto();

***

***SpawnAtk***
***
  declare AtkSpawn <=> Map::GetPlayerSpawn("SpawnAttack", 0);
  

  if (Player.CurrentClan == G_AtkClan && !Tournament) {
Player.IsHighlighted = True; ///
Player.AmmoGain   = 1.; ///
Player.ForceColor = <0., 1., 1.>; ///
Player.StaminaMax   = 1.; ///
Player.StaminaGain  = 1.; ///
if (Player.Id == G_RocketPlayerId) {
SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);
Player.AmmoGain = 0.9;
Player.ArmorMax = 100 * ClansNbPlayers[G_DefClan];
Player.Armor = 100 * ClansNbPlayers[G_DefClan];
Layers::Attach("Rocket", Player);
}
if (Player.Id == G_LaserPlayerId) {
    SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
Player.ArmorMax = 100* ClansNbPlayers[G_DefClan];
Player.Armor = 100* ClansNbPlayers[G_DefClan];
Player.AmmoGain   = 1.2;
Layers::Attach("Laser", Player);
} else if (Player.Id != G_RocketPlayerId && Player.Id != G_LaserPlayerId) {
Player.ArmorMax = 100;
Player.Armor = 100;
SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
Player.AmmoGain   = 1.;
Layers::Detach("Laser", Player);
Layers::Detach("Rocket", Player);
}
 
    SM::SpawnPlayer(Player, G_AtkClan, AtkSpawn);  }
else if (Player.CurrentClan == G_AtkClan && Tournament) {
if (Player.Id == G_RocketPlayerId || Player.Id == G_LaserPlayerId) {
if (!S_TeamLife) {
Player.ArmorMax = 100* ((ClansNbPlayers[G_DefClan]/2) + 1);
Player.Armor = 100* ((ClansNbPlayers[G_DefClan]/2) + 1);
} else {
Player.ArmorMax = S_Armors * 100;
Player.Armor = S_Armors * 100;
}
Player.IsHighlighted = True; ///
Player.AmmoGain   = 1.; ///
Player.ForceColor = <0., 1., 1.>; ///
Player.StaminaMax   = 1.; ///
Player.StaminaGain  = 1.; ///
SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
SM::SpawnPlayer(Player, G_AtkClan, AtkSpawn); 
}
}

if (Player.Id == G_RocketPlayerId) G_RocketPlayerId = Player.Id;
***

***SpawnDef***
***
  declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
  
  if (Player.CurrentClan == G_DefClan) {
  declare PlayerJustJoined for Player = False;
  Player.ArmorMax = 100;
Player.Armor = 100;
SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
Player.AmmoGain	= 1. * C_WURocketAmmoGain;

if (Tournament)
{
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, Settings::GetInteger("7", 4));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, Settings::GetInteger("9", 1));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger("5", 1));

declare DefWeapon	= CSmMode::EWeapon::Rocket;
Player.AmmoGain		= Settings::GetReal("8", 1.);
Player.StaminaMax	= Settings::GetReal("17", C_DefStaminaMaxMultiplier);
Player.StaminaGain	= Settings::GetReal("17", C_DefStaminaMaxMultiplier);
Player.ArmorMax		= 100;
SetPlayerWeapon(Player, DefWeapon, True);
Player.IsHighlighted = True;
}

if (Player.Id == G_Nuc && !Tournament) {
if (S_Dev) {
SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
Player.AmmoGain   = 0.9;
Player.StaminaMax = 2.75;
Player.StaminaGain = 0.5;
} else {
SetPlayerWeapon(Player, CSmMode::EWeapon::Nucleus, False);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
Player.AmmoGain   = 1.15;
Player.StaminaMax = 2.5;
Player.StaminaGain = 1.;
}
}
  
  SM::SpawnPlayer(Player, G_DefClan, DefSpawn);
  SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger("5", 1));
  UpdateMarkers(1);
  }
***

***RequestRespawn***
***
declare Chrono_C for Event.Player = True;
Chrono_C = True;
declare Time_Spawn for Event.Player = Now + S_TimeRespawn * 1000;
Time_Spawn = Now + S_TimeRespawn * 1000;


PassOn(Event);
***

***RequestSpawn***
***
if (!Tournament) {
declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
declare PlayerJustJoined for Player = False;
if (Player.CurrentClan == G_DefClan) {
declare Time_Spawn for Player = Now + S_TimeRespawn * 1000;
declare Chrono_C for Player = True;
if (Chrono_C) { Chrono::CreateBig(Player.Id); Chrono::Start(Player.Id, S_TimeRespawn * 1000); Chrono_C = False; }
declare netwrite Integer RespawnTime for Player = Time_Spawn;
RespawnTime = Time_Spawn;
if (Time_Spawn < Now) { SM::SpawnPlayer(Player, G_DefClan, DefSpawn); 
Chrono::DestroyBig(Player.Id); }
else if (Need_Spawn > Now) { SM::SpawnPlayer(Player, G_DefClan, DefSpawn); 
Chrono::DestroyBig(Player.Id);  }
}
}
***

***OnArmorEmpty***
***
if (Event.Victim.Id == G_RocketPlayerId || Event.Victim.Id == G_LaserPlayerId && Event.Shooter != Null && Event.Victim != Null) {
KillerName = Event.Shooter.Name;
ChampionName = Event.Victim.Name;
}
declare Time_Spawn for Event.Victim = Now + S_TimeRespawn * 1000;
Time_Spawn = Now + S_TimeRespawn * 1000;
declare Chrono_C for Event.Victim = True;
Chrono_C = True;
PassOn(Event);

if (Event.Victim.Id != G_RocketPlayerId && Event.Victim.Id != G_LaserPlayerId && Event.Victim.CurrentClan == G_AtkClan && Event.Shooter != Null)
{
PlaySound(CUIConfig::EUISound::TieBreakPoint, 0);
} else if (Event.Victim.Id == G_RocketPlayerId || Event.Victim.Id == G_LaserPlayerId && Event.Shooter != Null)
{
PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
}

if (Event.Victim.CurrentClan == G_DefClan && ClansNbPlayersAlive[G_DefClan] > 1) PlaySound(CUIConfig::EUISound::TieBreakPoint, 4);
else if (ClansNbPlayersAlive[G_DefClan] == 1 && Event.Victim.CurrentClan == G_DefClan) PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
***

***OnHit***
***

			if (ClansNbPlayersAlive[G_DefClan] > 1 && Event.Victim.CurrentClan == G_DefClan && Event.Shooter.CurrentClan == G_AtkClan) {
				declare DefLeft = ClansNbPlayersAlive[G_DefClan] - 1;
				if (DefLeft <= 1) {
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", 
							Teams[G_DefClan - 1].ColorText,
							_("1 defender left.")
						), 3000, 2
					);
				} else {
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 defenders left."), 
							Teams[G_DefClan - 1].ColorText, 
							TextLib::ToText(DefLeft)
						), 3000, 2
					);
				}
			}
			
/*
if (Event.Shooter.Id == G_RocketPlayerId) {
log(Event.Shooter.CurWeapon);
log("test1");
LaserAbility(Event.Shooter);
RocketAbility(Event.Victim);
G_LaserPlayerId = Event.Shooter.Id;
G_RocketPlayerId = Event.Victim.Id;
declare ArmorVictim = Event.Victim.Armor;
declare ArmorShooter = Event.Shooter.Armor;
ArmorVictim = Event.Victim.Armor;
ArmorShooter = Event.Shooter.Armor;
Event.Shooter.Armor = ArmorVictim;
Event.Victim.Armor = ArmorShooter;
log("test");
}
*/
if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) 
{ 


Event.Damage = 0; }
else {
PassOn(Event);
}

Event.Damage = 100;

/* -------------------------------------- */
// Friendly fire off
if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan && Event.Shooter.Id == G_Nuc && !Tournament) {
   G_Shield = Event.Victim.Id;
    G_ShieldPlayer = Event.Victim;
  //ShieldTemp = Now + 10 + S_Shield * 1000;
  declare UI <=> UIManager.GetUI(Event.Victim);
  if (UI != Null) {
declare netwrite Text event_victim for UI;
event_victim = "SHIELD";
}
foreach (Player in Players)
  Layers::Detach("Bouclier", Player);
  Layers::Attach("Bouclier", G_ShieldPlayer);
  declare ShieldTime for Event.Victim = 0;
  ShieldTime = Now + (S_ShieldTime * 1000);
  Event.Damage = 0;
  Event.Victim.HasShield = True;
 


//

if (Event.Victim.User != Null) {
if (Event.Victim.User.Language == "fr") { declare UI <=> UIManager.GetUI(Event.Victim.User); UI.SendNotice("$0f0Vous venez d'avoir un bouclier", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } 
else { declare UI <=> UIManager.GetUI(Event.Victim.User); UI.SendNotice("$0f0You gained a shield", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } } 


} else {
if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
PlaySound(CUIConfig::EUISound::Checkpoint, 1);
  Event.Damage = 0;
  
}


 else if (Event.Shooter.CurrentClan != Event.Victim.CurrentClan && Event.Victim.Id == G_Shield) {

if (Event.Victim.User != Null) {
if (Event.Victim.User.Language == "fr") { declare UI <=> UIManager.GetUI(Event.Victim.User); UI.SendNotice("$0f0Vous venez de perdre votre bouclier", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } 
else { declare UI <=> UIManager.GetUI(Event.Victim.User); UI.SendNotice("$0f0You lost your shield", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } } 

if (Event.Shooter.User != Null) {
if (Event.Shooter.User.Language == "fr") { declare UI <=> UIManager.GetUI(Event.Shooter.User); UI.SendNotice("$f00Vous venez de d√©truire un bouclier", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } 
else { declare UI <=> UIManager.GetUI(Event.Shooter.User); UI.SendNotice("$f00You broke a shield.", CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice , 1); } } 
AddPlayerAmmo(Event.Shooter, CSmMode::EWeapon::Laser, 1.);
AddPlayerAmmo(Event.Shooter, CSmMode::EWeapon::Rocket, 1.);
Layers::Detach("Bouclier", Event.Victim);
  G_Shield = NullId;
Event.Damage = 0;
PlaySound(CUIConfig::EUISound::FirstHit , 1);
}
}


// Just addpoints
if (Event.Shooter.CurrentClan != Event.Victim.CurrentClan)
{ Score::AddPoints(Event.Shooter, 1);
if (Event.Shooter.Id == G_Nuc) Event.Damage = 100;
declare Hits for Event.Shooter = 0;
Hits += 1;
declare BeHits for Event.Victim = 0;
BeHits += 1;
declare LaserHit for Event.Shooter = 0;
LaserHit += 1;
declare Hits_U for Event.Shooter.User = Hits;
Hits_U = Hits;
      }

if (Event.Victim.CurrentClan == G_AtkClan && Event.Shooter.CurrentClan == G_DefClan && S_TeamLife)
{
Event.Damage = 0;
Life -= 100;


}

***

***OnMiss***
***
if (Event.Victim != Null && Event.Victim.CurrentClan != Event.Shooter.CurrentClan)
{
declare NearMiss for Event.Victim = 0;
NearMiss += 1;
}
***

***OnFall***
***
log(Event.Height);
log("what");
***

***OnNewPlayer***
***
if (!Tournament) Header(""); else Header("");
declare PlayerJustJoined for Player = True;
if (MidGame) CH_UI::Rules(Player);
***

***OnPlayerDisconnect***
***
if (G_LaserPlayerId == NullId || G_RocketPlayerId == NullId) { Victory::SetRoundWinnerIfNoWinner (G_DefClan); MB_StopTurn = True; log(Event.Player.Name^" Disconnected"); }
***

***OnNewSpectator***
***
if (Spectator.Id == G_RocketPlayerId || Spectator.Id ==  G_LaserPlayerId) { Victory::SetRoundWinnerIfNoWinner (G_DefClan); MB_StopTurn = True; log(Spectator.Name^" Disconnected"); }
CH_UI::Rules(Spectator);
***

***GoalLoop***
***
CH_UI::Loop();
foreach (Goal in Goals) {
if (Now <= PoleTime) {
Goal.Gauge.Speed = -1;
}
}

// A <-- REALLY NANDO?
foreach (LandmarkGauge in MapLandmarks_Gauge) {



if (LandmarkGauge.Tag == "Goal A") {
if (LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = True;
if (LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = True;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = False;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = False;
}
}
// B
foreach (LandmarkGauge in MapLandmarks_Gauge) {
if (LandmarkGauge.Tag == "Goal B") {
if (LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = True;
if (LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = True;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = False;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = False;
}
}
// C
foreach (LandmarkGauge in MapLandmarks_Gauge) {
if (LandmarkGauge.Tag == "Goal C") {
if (LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = True;
if (LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = True;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_RocketPlayer = False;
if (!LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId) && LandmarkGauge.Sector.PlayersIds.count > 0 && LandmarkGauge.Sector != Null) Net_LaserPlayer = False;
}
}



// All defenders eliminated, start the capture countdown

if (ClansNbPlayersAlive[G_DefClan] <= 0 && S_CountDownElimination > 0 && S_Tournoi)
{
if (!Elimination) {
  Elimination = True;
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
		PlaySound(CUIConfig::EUISound::PhaseChange, 1);
		UIManager.UIAll.BigMessageSoundVariant = 0;
		UIManager.UIAll.BigMessage = _("All defenders eliminated, capture the goal!");
		UIManager.UIAll.CountdownEndTime = -1;
		EndTime = Now + (S_CountDownElimination * 1000); -1;
		}
		foreach (LandmarkGauge in MapLandmarks_Gauge) {
		if (LandmarkGauge.Gauge.Clan == G_DefClan) {
			LandmarkGauge.Gauge.Clan = G_AtkClan;
			LandmarkGauge.Gauge.Value = 0;
			LandmarkGauge.Gauge.Max = S_Capture;
		}
		
		if (LandmarkGauge.Sector != Null && (LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) || LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId))) {
			LandmarkGauge.Gauge.Speed = 1;
	AReal = LandmarkGauge.Gauge.ValueReal;
		} else {
			LandmarkGauge.Gauge.Speed = 0;
			}
			
}
}

if (Now >= PoleTime && !Elimination) {
  if (!GoalCanBeCaptured) {
    GoalCanBeCaptured = True;
    UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
    UIManager.UIAll.BigMessageSoundVariant = 0;
    UIManager.UIAll.BigMessage = _("The goal can now be captured.");
    UIManager.UIAll.CountdownEndTime = -1;
   foreach (LandmarkGauge in MapLandmarks_Gauge)
   LandmarkGauge.Gauge.Clan = G_DefClan;
    
  }
  
  if (Goals.count == 1) {
  +++GoalGameplay0+++
} else if (Goals.count > 1) {
  +++GoalGameplay1+++
}
  

} 

***

***GoalGameplay0***
***
  // Check if the attacker is capturing the pole
  foreach (LandmarkGauge in MapLandmarks_Gauge) {
    if (LandmarkGauge.Gauge.Value <= 0 && LandmarkGauge.Gauge.Clan == G_DefClan) {
     log("switch");
      LandmarkGauge.Gauge.Clan = G_AtkClan;
      LandmarkGauge.Gauge.Max = (S_Capture * 1000) * MapLandmarks_Gauge.count;
    }
    

    
    if (LandmarkGauge.Sector != Null ) {
    

    if(LandmarkGauge.Gauge.Clan == G_DefClan) {
        LandmarkGauge.Gauge.Speed = -1;
      } else {
      foreach(PlayerId in LandmarkGauge.Sector.PlayersIds) {  
  declare Player <=> Players[PlayerId]; 

       
      }
      }
if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) {
LandmarkGauge.Gauge.Speed = 1;
AReal = LandmarkGauge.Gauge.ValueReal;

    } else {
      LandmarkGauge.Gauge.Speed = 0;
    }
 }
}
***

***GoalGameplay1***
***

  if (Goals.count > 1) {
  // Check if the attacker is capturing the pole
  foreach (LandmarkGauge in MapLandmarks_Gauge) {
    if (LandmarkGauge.Gauge.ValueReal <= 0. && LandmarkGauge.Gauge.Clan == G_DefClan) {
      log("switch");
      LandmarkGauge.Gauge.Clan = G_AtkClan;
      LandmarkGauge.Gauge.Max = (S_Capture * 1000) * MapLandmarks_Gauge.count;
      ModeTime = Now + (S_TimeCapture * 1000);
    }
    

    
    if (LandmarkGauge.Sector != Null ) {
    

    if(LandmarkGauge.Gauge.Clan == G_DefClan) {
        LandmarkGauge.Gauge.Speed = -1;
      } else {
      foreach(PlayerId in LandmarkGauge.Sector.PlayersIds) {  
  declare Player <=> Players[PlayerId]; 

       
      }
      }
if (GoalsCaptured() == Goals.count - 1)  UIManager.UIAll.CountdownEndTime = ModeTime;

if (GoalsCaptured() == Goals.count - 1 && ModeTime < Now) {
if (!LandmarkGauge.Gauge.Captured) NotCaptured = LandmarkGauge.Tag;
if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)  && LandmarkGauge.Tag == NotCaptured) {
+++GoalMode0+++
log("test");
} else if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.count < 2)  {
      LandmarkGauge.Gauge.Speed = 0;
    }
    }  if (GoalsCaptured() < Goals.count - 1) {
if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) {
+++GoalMode1+++
} else if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.count < 2)  {
      LandmarkGauge.Gauge.Speed = 0;
    }
    } 
 }
}
}
***




***GoalMode0***
***

if (Goals.count == 3)
{
if (GoalsCaptured() == 2) {
AReal = LandmarkGauge.Gauge.ValueReal;
if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) {
LandmarkGauge.Gauge.Speed = 1;
log("continue");
} if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) || !LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) LandmarkGauge.Gauge.Speed = 0;

}
} else if (Goals.count == 2)
{
if (GoalsCaptured() == 1) {
AReal = LandmarkGauge.Gauge.ValueReal;
if (LandmarkGauge.Sector != Null && LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) && LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) {
LandmarkGauge.Gauge.Speed = 1;

} if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) || !LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) LandmarkGauge.Gauge.Speed = 0;
}
}

if (!LandmarkGauge.Sector.PlayersIds.exists(G_RocketPlayerId) || !LandmarkGauge.Sector.PlayersIds.exists(G_LaserPlayerId)) LandmarkGauge.Gauge.Speed = 0;
***

***OnShoot***
***
declare Shoots for Event.Shooter = 0;
Shoots += 1;
***

***GoalMode1***
***
log(Goals.count);
if (Goals.count == 3)
{
log("capture");
if (GoalsCaptured() == 0 || GoalsCaptured() == 1) {
LandmarkGauge.Gauge.Speed = 6;
 ModeTime = Now + (S_GoalTime * 1000);
LandmarkGauge.Gauge.Clan = G_AtkClan;
if (LandmarkGauge.Gauge.Value == LandmarkGauge.Gauge.Max) LandmarkGauge.Gauge.Captured = True;
}
} else if (Goals.count == 2)
{
log("capture");
if (GoalsCaptured() == 0)
{
ModeTime = Now + 5000;
LandmarkGauge.Gauge.Speed = 4;
 ModeTime = Now + (S_GoalTime * 1000);
LandmarkGauge.Gauge.Clan = G_AtkClan;
if (LandmarkGauge.Gauge.Value == LandmarkGauge.Gauge.Max) LandmarkGauge.Gauge.Captured = True;
}
}

***

***PrecisionManagement***
***
declare Hits for Player = 0;
declare Shoots for Player = 0;
declare Precision for Player = 0;

Precision = Hits - Shoots;

GetHitrate(Player);



***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
*** CH_UI::Loop(); ManageCommand(); CheckClans(True); main_function("Game"); /*Layers::Attach("TopBar");*/ Layers::Attach("TopBar2"); CoinsLoop(); // main

foreach (Player in Players) {
    declare PlayerClan for Player.User = 0;
PlayerClan = Player.CurrentClan;
}

Layers::Attach("Markers");
if (Script_Section == "Init") {
Script_Section = "Game"; ---StartRound---

}
if (Script_Section == "Game") {
---GoalLoop---
if (CanEndC + 1500 < Now) {
CheckEnd1("Custom");
}

foreach (Player in Players) {
if (Player.CurrentClan == G_AtkClan && S_TeamLife) {
Player.Armor = Life;
  }
}
//if (Tournament S_To) { EndMatch(); }

foreach (Player in Players) {
---PrecisionManagement---
}
Spectators();


if (Players.existskey(G_ShieldPlayer)) {
if (G_ShieldPlayer != Null ) {
ShieldManagement(G_ShieldPlayer);
 }
}

if (Now > MidGame_Time) MidGame = True;

foreach (Goal in Goals) 
{
if (Goal.Tag == NotCaptured)
 {
if (Goal.Gauge.ValueReal >= 0.98) { AReal = 1.; }
 }
}
 

Layers::Attach("Info");

foreach (Player in Players) {
declare UI <=> UIManager.GetUI(Player);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}


GoalsCaptured();


if (CH_Gameplay != BooleanToInteger(S_Gameplay))
   {
// Check gameplay
if (BooleanToInteger(S_Gameplay) == 0)
   {
EndMatch();
  } else if (BooleanToInteger(S_Gameplay) == 1)
   {
EndMatch();
   }
}

foreach (Player in Players) {
  if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate) {
    ---RequestSpawn---
  }
}


foreach (Goal in Goals)
{

    declare netwrite Integer Net_GatesCapturedUpdate for Teams[0];
    declare netwrite Integer[] Net_GatesCaptured for Teams[0];
    declare Integer GateIndex for Goal;
    
    
if (CH_Gameplay == 1) {

Layers::Update("Checkpoint", GetMLCheckpoint(Net_GatesCaptured.count));

if (Goal.Tag == "Goal A")
{
if (Goal.Gauge.Captured && !Anoloop) {  EndTime += S_SecondsGain * 1000; Anoloop = True;
    Net_GatesCaptured.add(GateIndex);
    Net_GatesCapturedUpdate = Now;
    Need_Spawn = Now + 1000;
    Players[G_RocketPlayerId].Armor += 100; Players[G_LaserPlayerId].Armor += 100; }
}
if (Goal.Tag == "Goal B")
{
if (Goal.Gauge.Captured && !Bnoloop) {  EndTime += S_SecondsGain * 1000; Bnoloop = True;
    Net_GatesCaptured.add(GateIndex);
    Net_GatesCapturedUpdate = Now;
    Need_Spawn = Now + 1000;
    Players[G_RocketPlayerId].Armor += 100; Players[G_LaserPlayerId].Armor += 100; }
}
if (Goal.Tag == "Goal C")
{
if (Goal.Gauge.Captured && !Cnoloop) {   EndTime += S_SecondsGain * 1000; Cnoloop = True;
    Net_GatesCaptured.add(GateIndex);
    Net_GatesCapturedUpdate = Now;
    Need_Spawn = Now + 1000;
    Players[G_RocketPlayerId].Armor += 100; Players[G_LaserPlayerId].Armor += 100; }
}

if (!Goal.Gauge.Captured && GoalsCaptured() > 0) { if (Goal.Tag == NotCaptured) { Announce("Goal"); UIManager.UIAll.CountdownEndTime = -1; } }
}
}

  ST2::SetFooterText("Rounds Max :"^S_Turn);


// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit) {
  CurrentTimeLimit = S_TimeLimit;
  if (S_TimeLimit > 0) EndTime = StartTime + (S_TimeLimit * 1000);
  else EndTime = -1;
}

Message::Loop();

// ---------------------------------- //
// victory conditions
declare IsMatchOver = False;
if (S_TimeLimit > 0 && Now > EndTime) IsMatchOver = True;

} else if (Script_Section == "Warm-Up") { Script_Section = "Init"; ---StartRound--- }
***

***CustomEndRound1***
***
foreach (Player in Players) {

if (ClansNbPlayersAlive[G_DefClan] == 0 && (!S_Tournoi || G_BreakDown)) { MB_StopRound = True; Victory::SetRoundWinnerIfNoWinner (G_AtkClan); Announce("C_Def"); }
else if (Player.Id == G_RocketPlayerId && Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned
 ||  Player.Id == G_LaserPlayerId && Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned
 || !Players.existskey(G_RocketPlayerId) || !Players.existskey(G_LaserPlayerId)   ) {
MB_StopRound = True; Victory::SetRoundWinnerIfNoWinner (G_DefClan); Announce("C_Atk");
} else if (Now > EndTime) { Victory::SetRoundWinnerIfNoWinner (G_DefClan); MB_StopRound = True; Announce("C_Time"); }
else if (AReal == 1.) { Victory::SetRoundWinnerIfNoWinner (G_AtkClan); MB_StopRound = True; Announce("C_Cap"); }
 }
***

***EndRound***
***
EndTime = -1;
MB_Sleep(50);
if (AReal == 1.) { PlaySound(CUIConfig::EUISound::VictoryPoint, 0); GivePoints("Atk"); if(S_Gameplay) View(GoalId()); }
MB_Sleep(400);
Message::CleanAllMessages();
MB_Sleep(500);
UIManager.UIAll.BigMessage = "";
MB_Sleep(500);



// ---------------------------------- //
// Select the next atk slot
G_RocketSlot[G_AtkClan] += 1;
if (G_RocketSlot[G_AtkClan] > S_NbPlayersPerTeam) G_RocketSlot[G_AtkClan] = 1;
MB_Sleep(100);

// ---------------------------------- //
// Select the next atk slot
G_LaserSlot[G_AtkClan] += 1;
if (G_LaserSlot[G_AtkClan] > S_NbPlayersPerTeam) G_LaserSlot[G_AtkClan] = 1;
MB_Sleep(100);

MB_Sleep(100); /// <-- Soft switch
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
MB_Sleep(400); /// <-- Soft switch

StartTime = -1;

if (ClansNbPlayersAlive[G_DefClan] == 1) ClanScores[G_DefClan] += 1;


foreach (Player in Players)
UnspawnPlayer(Player);
  declare netwrite Integer Net_GatesCapturedUpdate for Teams[0];
  declare netwrite Integer[] Net_GatesCaptured for Teams[0];
  Net_GatesCaptured.clear();
foreach (Player in Players)
Chrono::DestroyBig(Player.Id);
UIManager.UIAll.CountdownEndTime = -1;
foreach (Player in Players) {
Layers::Detach("Laser", Player);
Layers::Detach("Rocket", Player);
Layers::Detach("Bouclier", Player);
}
if (Victory::IsRoundDraw()) {
EndTime = -1;
}

if (!S_Quick) MB_Sleep(1500);

if (Victory::IsRoundWinner(1) || Victory::IsRoundWinner(2)) {
if (Victory::IsRoundWinner(1)) 
{
    Message::SendBigMessage(TextLib::Compose(_("$<%1$> wins the turn!"), Teams[0].ColorizedName), 3000, 1, CUIConfig::EUISound::EndRound , 1);
    ClanScores[1] += 1;
    if (G_BreakDown) ClanScores[1] + 2;
} 
else if (Victory::IsRoundWinner(2)) 
{
    Message::SendBigMessage(TextLib::Compose(_("$<%1$> wins the turn!"), Teams[1].ColorizedName), 3000, 1, CUIConfig::EUISound::EndRound , 1);
   ClanScores[2] += 1;
   if (G_BreakDown) ClanScores[2] += 2;
} 


// Give GEsCoins
foreach (Player in Players) {
declare persistent Coins for Player.User = 0;
declare TemporaryCoins for Player.User = 0;
declare TeamWork for Player = False;
declare TeamW for Player = 0;
declare NearMiss for Player = 0;
declare MostHits for Player = False;
declare MostCaptures for Player = False;
declare RunnerHits for Player = False;
declare netwrite AtkPoints for Player = 0;

if (TeamW > C_RequiW) TeamWork = True;

// 3 Max
for (Count, 0, 2)
if (Players.existskey(Count) && Player == Players[Count]) MostHits = True;
if (AtkPoints > C_RequiAtk) MostCaptures = True;
if (NearMiss > C_RequiMiss) RunnerHits = True;

if (TeamWork) {
Coins += 1;
TemporaryCoins += 1; }
if (MostHits) {
Coins += 1;
TemporaryCoins += 1; }
if (MostCaptures) {
Coins += 1;
TemporaryCoins += 1; }
if (RunnerHits) {
Coins += 1;
TemporaryCoins += 1; }

Coins += 1;
TemporaryCoins += 1;

declare ChatUI <=> UIManager.GetUI(Player);
if (ChatUI != Null) { SendNotice("""You won $f70{{{TemporaryCoins}}} GsCoins! $z$s( {{{Coins}}} Total GsCoins )""", Player);

declare netwrite GsCoins for Teams[0] = Coins;

}

TemporaryCoins = 0;
TeamWork = False;
MostHits = False;
MostCaptures = False;
RunnerHits = False;

}

if (((ClanScores[1] >= ClanScores[2]) || (ClanScores[2] >= ClanScores[1])) &&
   ClanScores[1] >= S_TurnGap && ClanScores[2] >= S_TurnGap &&
   ClanScores[1] >= S_Turn && ClanScores[2] >= S_Turn) G_BreakDown = True;

log(G_BreakDown);

if (G_BreakDown) UIManager.UIAll.StatusMessage = "$f70BreakDown";

sleep(500);
Header("");

MB_Sleep(2000);



Victory::SetMatchWinnerFromScore(S_Turn, S_TurnGap, S_TurnMax);
// ---------------------------------- //
// End match sequence
declare Integer Winner;
declare CTeam TeamGotLast;
/*
foreach (Player in Players) {
if (Victory::IsRoundWinner(1)) { if (Player.CurrentClan != 0) { UnSpawnPlayer(Player); } }
if (Victory::IsRoundWinner(2)) { if (Player.CurrentClan != 1) { UnspawnPlayer(Player); } }
if (Victory::IsRoundDraw()) {  UnspawnPlayer(Player);  }
  
}
*/
if (Victory::IsMatchWinner(1)) 
{
   MB_StopMap = True;
} 
else if (Victory::IsMatchWinner(2)) 
{
   MB_StopMap = True;
} 


MB_Sleep(200);
SM::UnspawnAllPlayers();
MB_Sleep(200);
if (!Tournament) Header(""); else Header("");
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(1000);
if (!S_Quick) MB_Sleep(2000);
MB_Sleep(100);

if (!S_Quick) MB_Sleep(500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}
Score::RoundEnd();

***

***LadderPoints***
***
foreach (Score in Scores) {
	// Check player clan
	if (MM_IsMatchServer() && Score.LadderClan == 0) {
		declare Clan = MM_GetAssignedClan(Score.User.Login);
		if (Clan > 0) Score.LadderClan = Clan;
	}
	
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare Hits for Score = 0;
	declare LaserHit for Score = 0;
	declare BeHits for Score = 0;
	declare GoalAverage = ((Hits + LaserHit) / 3.) - (BeHits / 6.);
	if (GoalAverage < 0.) GoalAverage = 0.;
	Score.LadderMatchScoreValue = Score.Points + GoalAverage;
	// Winner
	if (Score.LadderClan == WinnerMapClan) {
		Score.Points = 3;
	}
	// Looser
	else if (Score.LadderClan == 3 - WinnerMapClan) {
		Score.Points = 2;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
if (MM_IsMatchServer()) {
	MM_SetLadderMatchId();
}
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMap***
***
declare WinnerMapClan = -1;
ClearGoals();
if(MatchEndRequested) {
  Message::SimpleBigMessage("Map skipped, going to the next.", 8000); 
  UIManager.UIAll.SendChat("Map skipped, going to the next.");
  MB_Sleep(2000);
}

EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
if (!MatchEndRequested) {
if (Victory::IsMatchWinner(1) || Victory::IsMatchWinner(2)) {
if (Victory::IsMatchWinner(1)) 
{
    Message::SendBigMessage(Teams[0].ColorizedName ^ " wins the map!", 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
    ClanMatchPoints1 += 1;
    WinnerMapClan = 1;
    
} 
else if (Victory::IsMatchWinner(2)) 
{
    Message::SendBigMessage(Teams[1].ColorizedName ^ " wins the map!", 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
    ClanMatchPoints2 += 1;

    WinnerMapClan = 2;
    
} 
}



---LadderPoints---

if (ClanMatchPoints1 >= S_MatchPoints) { SetMatchWinner(1); MB_StopMatch = True; }
if (ClanMatchPoints2 >= S_MatchPoints) { SetMatchWinner(2); MB_StopMatch = True; }
log(MatchWinner());
if (!Tournament) Header(""); else Header("");
MB_Sleep(500);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
Score::RoundEnd();
Score::MatchEnd(True);
UIManager.UIAll.BigMessageSoundVariant = 0;
MB_Sleep(500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

while(!UIManager.UIAll.UISequenceIsCompleted) {
  MB_Yield();
}


if (ClanMatchPoints1 >= S_MatchPoints || ClanMatchPoints2 >= S_MatchPoints) {
if ((MatchWinner() == 1 || ClanMatchPoints1 >= S_MatchPoints) && ClanMatchPoints1 != ClanMatchPoints2) {
Message::SendBigMessage(Teams[0].ColorizedName ^ " wins the match!", 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
ClanMatchPoints1 = 0; ClanMatchPoints2 = 0;
declare Game_SectionNb = 0;
Game_SectionNb = 0;
}
if ((MatchWinner() == 2 || ClanMatchPoints2 >= S_MatchPoints) && ClanMatchPoints1 != ClanMatchPoints2) {
Message::SendBigMessage(Teams[1].ColorizedName ^ " wins the match!", 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
ClanMatchPoints1 = 0; ClanMatchPoints2 = 0;
declare Game_SectionNb = 0;
Game_SectionNb = 0;
}
MB_Sleep(2000);
}
}
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.BigMessage = "";

declare SecondMap = Now + 10 * 1000;
SecondMap = Now + 10 * 1000;
declare IsFinished = False;
IsFinished = False;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
// Give GEsCoins
foreach (Player in Players) {
if (!MatchEndRequested) {
declare persistent Coins for Player.User = 0;
declare TemporaryCoins for Player.User = 0;
declare TeamWork for Player = False;
declare TeamW for Player = 0;
declare NearMiss for Player = 0;
declare MostHits for Player = False;
declare MostCaptures for Player = False;
declare RunnerHits for Player = False;
declare netwrite AtkPoints for Player = 0;

if (TeamW > C_RequiW) TeamWork = True;

// 3 Max
for (Count, 0, 2)
if (Players.existskey(Count) && Player == Players[Count]) MostHits = True;
if (AtkPoints > C_RequiAtk) MostCaptures = True;
if (NearMiss > C_RequiMiss) RunnerHits = True;

if (TeamWork) {
Coins += 10;
TemporaryCoins += 10; }
if (MostHits) {
Coins += 8;
TemporaryCoins += 8; }
if (MostCaptures) {
Coins += 9;
TemporaryCoins += 9; }
if (RunnerHits) {
Coins += 5;
TemporaryCoins += 5; }

Coins += 1;
TemporaryCoins += 1;

declare ChatUI <=> UIManager.GetUI(Player);
if (ChatUI != Null) { ChatUI.SendChat("""You won $f70{{{TemporaryCoins}}} GsCoins! $z$s( {{{Coins}}} Total GsCoins )""");
ChatUI.StatusMessage = """You won $f70{{{TemporaryCoins}}} GsCoins! $z$s( {{{Coins}}} Total GsCoins )""";
declare netwrite GsCoins for Teams[0] = Coins;

}

TemporaryCoins = 0;
TeamWork = False;
MostHits = False;
MostCaptures = False;
RunnerHits = False;
}
}


while(Now < SecondMap) {
yield;
declare Integer SecondTick;
if (Now > 10) { IsFinished = True; }
if (Now > SecondTick) {
Message::SendBigMessage("$f82"^(SecondMap / 1000) - (Now / 1000), 600, 1, CUIConfig::EUISound::Silence, 0);
SecondTick = Now + 1000;
}

UIManager.UIAll.StatusMessage = "";
foreach (Player in Players) {
declare ChatUI <=> UIManager.GetUI(Player);
if (ChatUI != Null) ChatUI.StatusMessage = "";
}

declare IsRematch = False;			///< Do the players want a rematch ?
declare RematchNb = 0;				///< Number of consecutive rematch

}
Message::CleanBigMessages();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
***



***EndMatch***
***
Script_Section = "Warm-Up";
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
Interface::DestroyRank();
SpawnScreen1::DestroyRules();
SpawnScreen1::DestroyScores();
SpawnScreen1::DestroyMapInfo();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

Void PlaySound(CUIConfig::EUISound _Sound, Integer _Variant) {
  UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, _Sound, _Variant);
}

Void SendNotice(Text _Input) {
  UIManager.UIAll.SendNotice(_Input, CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}

Void SendNotice(Text _Input, CSmPlayer Player) {
  declare PlayerUI <=> UIManager.GetUI(Player);
if (PlayerUI != Null)
  PlayerUI.SendNotice(_Input, CUIConfig::ENoticeLevel::MapInfo , Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}



Void View(Ident Id) {
foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		UIManager.UIAll.SpectatorForcedTarget = Id;
		UIManager.UIAll.SpectatorCamAutoRadius = 100.;
		 }
foreach (S in Spectators) {
				declare UI <=> UIManager.GetUI(S);
		if (UI == Null) continue;
		UIManager.UIAll.SpectatorForcedTarget = Id;
		UIManager.UIAll.SpectatorCamAutoRadius = 100.;

}
}

Ident GoalId()
{
declare Ident GoalView;
declare Text NotCaptured;
foreach (Goal in Goals) {
//if (Goal.Gauge.ValueReal > 0.95 && Goal.Tag == NotCaptured)
//{
GoalView = Goal.Id;
//}
}
 return GoalView;
}


Void SpawnThemAll() 
{

  declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
  declare AtkSpawn <=> Map::GetPlayerSpawn("SpawnAttack", 0);
  
  // Warmup classic/free || Waiting time
    foreach (Player in Players) { 
      declare WarmUpSide2 for Player = 0;
      if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
      SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_WURocketAmmoMax);
      SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_WULaserAmmoMax);
      SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
    
      Player.ArmorMax = 300;
      if (WarmUpSide2 == 0) {
        Player.AmmoGain = 1. * C_WULaserAmmoGain;
        Player.StaminaMax = 1.;
        Player.StaminaGain = 1.;
        
        SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
        SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, AtkSpawn, Now);
        //SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
WarmUpSide2 = 1;
      } else if (WarmUpSide2 == 1) {
        Player.AmmoGain = 1. * C_WURocketAmmoGain;
        Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
        Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
        SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
        SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, DefSpawn, Now);
WarmUpSide2 = 2;
        //SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
      } else if (WarmUpSide2 == 2) {
        Player.AmmoGain = 1. * C_WUNucleusAmmoGain;
        Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
        Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
       // SetPlayerWeapon(Player, CSmMode::EWeapon::Nucleus, True);
        SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, DefSpawn, Now);
        WarmUpSide2 = 0;
      }
      Player.IsHighlighted = True;
      
    }
  

}

Void ManageCommand() {
  foreach (Event in PendingEvents) {
    if (Event.Type == CSmModeEvent::EType::OnCommand) {
      switch (Event.CommandName) {
        // ---------------------------------- //
        case "Command_ForceWarmUp": {
          if (Event.CommandValueBoolean) {
            G_Override_NeedWarmUp = True;
          }
        }
        // ---------------------------------- //
        case "Command_ForceClublinkReload": {
          if (Event.CommandValueBoolean) {
            G_Override_ForceClublinkReload = True;
          }
        }
      }
    }
  }
}

// ---------------------------------- //
/** Helper for the DisplayHitFunction
 *
 * @param _Player   The player who'll receive the notice
 * @param _Message  The message for the notice
 */
Void NoticeHitDistance(CSmPlayer _Player, Text _Message) {
  declare UI <=> UIManager.GetUI(_Player);
  Message::SendBigMessage(_Player, _Message, 2000, 2);
}



// ---------------------------------- //
/** Display the distance between the shooter and the victim
 *
 *  @param  _Shooter    The shooter
 *  @param  _Victim     The Victim
 *  @param  _ShooterOnly  Display the distance hit message to the shooter only
 */
Void DisplayHitDistance(CSmPlayer _Shooter, CSmPlayer _Victim, Boolean _ShooterOnly) {
  if (_Shooter == Null || _Victim == Null) return;
  
  declare Distance = MathLib::Distance(_Shooter.Position, _Victim.Position);
  Distance = MathLib::NearestInteger(Distance*10.0)/10.0;
  declare DistanceText = TextLib::SubString(TextLib::ToText(Distance), 0, 5);
  declare DistanceSplit = TextLib::Split(".", DistanceText);
  if (DistanceSplit.count == 1) DistanceText = DistanceSplit[0];
  declare DistanceMessage = TextLib::Compose(_("%1m hit!"), DistanceText);
  if (_ShooterOnly) {
    NoticeHitDistance(_Shooter, DistanceMessage);
  } else {
    
    foreach (Spectator in Spectators) {
      NoticeHitDistance(Spectator, DistanceMessage);
    }
    if (Distance > G_LongestRailDistance) {
      G_LongestRailName = _Shooter.Name;
      G_LongestRailDistance = Distance;
    }
  }
}

Void SetMatchWinner(Integer _Clan) {
declare MatchWinner1 = False;
declare MatchWinner2 = False;

if (_Clan == 1) {
 MatchWinner1 = True;
 MatchWinner2 = False;
}
else if (_Clan == 2) {
 MatchWinner2 = True;
 MatchWinner1 = False;
} else if (_Clan == 3) {
 MatchWinner2 = False;
 MatchWinner1 = False;
}

 }

Integer MatchWinner() {
declare Boolean MatchWinner1; declare Boolean MatchWinner2; declare Winner = -1;

if (MatchWinner1 == True) Winner = 1;
if (MatchWinner2 == True) Winner = 2;
if (MatchWinner1 == False && MatchWinner2 == False) Winner = 3;

return Winner;
} 


// ---------------------------------- //
/** Update the spectators
 *
 *	@param	_Forced		Force the update
 */
Void Spectators(Boolean _Forced) {
	if (!_Forced && G_LastSpecUpdate + 250 > Now) return;
	G_LastSpecUpdate = Now;
	UIManager.UIAll.SpectatorCamAutoLongitude = MathLib::Atan2(-G_MapSpecCamDirection.X, -G_MapSpecCamDirection.Z);
	UIManager.UIAll.SpectatorCamAutoLatitude = 0.5;
	
	UIManager.UIAll.SpectatorAutoTarget = G_RocketPlayerId;
	
	declare SpecDefId = NullId;
	foreach (Player in Players) {
		if (Player.CurrentClan == G_DefClan && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			SpecDefId = Player.Id;
		}
	}
	
	foreach (Player in Players) {		
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		// Can select defender to spec
		if (Player.CurrentClan != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = Player.CurrentClan;
		} else if (MM_GetRequestedClan(Player) != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = MM_GetRequestedClan(Player);
		} else {
			UI.SpectatorForceCameraType = -1;
			UI.SpectatorForcedClan = -1;
		}
		
		declare PrevSpectatorForcedClan for UI = -1;
		PrevSpectatorForcedClan = UI.SpectatorForcedClan;
	}
	
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
			
		if (UI.SpectatorForceCameraType >= 0 || UI.SpectatorForcedClan >= 0) {
			UI.SpectatorForceCameraType = -2;
			UI.SpectatorForcedClan = -2;
			
			declare PrevSpectatorForcedClan for UI = -1;
			if (PrevSpectatorForcedClan != UI.SpectatorForcedClan) {
				PrevSpectatorForcedClan = UI.SpectatorForcedClan;
					UIManager.UIAll.SendChat(TextLib::Compose("$<%1$> goes into spectator mode", Spectator.Name));
			}
		}
	}
}
Void Spectators() {
	Spectators(False);
}

Text Get_FrameMarkers()
{
declare Folder = "file://Media/Manialinks/Shootmania/Common";
return """
<frame id="Rocket"/>
<quad posn="0 0 -2" sizen="40 10" image="{{{Folder}}}/RocketWhite.dds" halign="center" valign="center"/>
</frame>
<frame id="Laser"/>
<quad posn="0 0 -2" sizen="40 10" image="{{{Folder}}}/RocketWhite.dds" halign="center" valign="center"/>
</frame>
""";
}

// ---------------------------------- //
/** Get the current mode of the script
 *  0 -> classic mode
 *  1 -> free mode
 *
 *  @return   The current mode of the script
 */
Integer GetMode() {
  declare Mode = S_Mode;
  if (Mode != C_ModeClassic && Mode != C_ModeFree) Mode = C_ModeClassic;
  return Mode;
}
Void UpdateMarkers(Integer _Mode) {
// Set the marker above the goal
  UIManager.UIAll.MarkersXML = "";
  declare Folder = "file://Media/Manialinks/Shootmania/Common";
  declare AtkPlayerLogin1 = "";
  declare AtkPlayerLogin2 = "";
  declare TeamAtkC = "";
  TeamAtkC = TextLib::ColorToText(Teams[1].ColorPrimary);

  declare LayerUpdated = O_Layers::Update("Markers", Get_FrameMarkers());
  declare Nuc = "";
  if (Players.existskey(G_RocketPlayerId)) AtkPlayerLogin1 = Players[G_RocketPlayerId].Login;
  if (Players.existskey(G_LaserPlayerId)) AtkPlayerLogin2 = Players[G_LaserPlayerId].Login;
  if (Players.existskey(G_Nuc)) Nuc = Players[G_Nuc].Login;
  
  declare Slot1 = "";
  if (AtkPlayerLogin1 != "") {
    Slot1 = """
<frame id="test1">
<quad halign="center" valign="center" sizen="20 5" style="Bgs1InRace" substyle="BgWindow4" />
</frame>
<marker imageurl="{{{Folder}}}/RocketWhite.dds" manialinkframeid="test1"   visibility="WhenInFrustum" bgcolor="{{{TeamAtkC}}}" playerlogin="{{{AtkPlayerLogin1}}}" box="0 2 0" />""";
  }
    declare Slot2 = "";
  if (AtkPlayerLogin2 != "") {
    Slot2 = """
<frame id="test2">
<quad halign="center" valign="center" sizen="20 5" style="Bgs1InRace" substyle="BgWindow4" />
</frame>
<marker  imageurl="{{{Folder}}}/LaserWhite.dds" manialinkframeid="test2"  visibility="WhenInFrustum" playerlogin="{{{AtkPlayerLogin2}}}" box="0 2 0" />""";
  }
      declare NucMarker = "";
  if (Nuc != "" && !S_Tournoi) {
    NucMarker = """<marker icon="Player3" playerlogin="{{{Nuc}}}" box="0 2 0" />""";
  }
  
  declare PolesMarker = "";
  foreach (LandmarkGauge in MapLandmarks_Gauge) {
    declare Icon = "";
    declare Name = "";
    if (LandmarkGauge.Tag == "Goal A") { Icon = "PointA"; Name = "$w$s$oA"; }
    else if (LandmarkGauge.Tag == "Goal B") { Icon = "PointB"; Name = "$w$s$oB"; }
    else if (LandmarkGauge.Tag == "Goal C") { Icon = "PointC"; Name = "$w$s$oC"; }
    else continue;
    PolesMarker ^= """<marker icon="{{{Icon}}}"  pos="{{{LandmarkGauge.Position.X}}} {{{LandmarkGauge.Position.Y + 25}}} {{{LandmarkGauge.Position.Z}}}" />""";
  }
    
  foreach (Player in Players) {
    declare UI <=> UIManager.GetUI(Player);
    if (UI == Null) continue;
   if (_Mode == 1) {
    if (Player.CurrentClan == G_AtkClan && (Player.Login != AtkPlayerLogin1 || Player.Login != AtkPlayerLogin2)) {
      UI.MarkersXML = Slot1 ^ Slot2 ^ PolesMarker;
    } else if (Player.CurrentClan == G_DefClan) {
      UI.MarkersXML = PolesMarker ^ NucMarker;
    }
 else if (_Mode == 0) UI.MarkersXML = PolesMarker;
    }
  }
  foreach (Spectator in Spectators) {
    declare UI <=> UIManager.GetUI(Spectator);
    if (UI == Null) continue;
 if (_Mode == 1) {
    UI.MarkersXML = PolesMarker ^ Slot1 ^ Slot2 ^ NucMarker;
} else if (_Mode == 0) UI.MarkersXML = PolesMarker;
  }

  foreach (Player in Players) {
    declare UI <=> UIManager.GetUI(Player);
  if (_Mode == 0) UI.MarkersXML = PolesMarker;
}
}


Text Info (){
declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
  declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);

//G_MapScores				= [1 => 0, 2 => 0];
    declare Text MLText = """

<quad posn="-164 91 0" sizen="330 20" bgcolor="FFFA" style="Bgs1InRace" substyle="BgGradTop"/>
<label posn="158 89" halign="right" scale="0.8" text="$s$i$f60Cham$fffPion $f60S$ffftable"/>
<quad posn="110 92 -10" sizen="60 23" style="Bgs1InRace" substyle="BgGradRight"/>
<quad posn="110 92 -11" sizen="60 23" style="Bgs1InRace" substyle="BgGradRight"/>
<label posn="151 85.5" halign="right" scale="0.6" text="!" id="MapName"/>
<quad posn="158 85.5 1" halign="right" sizen="10 10" scale="0.6" style="UIConstruction_Buttons" substyle="Stats" />
<label halign="center" valign="center2" style="TextRaceChrono" textcolor="FB0" textsize="6" text="" id="Label_Countdown"/>
<label posn="151 83" halign="right" scale="0.6" text="$i$sBy $f60!" id="MapAuthor"/>
<label posn="148 79.5" halign="right" scale="0.4" sizen="50 5" text="$w$iHow to Play"/>
<quad posn="158 80" halign="right" scale="0.6" sizen="50 5" manialink="http://lanteam.cloudcraft.fr/ges.xml" style="BgsPlayerCard" substyle="ProgressBar" scriptevents="1"/>

<frame hidden="1" class="LibManialink_Tooltip" id="closeframe">
  <label posn="0 0 1" sizen="48 4" halign="center" valign="center2" textsize="1.5" textcolor="aaa" id="Tooltip_Message" />
  <quad sizen="50 6" halign="center" valign="center" bgcolor="000d" id="Tooltip_BoundingBox" />
</frame>

<frame id="sirch" posn="0 -71 100" hidden="1" >
<frame posn="0 0 200">
<label halign="center" valign="center" posn="0 100 1" text="Loading" autonewlines="1" id="result" style="TextButtonBig"  />
<quad sizen="10 10" rot="-90" style="Icons128x128_1" halign="center" valign="center" posn="0 -5 1" scriptevents="1" id="closeframe"  class="LibManialink_TooltipShow" substyle="BackFocusable" />
</frame>
<frame posn="0 0 100">
<quad posn="-164 185 0" sizen="330 40" bgcolor="FFFA" style="Bgs1InRace" substyle="BgGradTop"/>
<quad posn="-164 165 0" sizen="330 20" bgcolor="FFFA" style="Bgs1InRace" substyle="BgGradTop"/>
<quad posn="-164 20 0" sizen="330 40" style="Bgs1InRace" substyle="BgGradBottom" />
<quad posn="-164 0 0" sizen="330 20" style="Bgs1InRace" substyle="BgGradBottom" />
<quad halign="center" valign="center" posn="0 0 -1" sizen="500 500" style="Bgs1" substyle="BgDialogBlur" opacity="0.5" />
</frame>
</frame>

  <frame posn="-5 100" id="top" scale="0.35" >
  <frame id="top1" posn="0 0" opacity="0" scale="1.0">
    <label posn="-16 86 4" sizen="20 5" text="{{{ClanScores[1]}}}" id="Point1" style="TextRaceChrono" scale="0."/>
    <label posn="23 86 4" sizen="20 5" text="{{{ClanScores[2]}}}" id="Point2" style="TextRaceChrono"  scale="0."/>
    <label posn="-35 86 4" sizen="40 5" text="$999{{{ClanMatchPoints1}}}" id="cmp1"   colorize="666" style="TextRaceChrono" opacity="0.1" scale="0."/>
    <label posn="41 86 4" sizen="40 5" text="$999{{{ClanMatchPoints2}}}" id="cmp2"    colorize="666" style="TextRaceChrono" opacity="0.1" scale="0."/>
    <quad posn="2 76 4" sizen="5 5" opacity="0.5" id="search" style="Icons64x64_1" substyle="Maximize" scriptevents="1" />
        <quad id="q1" posn="14 90 1" sizen="23 12" colorize="000"  bgcolor="FFFA" clan="2"  style="UiSMSpectatorScoreBig" substyle="BotRight"/>
    <quad id="q2" posn="-27 90 1" sizen="24 12" colorize="000"  bgcolor="FFFA"  clan="1" style="UiSMSpectatorScoreBig" substyle="BotLeft"/>
    
  </frame>
</frame>


<script><!--
	{{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
{{{Manialink::DumpLib()}}}

Void Events()
{
declare FrameIsHide = False;
declare FrameSearch <=> (Page.GetFirstChild("sirch") as CMlFrame);
foreach (Event in PendingEvents) {
  if (Event.Type == CMlEvent::Type::MouseClick) {
    if (Event.ControlId == "search") {
FrameSearch.Show();
FrameIsHide = False;
} else if (Event.ControlId == "closeframe")
{
FrameSearch.Hide();
FrameIsHide = True;
}
}
}
}

main() {
declare MapName	<=> (Page.GetFirstChild("MapName")	as CMlLabel);
declare FrameSearch <=> (Page.GetFirstChild("sirch") as CMlFrame);
declare MapAuthor	<=> (Page.GetFirstChild("MapAuthor")	as CMlLabel);
declare label_result	<=> (Page.GetFirstChild("result")	as CMlLabel);
declare Point1	<=> (Page.GetFirstChild("Point1")	as CMlLabel);
declare Point2	<=> (Page.GetFirstChild("Point2")	as CMlLabel);
declare netread Integer  Map1 for UI;
declare netread Integer  Map2 for UI;
declare netread Integer  P1 for UI;
declare netread Integer  P2 for UI;
declare netread Text MapNameT for UI;
declare netread Text MapAuthorT for UI;
declare FrameIsHide = False;
declare Anim = Now + 5000;
declare Anim2 = Now - 1;
declare HttpRequestTime = Now;
declare Req = Http.CreateGet("http://lanteam.cloudcraft.fr/test.html", False);
declare Text Result;
declare Ping for UI = 0;
Ping = 0;
while (!Req.IsCompleted) { yield; Ping += 1;}
if (Req.IsCompleted) {
Result = Req.Result;
label_result.SetText(Result);
if (Ping > 20) log("WARNING! HIGH PING!");
}

while (True) {
yield;
Point1.SetText(""^ClanScores[1]);
Point2.SetText(""^ClanScores[2]);
MapName.SetText(""^MapNameT);
MapAuthor.SetText("$f60by $fff"^MapAuthorT);
Events();

if (HttpRequestTime < Now)
{
declare Ping for UI = 0;
HttpRequestTime = Now + 1500;
while (!Req.IsCompleted) { yield; }
if (Req.IsCompleted) {
Result = Req.Result;
label_result.SetText(Result);
}
}

										while(Anim > Now)
		{
		yield;
		sleep(80);
        LibManialink_AnimLoop();
        LibManialink_Anim({{{Manialink::Inject("""<frame id="top" posn="-5 0 0" scale="1." rot="0" />""")}}}, 4500, "EaseOutElastic");
Events();
Anim2 = Now + 2000;
		}
		
		while(Anim2 > Now && Now > Anim)
		{
		yield;
		sleep(80);
		LibManialink_AnimLoop();
		LibManialink_Anim({{{Manialink::Inject("""<quad id="q1" colorize="{{{Team2Color}}}" />""")}}}, 4500, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<quad id="q2" colorize="{{{Team1Color}}}" />""")}}}, 4500, "EaseOutElastic");
		LibManialink_Anim({{{Manialink::Inject("""<label sizen="20 5" id="cmp1" opacity="1" scale="0.4"/>""")}}}, 4500, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<label sizen="20 5" id="cmp2" opacity="1" scale="0.4"/>""")}}}, 4500, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<label sizen="20 5" id="Point1" opacity="1" scale="0.5"/>""")}}}, 4500, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<label sizen="20 5" id="Point2" opacity="1" scale="0.5"/>""")}}}, 4500, "EaseOutElastic");
Events();
		}


}
}
--></script>

    """;

    return MLText;
/*declare Quad_SummaryRight <=> (Page.GetFirstChild("Quad_SummaryRight") as CMlQuad);
declare Quad_SummaryLeft  <=> (Page.GetFirstChild("Quad_SummaryLeft") as CMlQuad);

Quad_SummaryLeft.Colorize = Teams[1].ColorPrimary;
Quad_SummaryRight.Colorize = Teams[2].ColorPrimary;*/
}

Text Info2 (){
declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
  declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
//G_MapScores				= [1 => 0, 2 => 0];
    declare Text MLText = """
<frame posn="-30 -18 10" scale="1.2">
<quad posn="-164 91 0" sizen="330 20" bgcolor="FFFA" style="Bgs1InRace" substyle="BgGradTop"/>
<label posn="158 89" halign="right" scale="0.8" text="$s$i$f60Cham$fffPion $f60S$ffftable"/>
<label posn="-68 82.5" halign="left" scale="1.2" text="!" id="MapName"/>
<quad posn="-88 85.5 1" halign="left" sizen="10 10" scale="1.5" style="UIConstruction_Buttons" substyle="Stats" />
<label halign="center" valign="center2" style="TextRaceChrono" textcolor="FB0" textsize="6" text="" id="Label_Countdown"/>
<label posn="-68 76" halign="left" scale="1.2" text="$i$sBy $f60!" id="MapAuthor"/>

</frame>

  <frame posn="-15 -120" id="top" scale="2." >
  <frame id="top1" posn="0 0" opacity="0" scale="1.0">
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
    <label posn="-13 86 4" sizen="20 5" text="{{{ClanScores[1]}}}" id="Point1" style="TextRaceChrono" scale="0.5"/>
    <label posn="20 86 4" sizen="20 5" text="{{{ClanScores[2]}}}" id="Point2" style="TextRaceChrono"  scale="0.5"/>
    <label posn="-32 86 4" sizen="20 5" text="$999{{{ClanMatchPoints1}}}"  colorize="666" style="TextRaceChrono" opacity="1" scale="0.4"/>
    <label posn="38 86 4" sizen="20 5" text="$999{{{ClanMatchPoints2}}}"  colorize="666" style="TextRaceChrono" opacity="1" scale="0.4"/>
    
        <quad id="q1" posn="3 90 1" sizen="32 12" colorize="{{{Team2Color}}}"  bgcolor="FFFA" clan="2"  style="UiSMSpectatorScoreBig" substyle="BotRight"/>
    <quad id="q2" posn="-26 90 1" sizen="32 12" colorize="{{{Team1Color}}}"  bgcolor="FFFA"  clan="1" style="UiSMSpectatorScoreBig" substyle="BotLeft"/>
    
<quad posn="-92.5 100 -20" sizen="400 120" image="" style="ManiaPlanetMainMenu" substyle="MainBg" /> 
  </frame>
</frame>


<script><!--
main() {
declare MapName	<=> (Page.GetFirstChild("MapName")	as CMlLabel);
declare MapAuthor	<=> (Page.GetFirstChild("MapAuthor")	as CMlLabel);
declare Point1	<=> (Page.GetFirstChild("Point1")	as CMlLabel);
declare Point2	<=> (Page.GetFirstChild("Point2")	as CMlLabel);
declare netread Integer  Map1 for UI;
declare netread Integer  Map2 for UI;
declare netread Integer  P1 for UI;
declare netread Integer  P2 for UI;
declare netread Text MapNameT for UI;
declare netread Text MapAuthorT for UI;
while (True) {
yield;
Point1.SetText(""^ClanScores[1]);
Point2.SetText(""^ClanScores[2]);
MapName.SetText(""^MapNameT);
MapAuthor.SetText("$f60by $fff"^MapAuthorT);
}
}
--></script>

    """;

    return MLText;
/*declare Quad_SummaryRight <=> (Page.GetFirstChild("Quad_SummaryRight") as CMlQuad);
declare Quad_SummaryLeft  <=> (Page.GetFirstChild("Quad_SummaryLeft") as CMlQuad);

Quad_SummaryLeft.Colorize = Teams[1].ColorPrimary;
Quad_SummaryRight.Colorize = Teams[2].ColorPrimary;*/
}


Void WarmUp() {
  XmlRpc::BeginWarmUp();
  +++StartWarmUp+++
  
  if (MB_UseScriptCallbacks && XmlRpc::CallbackIsAllowed("BeginWarmup")) XmlRpc::SendCallback("BeginWarmup", Json::Enfold(Json::Stringify("AllReady", False)));
  
  // Shutdown the poles during warmup
  foreach (Goal in MapLandmarks_Gauge) {
    Goal.Gauge.Clan = 0;
    Goal.Gauge.Speed = 0;
    Goal.Gauge.Value = 0;
    Goal.Gauge.Max = 1000;
    Goal.Gauge.Captured = False;
  }
  SM::UnspawnAllPlayers();
  Message::CleanBigMessages();
  UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
  UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Silence;
  UIManager.UIAll.BigMessageSoundVariant = 0;
  UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
  if (G_Override_NeedWarmUp) UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Pause"));
  else UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
  PlaySound(CUIConfig::EUISound::PhaseChange, 0);
  
  WarmUp2::Begin();
  CH_UI::Loop();
  // Init players
  foreach (Player in Players) {
    SetPlayerClan(Player, MM_GetRequestedClan(Player));
    if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
    else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
  }
  WarmUp2::Clean();
  WarmUp2::Fill();
  declare PrevWarmUpDuration = S_WarmUpDuration-1;
  declare PrevMode = -1;

  
WarmUp2::SetAllSlotsIcons("Clan1", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
WarmUp2::SetAllSlotsIcons("Clan2", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
for (Count, 1, 2) {
log(Count);
WarmUp2::SetSlotIcon("Clan"^Count, G_RocketSlot[Count], "file://Media/Manialinks/ShootMania/Common/Laser.dds");
WarmUp2::SetSlotIcon("Clan"^Count, G_LaserSlot[Count], "file://Media/Manialinks/ShootMania/Common/Laser.dds");
}
  
  while (!WarmUp2::Stop()) {
    MM_Yield();
 
foreach (Player in Players) {
declare persistent Coins for Player.User = 0;
declare netwrite GsCoins for Player.Score = Coins;
GsCoins = Coins;
}
 
    ManageCommand();
    //ForceClublinkReload();
    
    // Let the server sleep if there's no players on it
    if (PlayersNbTotal <= 0) continue;
    
    foreach (Player in Players) {
      if (Player.CurrentClan != MM_GetRequestedClan(Player)) {
        UnspawnPlayer(Player);
        SetPlayerClan(Player, MM_GetRequestedClan(Player));
        if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
        else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
      }
    }
    
    if (PrevMode != GetMode() || PrevWarmUpDuration != S_WarmUpDuration) {
      PrevMode = GetMode();
      PrevWarmUpDuration = S_WarmUpDuration;
      
      declare LongTimer = S_WarmUpDuration*1000;
      declare ShortTimer = 5000;
      if (LongTimer <= 0) { LongTimer = 0; ShortTimer = 0; }
      
      if (GetMode() == C_ModeClassic) {
        WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-2, S_NbPlayersPerTeam], LongTimer => [2, S_NbPlayersPerTeam]]);
        WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-2, S_NbPlayersPerTeam], LongTimer => [2, S_NbPlayersPerTeam]]);
      } else {
        WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
        WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
      }
    }

    WarmUp2::Loop();
    Spectators();
Clublink::DefineTeamAuto();
    SpawnThemAll();
CH_UI::Loop();
//Layers::Update("TopBar", Info());
Layers::Update("TopBar2", Info2());
Layers::Attach("ST");
////Layers::Attach("TopBar");
Layers::Attach("TopBar2");
foreach (Player in Players) {
    declare PlayerClan for Player.User = 0;
PlayerClan = Player.CurrentClan;
}
    UpdateMarkers(0);

foreach (Player in Players) {
declare UI <=> UIManager.GetUI(Player);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}

foreach (Spectator in Spectators) {
declare UI <=> UIManager.GetUI(Spectator);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}

foreach (Goal in Goals) {
//if (Goal.Gauge.ValueReal > 0.95 && Goal.Tag == NotCaptured)
//{
UIManager.UIAll.SpectatorCamAutoLongitude = 0.;
UIManager.UIAll.SpectatorCamAutoLatitude = 0.;
//}
}
declare netwrite Ready_Nb1 for Teams[0] = 1;
declare netwrite Ready_Nb2 for Teams[0] = 1;
  if (S_Tournoi) {
 foreach (Player in Players) {
if(WarmUp2::IsReady(Player)) { 
Layers::Attach("Ready", Player);
Ready_Nb1 = WarmUp2::GetReadyPlayersNb("Clan1");
Ready_Nb2 = WarmUp2::GetReadyPlayersNb("Clan2");
   } else { Layers::Detach("Ready", Player); }
   }

   }

    ST2::SetFooterText("Rounds Max :"^S_Turn);
    WarmUp2::ManageEvents();
    foreach (Event in PendingEvents) {
      if (Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null && Event.WeaponNum == 1) {
        DisplayHitDistance(Event.Shooter, Event.Victim, True);
      }
       else if (Event.Type == CSmModeEvent::EType::OnPlayerAdded) {
        CH_UI::Rules(Event.Player);
       }
    }
  }
  
  WarmUp2::End();
  
  if (MB_UseScriptCallbacks && XmlRpc::CallbackIsAllowed("EndWarmup")) XmlRpc::SendCallback("EndWarmup", Json::Enfold(Json::Stringify("AllReady", True)));
  
  PlaySound(CUIConfig::EUISound::StartMatch, 0);
  UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
  UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
  UIManager.UIAll.StatusMessage = "";
  UIManager.UIAll.BigMessage = "";
  SM::UnspawnAllPlayers();
  
  // ---------------------------------- //
  // Update the players clublinks
  Clublink::SyncUpdate();
  
  
  +++EndWarmUp+++
  XmlRpc::EndWarmUp();
  if (!Tournament) Header(""); else Header("");
}

declare Text KillerName;
declare Text ChampionName;

Void Announce(Text _Input) {

// Win


if (_Input == "C_Def") UIManager.UIAll.StatusMessage = _("All defenders eliminated.");
else if (_Input == "C_Atk") UIManager.UIAll.StatusMessage = (KillerName^"$z eliminated a Champion! ("^ChampionName^"$z)");
else if (_Input == "C_Time") UIManager.UIAll.StatusMessage = _("Time limit reached.");
else if (_Input == "C_Cap") UIManager.UIAll.StatusMessage = _("Goal captured!");

else if (_Input == "Warmup") {
SendNotice("$f00==> $999No enought players");
SendNotice("$f00==> $dddMinimum of 2players per team");
}

else if (_Input == "Goal")
{
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::RankChange;
    UIManager.UIAll.BigMessageSoundVariant = 0;
    foreach (Player in Players) {
if (Player.User != Null) {
declare UI <=> UIManager.GetUI(Player.User);
if (Player.User.Language == "fr") { 
    UI.BigMessage = _("Le dernier Goal peut maintenant √™tre captur√©!");
}
if (Player.User.Language == "it") { 
    UI.BigMessage = _("Ora pu√≤ essere catturato l'ultimo goal.");
}
else { declare UI <=> UIManager.GetUI(Player.User); UI.BigMessage = _("The last goal can now be captured."); }
}
}
} else if (_Input == "Attack") {



declare TeamAtkName = "";
declare TeamDefName = "";
TeamAtkName = Teams[G_AtkClan - 1].ColorizedName;
TeamDefName = Teams[G_DefClan - 1].ColorizedName;

UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
UIManager.UIAll.BigMessageSoundVariant = 0;
UIManager.UIAll.StatusMessage = TextLib::Compose(
  _("$<%1$> attack - defense $<%2$>"), 
  TeamAtkName, 
  TeamDefName
);

  foreach (Player in Players) {
if (Player.User != Null) {
if (Player.User.Language == "fr") { declare UI <=> UIManager.GetUI(Player.User);Message::SendBigMessage(Player, TeamAtkName^"$z attaquent!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 
if (Player.User.Language == "it") { declare UI <=> UIManager.GetUI(Player.User);Message::SendBigMessage(Player, TeamAtkName^"$z stanno attacando!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 
else { declare UI <=> UIManager.GetUI(Player.User); Message::SendBigMessage(Player, TeamAtkName^"$z are attacking!", 2000, 10, CUIConfig::EUISound::Silence, 0); } } }


} else if (_Input == "Attacker") {
if (Players.existskey(G_Nuc) && !S_Tournoi) {
  declare Bomber = Players[G_Nuc];
  foreach (Player in Players) {
if (Player.User != Null  && !Tournament) {
if (Player.User.Language == "fr") { declare UI <=> UIManager.GetUI(Player.User);Message::SendBigMessage(Player, Bomber.Name^" $z$s"^Teams[G_DefClan - 1].ColorText^"est un soigneur!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 
if (Player.User.Language == "it") { declare UI <=> UIManager.GetUI(Player.User);Message::SendBigMessage(Player, Bomber.Name^" $z$s"^Teams[G_DefClan - 1].ColorText^"√® un guaritore!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 
else { declare UI <=> UIManager.GetUI(Player.User); Message::SendBigMessage(Player, Bomber.Name^" $z$s"^Teams[G_DefClan - 1].ColorText^"is an healer!", 2000, 10, CUIConfig::EUISound::Silence, 0); } } 

  }
}

declare CSmPlayer A1;
declare CSmPlayer A2;

if (G_RocketPlayerId != NullId) {
A1 = Players[G_RocketPlayerId];
} 
if (G_LaserPlayerId != NullId) {
A2 = Players[G_LaserPlayerId];
}

if (G_RocketPlayerId != NullId && G_LaserPlayerId != NullId) {
  foreach (Player in Players) {
if (Player.User != Null) {
if (Player.User.Language == "fr") { declare UI <=> UIManager.GetUI(Player.User);Message::SendStatusMessage(Player, A1.Name^" $z$888&$z "^A2.Name^" $z"^Teams[G_AtkClan - 1].ColorText^"$ssont des Champions!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 
if (Player.User.Language == "fr") { declare UI <=> UIManager.GetUI(Player.User);Message::SendStatusMessage(Player, A1.Name^" $z$888&$z "^A2.Name^" $z"^Teams[G_AtkClan - 1].ColorText^"$sare i Campioni!", 2000, 10, CUIConfig::EUISound::Silence, 0); } 

else { declare UI <=> UIManager.GetUI(Player.User); Message::SendStatusMessage(Player, A1.Name^" $z$888&$z "^A2.Name^" $z"^Teams[G_AtkClan - 1].ColorText^"$sare the Champions!", 2000, 10, CUIConfig::EUISound::Silence, 0); } } } }



}

}

Void UpdateSlot() {
    // Find and assign bomb carrier for the next round
/*
  declare LastCarried2 = -1;
  G_LaserPlayerId = NullId;
  foreach (Player in Players) {
    if (Player.RequestedClan != G_AtkClan) {
      // Wrong team
      continue;
    }
        if (Player.Id == G_RocketPlayerId) {
      // Wrong Slot
      break;
    }  
    
    
    declare LastCarriedBomb2 for Player.Score = -1;
    if (LastCarriedBomb2 < 0) {
      // Player didn't carry the bomb so far - Directly choose him
      G_LaserPlayerId = Player.Id;
      break;
    }
    
    if (G_LaserPlayerId == NullId) {
      // No player found so far - Queue him
      G_LaserPlayerId = Player.Id;
      LastCarried2 = LastCarriedBomb2;
      continue;
    }
    
    
    
    if (LastCarried2 <= LastCarriedBomb2) {
      // Another queued player is waiting longer than this one
      continue;
    }
    
    // Queue player
    G_LaserPlayerId = Player.Id;
    
    LastCarried2 = LastCarriedBomb2;
  }
  
  // Set bomb carry time for chosen player
  if (Players.existskey(G_LaserPlayerId)) {
    declare Integer LastCarriedBomb2 for Players[G_LaserPlayerId].Score;
    LastCarriedBomb2 = Now;
    
  } else {
    // No player available - Drop the bomb in an attack spawn

  }
  
  // SLOT 1 - Attack
  
    // Find and assign bomb carrier for the next round
  declare LastCarried1 = -1;
  G_RocketPlayerId = NullId;
  foreach (Player in Players) {
    if (Player.RequestedClan != G_AtkClan) {
      // Wrong team
      continue;
    }
          if (Player.Id == G_LaserPlayerId) {
      // Wrong Slot
      continue;
    } 
   
    

    
    declare LastCarriedBomb1 for Player.Score = -1;
    if (LastCarriedBomb1 < 0) {
      // Player didn't carry the bomb so far - Directly choose him
      G_RocketPlayerId = Player.Id;
      break;
    }
    
    if (G_RocketPlayerId == NullId) {
      // No player found so far - Queue him
      G_RocketPlayerId = Player.Id;
      LastCarried1 = LastCarriedBomb1;
      continue;
    }
    
    if (LastCarried1 <= LastCarriedBomb1) {
      // Another queued player is waiting longer than this one
      continue;
    }
    
    // Queue player
    G_RocketPlayerId = Player.Id;
    
    LastCarried1 = LastCarriedBomb1;
  }
  
  // Set bomb carry time for chosen player
  if (Players.existskey(G_RocketPlayerId)) {
    declare Integer LastCarriedBomb1 for Players[G_RocketPlayerId].Score;
    LastCarriedBomb1 = Now;
  } else {
    // No player available - Drop the bomb in an attack spawn

  }
  
    // Find and assign bomb carrier for the next round
  declare LastCarried = -1;
  G_Nuc = NullId;
  foreach (Player in Players) {
    if (Player.RequestedClan != G_DefClan) {
      // Wrong team
      continue;
    }
    
    
    
    declare LastCarriedBomb for Player.Score = -1;
    if (LastCarriedBomb < 0) {
      // Player didn't carry the bomb so far - Directly choose him
      G_Nuc = Player.Id;
      break;
    }
    
    if (G_Nuc == NullId) {
      // No player found so far - Queue him
      G_Nuc = Player.Id;
      LastCarried = LastCarriedBomb;
      continue;
    }
    
    if (LastCarried <= LastCarriedBomb) {
      // Another queued player is waiting longer than this one
      continue;
    }
    
    // Queue player
    G_Nuc = Player.Id;
    
    LastCarried = LastCarriedBomb;
  }
  
  // Set bomb carry time for chosen player
  if (Players.existskey(G_Nuc)) {
    declare Integer LastCarriedBomb for Players[G_Nuc].Score;
    LastCarriedBomb = Now;
    
  } else {
    // No player available - Drop the bomb in an attack spawn

  }
  */

// ---------------------------------- //
// Get the next rocket attacker
declare SleepMultiplier = 1.;		///< Multiply the different sleept times of the script by this value
declare PreTurnEndTime = Now + MathLib::NearestInteger(2500 * SleepMultiplier);
declare NextRocketName = "";
declare Clan = "Clan1";
if (G_AtkClan == 2) Clan = "Clan2";
declare SlotNb = WarmUp2::GetSlotsNb(Clan);
declare I = 0;

while (True) {
	if (G_RocketSlot[G_AtkClan] > S_NbPlayersPerTeam) G_RocketSlot[G_AtkClan] = 1;
	
	declare PlayerId = WarmUp2::GetSlot(Clan, G_RocketSlot[G_AtkClan]);
	if (PlayerId != NullId && Players.existskey(PlayerId)) {
		NextRocketName = Players[PlayerId].Name;
		G_RocketPlayerId = PlayerId;
		declare netwrite Net_Elite_AtkLogin for Teams[0] = "";
		declare netwrite Net_Elite_AtkSponsors for Teams[0] = Text[];
		Net_Elite_AtkLogin = Players[PlayerId].Login;
		log(NextRocketName);
		log(G_RocketPlayerId);
		break;
	}
	
	G_RocketSlot[G_AtkClan] += 1;
	I += 1;
	if (I >= SlotNb) break;
}

declare NextLaserName = "";
declare Y = 0;

while (True) {
	if (G_LaserSlot[G_AtkClan] > S_NbPlayersPerTeam) G_LaserSlot[G_AtkClan] = 1;
	
	declare PlayerId = WarmUp2::GetSlot(Clan, G_LaserSlot[G_AtkClan]);
	if (PlayerId != NullId && PlayerId != G_RocketPlayerId && Players.existskey(PlayerId)) {
		NextLaserName = Players[PlayerId].Name;
		G_LaserPlayerId = PlayerId;
		declare netwrite Net_Elite_AtkLogin for Teams[0] = "";
		declare netwrite Net_Elite_AtkSponsors for Teams[0] = Text[];
		Net_Elite_AtkLogin = Players[PlayerId].Login;
		log(NextLaserName);
		log(G_LaserPlayerId);
		break;
	}
	
	G_LaserSlot[G_AtkClan] += 1;
	Y += 1;
	if (Y >= SlotNb) break;
}

}

/**/ Void CheckEnd1(Text _Custom) {
/**/ if (_Custom == "") {
/**/ if (!UseRounds_B) {
/**/ ---EndMap---
/**/ } else ---CustomEndRound1---
/**/ }
/**/ if (_Custom == "Custom") {
/**/ if (!UseRounds_B) {
/**/ ---CustomEndMap---
/**/ } else ---CustomEndRound1---
/**/ }
}



Text Bouclier () {

return """
<quad posn="0 -90 15"  sizen="16 16" halign="center" valign="bottom" style="Icons128x32_1" substyle="PainterTeam" styleselected="1"  />
<quad posn="0 -90 14"  sizen="16 16" halign="center" valign="bottom" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" styleselected="1"  />
<label posn="-0.5 -82.5 16" scale="0.3" halign="center" valign="bottom" opacity="0.4" rot="25" sizen="30 30" text="xdxdxdxdxd" id="armor" />
<script><!--


main () {
declare netread Text event_victim for UI;
declare Label_Armor <=> (Page.GetFirstChild("armor") as CMlLabel);
while (True) {

yield;
Label_Armor.SetText("$sSHIELD");
}
}
--></script>
""";



}

Text Laser () {

return """
<quad posn="-20 -91 16"  sizen="16 16" halign="center" valign="bottom" style="Icons64x64_2" substyle="LaserHit"  />
<quad posn="0 -90 15"  sizen="16 16" halign="center" valign="bottom" style="Icons64x64_2" substyle="UnknownHit" styleselected="1"  />
<quad posn="0 -90 14"  sizen="16 16" halign="center" valign="bottom" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" styleselected="1"  />
<label posn="-0.5 -82.5 16" scale="0.4" halign="center" valign="bottom" opacity="0.4" rot="25" sizen="30 30" text="xdxdxdxdxd" id="armor" />
<label posn="-0.5 -65.5 16" scale="0.6" halign="center" valign="bottom" opacity="0.8" sizen="30 30" text="You are a Champion!"  />
<script><!--


main () {
declare netread Text event_victim for UI;
declare Label_Armor <=> (Page.GetFirstChild("armor") as CMlLabel);
while (True) {

yield;
Label_Armor.SetText("$sSHIELD");
}
}
--></script>
""";



}

Text Rocket () {

return """
<quad posn="-20 -91 16"  sizen="16 16" halign="center" valign="bottom" style="Icons64x64_2" substyle="RocketHit"  />
<quad posn="0 -90 15"  sizen="16 16" halign="center" valign="bottom" style="Icons64x64_2" substyle="UnknownHit" styleselected="1"  />
<quad posn="0 -90 14"  sizen="16 16" halign="center" valign="bottom" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" styleselected="1"  />
<label posn="-0.5 -82.5 16" scale="0.4" halign="center" valign="bottom" opacity="0.4" rot="25" sizen="30 30" text="xdxdxdxdxd" id="armor" />
<label posn="-0.5 -65.5 16" scale="0.6" halign="center" valign="bottom" opacity="0.8" sizen="30 30" text="You are a Champion!"  />
<script><!--


main () {
declare netread Text event_victim for UI;
declare Label_Armor <=> (Page.GetFirstChild("armor") as CMlLabel);
while (True) {

yield;
Label_Armor.SetText("$sSHIELD");
}
}
--></script>
""";



}

Text TimeSpawn() {
return """
<frame posn="150 -80">
<label posn="2 90.5 2" sizen="10 10" id="time" text="" style="TextPlayerCardScore" scale="1.3" />
<quad posn="0 94 0" sizen="10 10" bgcolor="FFFA" style="Bgs1InRace" substyle="ProgressBar" colorize="29f"/>
<quad posn="0 94 1" sizen="10 10" bgcolor="00FFFFAA" style="Bgs1" substyle="BgSlider" modulatecolor="00FFFFFF"/>
</frame>

<script><!--


main () {
declare Label_Armor <=> (Page.GetFirstChild("time") as CMlLabel);
declare netread Integer SettingTimer for UI;
while (True) {

yield;


foreach (Player in Players) {

}
}
}
--></script>
""";

}
/*
Text Info2 (){
declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
  declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
//G_MapScores       = [1 => 0, 2 => 0];
    declare Text MLText = """
<frame posn="-30 -18 10" scale="1.2">
<quad posn="-164 91 0" sizen="330 20" bgcolor="FFFA" style="Bgs1InRace" substyle="BgGradTop"/>
<label posn="158 89" halign="right" scale="0.8" text="$s$i$f60Cham$fffPion $f60S$ffftable"/>
<label posn="-68 82.5" halign="left" scale="1.2" text="!" id="MapName"/>
<quad posn="-88 85.5 1" halign="left" sizen="10 10" scale="1.5" style="UIConstruction_Buttons" substyle="Stats" />
<label halign="center" valign="center2" style="TextRaceChrono" textcolor="FB0" textsize="6" text="" id="Label_Countdown"/>
<label posn="-68 76" halign="left" scale="1.2" text="$i$sBy $f60!" id="MapAuthor"/>

</frame>

  <frame posn="-15 -120" id="top" scale="2." >
  <frame id="top1" posn="0 0" opacity="0" scale="1.0">
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
<quad posn="-100 120 -20" sizen="300 30" style="Bgs1" substyle="BgCardProperty" />
    <label posn="-13 86 4" sizen="20 5" text="{{{ClanScores[1]}}}" id="Point1" style="TextRaceChrono" scale="0.5"/>
    <label posn="20 86 4" sizen="20 5" text="{{{ClanScores[2]}}}" id="Point2" style="TextRaceChrono"  scale="0.5"/>
    <label posn="-32 86 4" sizen="20 5" text="$9990" id="Map1l"   colorize="666" style="TextRaceChrono" opacity="1" scale="0.4"/>
    <label posn="38 86 4" sizen="20 5" text="$9990" id="Map2l"   colorize="666" style="TextRaceChrono" opacity="1" scale="0.4"/>
    
        <quad id="q1" posn="3 90 1" sizen="32 12" colorize="{{{Team2Color}}}"  bgcolor="FFFA" clan="2"  style="UiSMSpectatorScoreBig" substyle="BotRight"/>
    <quad id="q2" posn="-26 90 1" sizen="32 12" colorize="{{{Team1Color}}}"  bgcolor="FFFA"  clan="1" style="UiSMSpectatorScoreBig" substyle="BotLeft"/>
    
<quad posn="-92.5 100 -20" sizen="400 120" image="" style="ManiaPlanetMainMenu" substyle="MainBg" /> 
  </frame>
</frame>


<script><!--
main() {
declare MapName <=> (Page.GetFirstChild("MapName")  as CMlLabel);
declare MapAuthor <=> (Page.GetFirstChild("MapAuthor")  as CMlLabel);
declare Map1l <=> (Page.GetFirstChild("Map1l")  as CMlLabel);
declare Map2l <=> (Page.GetFirstChild("Map2l")  as CMlLabel);
declare Point1  <=> (Page.GetFirstChild("Point1") as CMlLabel);
declare Point2  <=> (Page.GetFirstChild("Point2") as CMlLabel);
declare netread Integer  Map1 for UI;
declare netread Integer  Map2 for UI;
declare netread Integer  P1 for UI;
declare netread Integer  P2 for UI;
declare netread Text MapNameT for UI;
declare netread Text MapAuthorT for UI;
while (True) {
yield;
Map1l.SetText(""^Map1);
Map2l.SetText(""^Map2);
Point1.SetText(""^ClanScores[1]);
Point2.SetText(""^ClanScores[2]);
MapName.SetText(""^MapNameT);
MapAuthor.SetText("$f60by $fff"^MapAuthorT);
}
}
--></script>

    """;

    return MLText;
}
*/
CSmPlayer All() { declare CSmPlayer C; foreach(Player in AllPlayers) { C = Player; } return C; }

Void CheckClans(Boolean _Pause) {
if ((G_Override_NeedWarmUp) && !MM_IsMatchmakingServer()) {
if (!_Pause)
    //  Announce("Warmup");
    UIManager.UIAll.CountdownEndTime = -1;
    Message::CleanAllMessages();
   Layers::Detach("Rocket", All());
   Layers::Detach("Laser", All());
  declare Script_Section = "Warm-Up";
  Script_Section = "Warm-Up";
  Victory::SetRoundDrawIfNoWinner();
  WarmUp();
  MB_StopRound = True;
  MB_SectionTurnNb -= 1;
    G_Override_NeedWarmUp = False;
  
}
}




Text CreateLayerInfo() {
  declare ImgPath = "file://Media/Manialinks/Shootmania/Common/";
  declare ImgPathElite = "https://github.com/maniaplanet/game-modes/raw/master/TitlePack/Media/Manialinks/ShootMania/Elite/";
  declare ImgCheck = ImgPath^"CheckpointsLeft.dds";
  declare ImgArmor = ImgPath^"AttackerShieldLeft.dds";
  declare CheckpointHidden = 1;
  declare G_CheckpointsNb = 0;
  declare RocketIMG = "";
  declare LaserIMG = "";

if (!Tournament)
{
RocketIMG = """ style="Icons64x64_2" substyle="LaserHit" """;
LaserIMG = """ style="Icons64x64_2" substyle="LaserHit" """;
} else {
RocketIMG = """ style="Icons64x64_2" substyle="LaserHit" """;
LaserIMG = """ style="Icons64x64_2" substyle="LaserHit" """;
}

  if (G_CheckpointsNb > 0) CheckpointHidden = 0;

  return """
<manialink version="1" name="Elite:Info">
<frame id="Frame_Playing">
  <frame class="LibCustomUI_Module" id="Elite_Checkpoints">
    <frame posn="156 -80 64" hidden="{{{CheckpointHidden}}}" scale="0.7" id="Frame_Checkpoints">
      <quad sizen="8 8" halign="right" valign="bottom" image="{{{ImgCheck}}}" colorize="0.5 0.5 0.5" />
      <label posn="-10 4.1" textsize="5" halign="right" valign="center" textemboss="1" textcolor="ddd" text="0/{{{G_CheckpointsNb}}}" id="Label_Checkpoints" />
    </frame>
  </frame>
  <frame class="LibCustomUI_Module" id="Elite_AtkArmor">
    <frame posn="156 -88 64" scale="0.8" id="Frame_AtkArmor">
      <quad sizen="8 8" halign="right" valign="bottom" image="{{{ImgArmor}}}" colorize="0.5 0.5 0.5" />
      <label posn="-10 4.5" textsize="5" halign="right" valign="center" textemboss="1" textcolor="ddd" text="3" id="Label_ArmorsLeft" />
    </frame>
  </frame>
  <frame class="LibCustomUI_Module" id="Elite_GaugeCapture">
    <frame posn="0 -40 64" hidden="1" id="Frame_Capture">
      <label posn="0 6" halign="center" textsize="5" textemboss="1" text="100%" id="Label_Capture" />
      <gauge posn="0 0 1" sizen="140 8" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
<quad posn="0 0" sizen="140 8" halign="center" style="Bgs1InRace" substyle="BgButtonShadow" />
<quad posn="-1 -8 -1" sizen="43 22" halign="center" rot="180" style="UiSMSpectatorScoreBig" substyle="CenterShieldSmall" />
<quad posn="-15 20" sizen="8 8" {{{RocketIMG}}}  id="c1"  />
<quad posn="5 20" sizen="8 8" {{{LaserIMG}}}  id="c2"  />
    </frame>
  </frame>
  <frame class="LibCustomUI_Module" id="Elite_Sponsors">
    <frame posn="80 -88 64" hidden="1" id="Frame_Sponsors">
      <quad sizen="40 20" valign="bottom" id="Quad_Sponsor" />
    </frame>
  </frame>
</frame>
<script><!--
#Include "MathLib" as ML

#Const C_SponsorTime 5000

declare CMlFrame Frame_Sponsors;

Void UpdateSponsorsVisibility() {
  declare netread Text Net_Elite_AtkLogin for Teams[0];
  
  if (
    IsSpectatorMode
    && GUIPlayer != Null 
    && Net_Elite_AtkLogin != "" 
    && GUIPlayer.Login == Net_Elite_AtkLogin
  ) {
    Frame_Sponsors.Show();
  } else {
    Frame_Sponsors.Hide();
  }
}

Void UpdateSponsorImage(Integer _Key) {
  declare Quad_Sponsor <=> (Page.GetFirstChild("Quad_Sponsor") as CMlQuad);
  declare netread Text[] Net_Elite_AtkSponsors for Teams[0];
  
  if (!Net_Elite_AtkSponsors.existskey(_Key)) return;
  
  declare Url = Net_Elite_AtkSponsors[_Key];
  if (Http.IsValidUrl(Url)) Quad_Sponsor.ChangeImageUrl(Url);
}

main() {
  declare Frame_Playing   <=> (Page.GetFirstChild("Frame_Playing")    as CMlFrame);
  declare Label_Checkpoints <=> (Page.GetFirstChild("Label_Checkpoints")  as CMlLabel);
  declare Frame_Capture     <=> (Page.GetFirstChild("Frame_Capture")    as CMlFrame);
  declare Label_Capture     <=> (Page.GetFirstChild("Label_Capture")    as CMlLabel);
  declare Gauge_Capture     <=> (Page.GetFirstChild("Gauge_Capture")    as CMlGauge);
  declare Frame_AtkArmor    <=> (Page.GetFirstChild("Frame_AtkArmor")   as CMlFrame);
  declare Label_ArmorsLeft  <=> (Page.GetFirstChild("Label_ArmorsLeft")   as CMlLabel);
  declare c1  <=> (Page.GetFirstChild("c1")   as CMlQuad);
  declare c2  <=> (Page.GetFirstChild("c2")   as CMlQuad);
  
  Frame_Sponsors <=> (Page.GetFirstChild("Frame_Sponsors") as CMlFrame);
  
  declare netread Integer Net_Elite_CheckpointsCaptured for Teams[0];
  declare netread Text Net_Elite_AtkLogin for Teams[0];
  declare netread Text[] Net_Elite_AtkSponsors for Teams[0];
  declare netread Integer Net_Elite_AtkArmorsLeft for Teams[0];
  declare netread Boolean Net_RocketPlayer for Teams[0];
  declare netread Boolean Net_LaserPlayer for Teams[0];
  
  declare PrevUISequence = CUIConfig::EUISequence::Playing;
  declare PrevCheckpointsCaptured = 0;
  declare PrevGUIPlayerId = NullId;
  declare PrevIsSpectatorMode = False;
  declare PrevAtkArmorsLeft = -1;
  
  declare SponsorKey = 0;
  declare NextSponsorTime = 0;
  
  {{{CustomUI::InjectMLInit()}}}
  
  while (True) {

    yield;

        if (Net_LaserPlayer) { c2.Opacity = 1.; c2.Scale = 1.3; }
if (Net_RocketPlayer) { c1.Opacity = 1.; c1.Scale = 1.3; }
if (!Net_LaserPlayer) { c2.Opacity = 0.2; c2.Scale = 0.9; }
if (!Net_RocketPlayer) { c1.Opacity = 0.2; c1.Scale = 0.9; }



    if (InputPlayer == Null) continue;
    if (!PageIsVisible) continue;
    
    {{{CustomUI::InjectMLLoop()}}}
    
    if (PrevUISequence != UI.UISequence) {
      PrevUISequence = UI.UISequence;
      
      if (UI.UISequence == CUIConfig::EUISequence::Playing || UI.UISequence == CUIConfig::EUISequence::UIInteraction) {
        Frame_Playing.Show();
      } else {
        Frame_Playing.Hide();
      }
    }
    
    if (PrevCheckpointsCaptured != Net_Elite_CheckpointsCaptured) {
      PrevCheckpointsCaptured = Net_Elite_CheckpointsCaptured;
      Label_Checkpoints.SetText(Net_Elite_CheckpointsCaptured^"/{{{G_CheckpointsNb}}}");
    }
    
    if (PrevAtkArmorsLeft != Net_Elite_AtkArmorsLeft) {
      PrevAtkArmorsLeft = Net_Elite_AtkArmorsLeft;
      Label_ArmorsLeft.Value = ""^Net_Elite_AtkArmorsLeft;
    }
    
    if (GUIPlayer != Null && PrevGUIPlayerId != GUIPlayer.Id) {
      PrevGUIPlayerId = GUIPlayer.Id;
      NextSponsorTime = Now + C_SponsorTime;
      UpdateSponsorsVisibility();
      UpdateSponsorImage(SponsorKey);
    } else if (GUIPlayer == Null && Frame_Sponsors.Visible) {
      PrevGUIPlayerId = NullId;
      Frame_Sponsors.Hide();
    }
    
    if (PrevIsSpectatorMode != IsSpectatorMode) {
      PrevIsSpectatorMode = IsSpectatorMode;
      NextSponsorTime = Now + C_SponsorTime;
      UpdateSponsorsVisibility();
      UpdateSponsorImage(SponsorKey);
    }
    
    if (Frame_Sponsors.Visible && Now >= NextSponsorTime) {
      NextSponsorTime = Now + C_SponsorTime;
      if (Net_Elite_AtkSponsors.count > 0 && Net_Elite_AtkSponsors.existskey(0)) {
        SponsorKey += 1;
        if (!Net_Elite_AtkSponsors.existskey(SponsorKey)) SponsorKey = 0;
        UpdateSponsorImage(SponsorKey);
      }
    }


    
    declare CSmPlayer TargetPlayer;
    if (GUIPlayer != Null) TargetPlayer <=> GUIPlayer;
    else TargetPlayer <=> InputPlayer;
    
    if (IsSpectatorMode) {
      declare MaxValueReal = 0.;
      declare Clan = 0;
      foreach (LandmarkGauge in MapLandmarks_Gauge) {
        if (LandmarkGauge.Tag == "Checkpoint" || LandmarkGauge.Gauge.Speed <= 0) continue;
        if (LandmarkGauge.Gauge.ValueReal > MaxValueReal) {
          MaxValueReal = LandmarkGauge.Gauge.ValueReal;
          Clan = LandmarkGauge.Gauge.Clan;
        }
      }
      if (MaxValueReal > 0.) {
        if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
        Gauge_Capture.Ratio = MaxValueReal;
        Gauge_Capture.Clan = Clan;
        Label_Capture.Value = ML::FloorInteger(MaxValueReal * 100.)^"%";
      } else if (Frame_Capture.Visible) {
        Frame_Capture.Visible = False;
      }
    } else {
      if (
        TargetPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned
        && TargetPlayer.CapturedLandmark != Null 
        && TargetPlayer.CapturedLandmark.Tag != "Checkpoint"
        //&& TargetPlayer.CapturedLandmark.Gauge != Null
        // && TargetPlayer.CapturedLandmark.Gauge.Speed > 0 
        && TargetPlayer.CapturedLandmark.Sector.PlayersIds.count > 0
      ) {
        if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
        Gauge_Capture.Ratio = TargetPlayer.CapturedLandmark.Gauge.ValueReal;
        Gauge_Capture.Clan = TargetPlayer.CapturedLandmark.Gauge.Clan;
        Label_Capture.Value = ML::FloorInteger(TargetPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";


foreach(PlayerId in TargetPlayer.CapturedLandmark.Sector.PlayersIds) {  
        declare Player <=> Players[PlayerId]; 
/*
        if (TargetPlayer.CapturedLandmark.Sector.PlayersIds.count > 0 && Net_RocketPlayer && Player.CurrentClan == TargetPlayer.CapturedLandmark.Gauge.Clan)
{
c1.Opacity = 1.;
c2.Opacity = 0.2;
}
        if (TargetPlayer.CapturedLandmark.Sector.PlayersIds.count > 0 && Net_LaserPlayer && Player.CurrentClan == TargetPlayer.CapturedLandmark.Gauge.Clan)
{
c1.Opacity = 1.;
c2.Opacity = 1.;
} */
}
    
      } else if (Frame_Capture.Visible) {
        Frame_Capture.Visible = False;
      }
    }
  }
}
--></script>
</manialink>
""";
}

Text GetRegion(CUser _User) {
  if (_User == Null) {
    return "";
  }
  declare ZonePath = "";
  if (_User.ZonePath != "") {
    declare ExplodeZonePath = TextLib::Split("|", _User.ZonePath);
    if (ExplodeZonePath.existskey(1)) {
      ZonePath = ExplodeZonePath[1];
    }
  }
  if (ZonePath == "") {
    ZonePath = "Other";
  }
  return ZonePath;
}


// Create score table
Text ST42() {
  // Get scores to be displayed
  declare CSmScore[] ActualScores;
  
  foreach (Score in Scores) {
  
    if (Players.count > 0) {
    
      ActualScores.add(Score);
      
    }
  }
  
  // Crate scoretable manialink
  declare TableWidth = 190;
  declare RowHeight = 10;
  
  declare Column = 0;
  declare Row = 0;
  declare Rank = 1;
  
  declare Manialink = """
    <script><!--
      main() {
        while (True) {
          yield;
          
          foreach (Event in PendingEvents) {
            switch (Event.Type) {
              case CMlEvent::Type::MouseClick: {
                ShowProfile(Event.ControlId);
              }
            }
          }
        }
      }
    --></script>
    <frame posn="0 7">
      

      <label posn="80 30.5" textprefix="$o" text="{{{_("Ranking")}}}" translate="1  " scale="1.2" halign="center" valign="center" style="BgMainMenuTitleHeader"/>
      <quad posn="6.5 -22 - 5" sizen="{{{TableWidth*1.1}}} 115" style="Bgs1InRace" substyle="BgHealthBar" halign="center" valign="center"/>
      
      <label posn="{{{-TableWidth*0.45}}} 32.5" text="Points Limit: 100" scale="0.55" halign="left" valign="top"/>
      

      
      <label posn="{{{TableWidth*0.35 + 10}}} 24" text="Defense" scale="0.45" halign="center" valign="bottom"/>
      <label posn="{{{TableWidth*0.38 + 13}}} 24" text="Attack" scale="0.45" halign="center" valign="bottom"/>
      <label posn="{{{TableWidth*0.42 + 15}}} 24" text="Score" scale="0.45" halign="center" valign="bottom"/>       """;
      
  foreach (Score in ActualScores) {
    declare PlayerClan for Score.User = 0;
    declare Text BGColor1;
    declare Text Opacity;
    declare Text BGColor2;
    switch (PlayerClan) {
      case 1: {
        BGColor1 = "29f";
        BGColor2 = "226";
        Opacity = "1.";
      }
      case 2: {
        BGColor1 = "811";
        BGColor2 = "622";
        Opacity = "1.";
      }
      case 3: {
          BGColor1 = "000";
      BGColor2 = "000";
          Opacity = "0.";
      }
      default: {
        BGColor1 = "186";
        BGColor2 = "186";
        Opacity = "0.1";
      }
    }
    Column = 0;
    if (Rank > 0.5 * (ActualScores.count + 1.0)) {
      Column = 0;
    } 
    Row = Rank - 1 - Column*((ActualScores.count+1)/2);
    
    Manialink ^= """
      <frame posn="{{{(-1+Column)*TableWidth*0.45}}} {{{19-Row*RowHeight}}}">
      <quad posn="8 0 -5" sizen="{{{RowHeight*0.95 + 171}}} {{{RowHeight*0.95 + 3}}}" opacity="{{{Opacity}}}" colorize="{{{BGColor1}}}c" halign="left" valign="center" style="Bgs1InRace" substyle="BgTitle3_3"/>
        <quad posn="4 5" sizen="{{{RowHeight*0.95}}} {{{RowHeight*1.}}}" style="BgsChallengeMedals" substyle="BgPlayed" rot="90" colorize="{{{BGColor1}}}c" halign="left" valign="center"/>
        <label posn="{{{RowHeight*0.46}}} 0.5" text="{{{Rank}}}." scale="1.2" halign="center" valign="center"/>
        <!-- **************** Panel User **************** -->
        <quad posn="{{{RowHeight*0.9+0.1}}} 0" sizen="{{{TableWidth*0.4}}} {{{RowHeight*0.95}}}" colorize="{{{BGColor2}}}9" halign="left" valign="center" id="{{{Score.User.Login}}}" style="Bgs1InRace" substyle="BgTitleShadow"     scriptevents="1"/>
        
                <quad posn="{{{RowHeight*0.9+0.1}}} 0" sizen="{{{TableWidth*0.4}}} {{{RowHeight*0.95}}}" colorize="{{{BGColor2}}}9" halign="left" valign="center" id="{{{Score.User.Login}}}" style="Bgs1InRace" substyle="BgHealthBar"     scriptevents="1"/>
                      
        <!-- **************** Scores User **************** -->
        
        <quad posn="{{{RowHeight*0.9+102}}} 0" sizen="{{{TableWidth*0.4}}} {{{RowHeight*0.95}}}" bgcolor="{{{BGColor2}}}9" halign="left" valign="center" id="{{{Score.User.Login}}}" style="Bgs1InRace" substyle="BgTitleShadow"     scriptevents="1"/>
        
          <quad posn="{{{RowHeight*0.9+102}}} 0" sizen="{{{TableWidth*0.4}}} {{{RowHeight*0.95}}}" bgcolor="{{{BGColor2}}}9" halign="left" valign="center" id="{{{Score.User.Login}}}" style="Bgs1InRace" substyle="BgHealthBar" colorize="{{{BGColor2}}}9"     scriptevents="1"/>
        <quad posn="180 4" sizen="{{{RowHeight * 0.8}}} {{{RowHeight}}}" style="BgsChallengeMedals" substyle="BgPlayed" rot="90" bgcolor="{{{BGColor1}}}c" halign="left" valign="center"/>
        <quad posn="170 4" sizen="{{{RowHeight * 0.8}}} {{{RowHeight}}}" style="BgsChallengeMedals" substyle="BgPlayed" rot="90" bgcolor="{{{BGColor1}}}c" halign="left" valign="center"/>
        <quad posn="160 4" sizen="{{{RowHeight * 0.8}}} {{{RowHeight}}}" style="BgsChallengeMedals" substyle="BgPlayed" rot="90" bgcolor="{{{BGColor1}}}c" halign="left" valign="center"/>
        
        

        <label posn="{{{RowHeight*0.9+2}}} {{{RowHeight*0.2}}}" sizen="{{{TableWidth*0.3}}} {{{RowHeight*0.8}}}" text="{{{Score.User.Name}}}" halign="left" valign="center"/>
        <label posn="{{{RowHeight*0.9+2}}} {{{-RowHeight*0.4}}}" sizen="{{{TableWidth*0.3}}} {{{RowHeight*0.2}}}" text="Rank: {{{Score.User.LadderRank}}} ({{{GetRegion(Score.User)}}})" scale="0.45" halign="left" valign="bottom"/>
        
        """;
    declare DefendHits for Score = 0;
    Manialink ^= """
      <label posn="{{{TableWidth*0.35  + 96}}} 0.5" textprefix="$5bf" text="{{{DefendHits}}}" scale="0.9" halign="center" valign="center"/>""";
    declare WonAttackRounds for Score = 0;
    Manialink ^= """
      <label posn="{{{TableWidth*0.38  + 99}}} 0.5" textprefix="$fb5" text="{{{WonAttackRounds}}}" scale="0.9" halign="center" valign="center"/>""";
    Manialink ^= """
      <label posn="{{{TableWidth*0.42 + 101}}} 0.5" text="{{{Score.Points}}}" scale="1.2" halign="center" valign="center"/>
      </frame>""";

    Rank += 1;
    if (Rank > 16) {
      break;
    }
  }
  
  
  
  Manialink ^= """
    </frame>""";
  
  return Manialink;
}

Void GivePoints (Text _AoD) 
{
if (_AoD == "Atk") {
foreach (Player in Players) {
if (Player.Id == G_RocketPlayerId || Player.Id == G_LaserPlayerId) {
declare netwrite AtkPoints for Player = 0;
AtkPoints += 1;
ST2::SetColValue("AtkPoints", Player.Score, TextLib::ToText(AtkPoints));
     }
  }
}
}

declare Integer IntegerConverted;
Integer BooleanToInteger (Boolean _Convert)
{
if (!_Convert) IntegerConverted = 0;
else if (_Convert) IntegerConverted = 1;
return IntegerConverted;
}

Void EndMatch()
{
MatchEndRequested = True; MB_StopMap = True;
}


declare Integer NbCaptured;
declare Boolean  StopThisMachineA;
declare Boolean  StopThisMachineB;
declare Boolean  StopThisMachineC;

Integer GoalsCaptured() {
NbCaptured = 0;
foreach (Goal in Goals)
{
if (Goal.Tag == "Goal A")
{
if (Goal.Gauge.Captured) NbCaptured += 1;
}
if (Goal.Tag == "Goal B")
{
if (Goal.Gauge.Captured) NbCaptured += 1;
}
if (Goal.Tag == "Goal C")
{
if (Goal.Gauge.Captured) NbCaptured += 1;
}
}

return NbCaptured;
}

Integer GoalMode()
{
declare ThisOneCanBeCap = Now + 50000;
declare GaolMode = 0;
if (GoalsCaptured() == Goals.count - 1)
{ foreach(Goal in Goals) {  ThisOneCanBeCap = Now + 5000; GaolMode = 0; Goal.Gauge.Max = (S_Capture * 1000); } }
if (GoalsCaptured() + 1 < Goals.count)
{ foreach(Goal in Goals) { GaolMode = 1; Goal.Gauge.Max = 100; } }
log(GaolMode);
return GaolMode;
}

// ---------------------------------- //
/**
 *  Convert Integers from 1 to 9 into letters from A to I
 *
 *  @param  _N    The Integer to convert
 *
 *  @return     The letter
 */
Text GetLetterFromNumber(Integer _N) {
  switch(_N) {
    case 1 : return "A";
    case 2 : return "B";
    case 3 : return "C";
  }
  return "A";
}


// ---------------------------------- //
/** Get the checkpoint ManiaLink
 *
 *  @param    _GatesNb  Number of gates at this checkpoint
 *
 *  @return   The ManiaLink text
 */
Text GetMLCheckpoint(Integer _GatesNb) {
  declare GatesML = "";
  
  declare SpaceX = 10.;
  declare Width = (_GatesNb-1) * SpaceX;
  for (I, 0, _GatesNb-1) {
    declare PosnX = (-Width/2.) + (I * SpaceX);
    declare Letter = GetLetterFromNumber(I+1);
    GatesML ^= """
<quad posn="{{{PosnX}}} -10 0" sizen="8 8" halign="center" valign="center" style="BgRaceScore2" substyle="CupFinisher" class="Gate" />
<label posn="{{{PosnX}}} -10 0.3" sizen="6 6" halign="center" valign="center" textsize="2" text="$s{{{Letter}}}" />""";
  }
  
  return """
<manialink version="1" name="Siege:Checkpoint">
<frame posn="0.5 72.5 40">
  <frame class="LibCustomUI_Module" id="Checkpoint">
    {{{GatesML}}}
  </frame>
</frame>
<script><!--
main() {
  {{{CustomUI::InjectMLInit()}}}
  
  declare CMlQuad[] Quads_Gate;
  Page.GetClassChildren("Gate", Page.MainFrame, True);
  foreach (Control in Page.GetClassChildren_Result) {
    Quads_Gate.add((Control as CMlQuad));
  }
  
  declare netread Integer Net_GatesCapturedUpdate for Teams[0];
  declare netread Integer[] Net_GatesCaptured for Teams[0];
  declare netread Integer GoalsCount for Teams[0];
  
  declare PrevGatesCapturedUpdate = -1;
  
  while (True) {
    yield;
    if (InputPlayer == Null || !PageIsVisible) continue;
    
    {{{CustomUI::InjectMLLoop()}}}
    
    
    
    if (PrevGatesCapturedUpdate != Net_GatesCapturedUpdate) {
      PrevGatesCapturedUpdate = Net_GatesCapturedUpdate;
      
      declare Count = 1;
      foreach (Quad_Gate in Quads_Gate) {
        if (Net_GatesCaptured.exists(Count)) {
          Quad_Gate.Substyle = "CupFinisher";
        } else {
          Quad_Gate.Substyle = "CupFinisher";
        }
        Count += 1;
      }
    }
  }
}
--></script>
</manialink>""";
}

Void Init(CSmPlayer Player)
{
Player.StaminaMax = 1.;
Player.StaminaGain = 1.;
}

declare Integer ShieldTime;
Void ShieldManagement(CSmPlayer Player)
{
declare Blink_Start for Player = Now;
declare Blink for Player = False;
declare Blink_Duration for Player = 0;
declare ShieldTime for Player = 0;

  if (Now >= Blink_Start + Blink_Duration) {
    Blink_Start = Now;
    Blink = !Blink;
    
    if (Blink) Blink_Duration = 100;
    else Blink_Duration = C_Blink - 100;
  }

if (Now + 2000 > ShieldTime) { Player.HasShield = Blink; Player.IsHighlighted = Blink; }

if (Now > ShieldTime)
  {
Layers::Detach("Bouclier", Player);
Player.HasShield = True;
Player.IsHighlighted = True;
  G_Shield = NullId;
  G_ShieldPlayer = Null;
  }

}

// ---------------------------------- //
/// Initialize the color of the spawns, poles and other colored elements
Void InitBasesColor() {
	foreach (Base in MapBases) {
		Base.Clan = G_DefClan;
		Base.IsActive = True;
	}
	
	// Get def and atk spawn
	declare DefSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnDefense", 0);
	declare AtkSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnAttack", 0);
	
	// Color the bases
	if (DefSpawn.Base != AtkSpawn.Base && DefSpawn.Base != Null && AtkSpawn.Base != Null) {
		AtkSpawn.Base.Clan = G_AtkClan;
		AtkSpawn.Base.IsActive = True;
	}
}

// Get hitrate of a player
Integer GetHitrate(CSmPlayer Player) {
	if (Player == Null) return -1;
	declare Shoots for Player = 0;
	declare Hits for Player = 0;
	if (Shoots > 0) {
		declare Hitrate = ((Hits * 1.) / (Shoots * 1.)) * 10;
		if (Hitrate > 0.) {
			return MathLib::NearestInteger(Hitrate * 10);
		}
	}

	return -1;
}

// Update hitrate on the scorestable
Void UpdateHitrate(CSmPlayer _Player, Boolean _Highlight) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Hitrate = GetHitrate(_Player);
	declare netwrite Integer Net_Hitrate for _Player;
	declare netwrite Boolean Net_HitrateHighlight for _Player;
	Net_Hitrate = Hitrate;
	Net_HitrateHighlight = _Highlight;
	if (Hitrate > 0) {
	if (Hitrate > 0 && Hitrate < 40)
	ST2::SetColValue(C_ST_ColId_Accuracy, _Player.Score, "$f00"^TextLib::ToText(Hitrate)^"$f20%");
	if (Hitrate > 40 && Hitrate < 75)
	ST2::SetColValue(C_ST_ColId_Accuracy, _Player.Score, "$fff"^TextLib::ToText(Hitrate)^"$999%");
	if (Hitrate > 75 && Hitrate < 101)
	ST2::SetColValue(C_ST_ColId_Accuracy, _Player.Score, "$0f0"^TextLib::ToText(Hitrate)^"$0f0%");
	}
}
Void UpdateHitrate(CSmPlayer _Player) {
	UpdateHitrate(_Player, False);
}


Text Ready_Layer()
{
	declare Text ImgBaseDir			= "file://Media/Manialinks/Shootmania/Common/";
	declare Text WelcomeBgImage		= ImgBaseDir^"topsBg.dds";
	declare Text WelcomeBgImageTop		= ImgBaseDir^"SpawnScreen.dds";
	declare Text ArmorImage			= ImgBaseDir^"ShieldWhite.dds";
	declare Text WpLaserImage		= ImgBaseDir^"WpLaser.dds";
	declare Text WpRocketImage		= ImgBaseDir^"WpRocket.dds";
	declare Text WpNucleusImage		= ImgBaseDir^"WpNucleus.dds";
	declare Text HighlightColor		= "f90";
	declare Text CAlign				= """ valign="center" halign="center" """;

return """
<dico>
<language id="en">
<Name>$s$fffChampions $f00$o| $z$sTournament mode actived.</Name>
<Intro>To start, each team need {{{S_NbPlayersPerTeam}}} players.</Intro>
<After>You can desactivate the Tournament mode to pratice!{{{"\n"}}}But, In tournament mode, you'll got a different gameplay</After>
</language>
<language id="fr">
<Name>$s$fffChampions $f00$o| $z$sMode Tournoi activ√©.</Name>
<Intro>Vous devez √™tre {{{S_NbPlayersPerTeam}}} joueurs par √©quipe pour jouer.</Intro>
<After>Vous pouvez d√©sactiver le mode Tournoi pour vous entrainer!{{{"\n"}}}Mais attention, en mode Tournoi, vous aurez un gameplay diff√©rent</After>
</language>
<language id="it">
<Name>$s$fffCampioni $f00$o| $z$sModalit√† torneo attivata.</Name>
<Intro>Per iniziare, a ogni squadra serve {{{S_NbPlayersPerTeam}}} giocatori.</Intro>
<After>E' possibile disattivare la modalit√† torneo in pratica!{{{"n"}}}Ma, in modalit√† torneo, avevate un gameplay diverso</After> 
</language>
</dico>

<frame posn="0 -5">
<quad posn="0 40 -1" halign="center" valign="center" sizen="180 52.5" image="{{{WelcomeBgImage}}}" />
<quad posn="0 50 0" halign="center" valign="center" sizen="100 20" />
<label posn="0 45 1" halign="center" scale="1.1" valign="center" textid="Name" />
<label posn="0 40" halign="center" scale="0.8" valign="center" textid="Intro" />
<label posn="0 35" halign="center" scale="0.75" valign="center" textid="After" />
<frame scale="0.7">
<label posn="-80 40" scale="1." halign="center" id="ReadyNb1" />
<quad posn="-60 42" sizen="10 10" halign="center" style="Icons64x64_1" substyle="Green" />
</frame>
<frame scale="0.7">
<label posn="80 40" scale="1." halign="center" id="ReadyNb2" />
<quad posn="60 42" sizen="10 10" halign="center" style="Icons64x64_1" substyle="Green" />
</frame>

</frame>

<script><!--
main() {
declare Label_ReadyNb1 <=> (Page.GetFirstChild("ReadyNb1") as CMlLabel);
declare Label_ReadyNb2 <=> (Page.GetFirstChild("ReadyNb2") as CMlLabel);
declare netread Integer Ready_Nb1 for Teams[0];
declare netread Integer Ready_Nb2 for Teams[0];

declare ReadyNb1 = 0;
declare ReadyNb2 = 0;
while(True) {
yield;
sleep(100);
ReadyNb1 = Ready_Nb1;
Label_ReadyNb1.SetText("$s$i$29f"^ReadyNb1^" Blues Ready");
ReadyNb2 = Ready_Nb2;
Label_ReadyNb2.SetText("$s$i$f30"^ReadyNb2^" Reds Ready");
}
}
--></script>

""";
}


Void main_function(Text _T)
 { 
  if (_T == "Server") {
  Layers::Create("ST");
  Layers::Create("M1");
  Layers::Create("M2");
  Layers::SetType("ST", C_Interface["ST"]);
   Layers::SetType("M1", C_Interface["Markers"]);
   Layers::SetType("M2", C_Interface["Markers"]);

  }
  else if (_T == "Game") {
  Layers::Attach("ST");
  Layers::Attach("TopBar2");
  //Layers::Attach("TopBar");
foreach (Player in Players) {
declare UI <=> UIManager.GetUI(Player);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}
foreach (Spectator in Spectators) {
declare UI <=> UIManager.GetUI(Spectator);
declare netwrite Text MapNameT for UI = Map.MapName;
declare netwrite Text MapAuthorT for UI = Map.AuthorLogin;
MapNameT = Map.MapName;
MapAuthorT = Map.AuthorLogin;
}
//Markers::Add("""<marker manialinkframeid="test" playerlogin="*player1*" />""", Markers_Frame()); 
 //Layers::Update("ST", GetScoresTable());
  }
}

Integer RetrieveCoins(CSmPlayer _Player)
{
declare persistent Coins for _Player.User = 0;
return Coins;
}

Void ML_Play(Text Input, Boolean Score_)
{

declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
  declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
//declare P_Adv = [1 => 0, 2 => 0];

declare MLText = """""";

declare _Scores = "";
if (Score_) {
_Scores = """${{{Team1Color}}}$s$v$i{{{ClanScores[1]}}} $fff- ${{{Team2Color}}}{{{ClanScores[2]}}}""";
} else _Scores = "";
if (Input != "") {
   MLText = """


<frame id="principal">
<frame id="movement" posn="400" >
<label posn="0 0" scale="0.95" halign="center" valign="center" style="TextButtonBig" textsize="4" text="$s$i{{{Input}}}" />
<label posn="50 0" scale="1.1" halign="center" valign="center" style="TextButtonBig" textsize="4" text="{{{_Scores}}}" />
<quad posn="0 0 -1" scale="0.95" halign="center" valign="center" sizen="80 30" style="UiSMSpectatorScoreBig" substyle="UIRange2Bg" />

</frame>
<quad posn="0 -1.5 -2" opacity="0." id="need" scale="0.95" halign="center" valign="center" sizen="800 13" style="Bgs1" substyle="BgDialogBlur" />
<quad posn="-130 0 -1" id="need1" opacity="0." scale="0.95" sizen="100 400" halign="center" valign="center" style="Bgs1InRace" substyle="BgGradLeft" />
</frame>

<script><!--

{{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
{{{Manialink::DumpLib()}}}

main() {
declare Frame_Global <=> (Page.GetFirstChild("movement")			as CMlFrame);
declare Quad_Opacity <=> (Page.GetFirstChild("need")			as CMlQuad);
declare netread Integer Anim for Teams[0];
declare Anim2 = 0;
while(True) {
yield;

while (Anim > ArenaNow) {
yield;
LibManialink_AnimLoop();
LibManialink_Anim({{{Manialink::Inject("""<quad id="need" opacity="1." />""")}}}, {{{Anim_}}}, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<quad id="need1" opacity="1." />""")}}}, {{{Anim_}}}, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<frame id="movement" posn="-100" />""")}}}, {{{Anim_}}}, "EaseOutElastic");
Anim2 = Now + 5000;
}

while(Anim2 > Now && Anim < Now)
{
yield;
LibManialink_AnimLoop();
LibManialink_Anim({{{Manialink::Inject("""<quad id="need1" posn="-500" scale="0." opacity="0." />""")}}}, {{{Anim_}}}, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<quad id="need" posn="-1500" opacity="0." />""")}}}, {{{Anim_}}}, "EaseOutElastic");
LibManialink_Anim({{{Manialink::Inject("""<frame id="movement" posn="-500" />""")}}}, {{{Anim_}}}, "EaseOutElastic");
}

}
}
--></script>
 """;
  Layers::Update("ML_Play", MLText);
   }


Layers::Attach("ML_Play");

}

Void CoinsLoop()
{
foreach (Player in Players) {
declare persistent Coins for Player.User = 0;
declare netwrite GsCoins for Player.Score = Coins;
GsCoins = Coins;
}
}

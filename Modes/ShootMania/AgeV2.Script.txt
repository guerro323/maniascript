

/*
 *	Mode melee
 */

#Extends "Modes/ShootMania/Base/ModeShootmania.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/MiniMap2.Script.txt" as MiniMap
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Stormium/SpawnScreen.Script.txt" as StormiumSS
#Include "Libs/Stormium/Interface.Script.txt" as StormiumIT
#Include "Libs/Stormium/InterfaceClassSelector.Script.txt" as StormiumITCS
#Include "Libs/Nadeo/ScoresTable2.Script.txt" as ST2
#Include "Libs/Stormium/Kits.Script.txt" as Kits

#Const	CompatibleMapTypes	"TeamDeathmatchArena, AgeArena"
#Const	Version				"2014-07-25"
#Const	ScriptName			"Melee.Script.txt"

#Const m_MiniMapSize <60., 60.>
#Const m_MiniMapPos <92., 0., 0.>

#Const EGameState_Starting 	0
#Const EGameState_InPlay 	1

#Setting S_CoeffTimeLimitCaptureCheckpointAutoTeamBalanceVote 1.2 as _("Time to capture a CP * this coeff (same coeff to rush check)")
#Setting S_TimeToVoteBalance 60000
#Setting S_RatioToValideVoteBalance 0.55 as _("/!\\ 1Yes, 1No, 1other => 2/1No = Vote valide")
#Setting S_TimeToCaptureCheckpoint 60 as _("Time to capture a checkpoint (s)")
#Setting S_MultiPlayerFasterCap True as _("Allow faster capture")
#Setting S_EndTime				5	as _("Time to finish a round (minute)")
#Setting S_RushTime				60	as _("Time to rush the goal (s)")
#Setting S_GainTimePerNewRange 	30 as _("Gain time per new range")
#Setting S_GainTimeOnCapture			20 as _("Gain time per capture")
#Setting S_RushTimeGateDuration	15000 as _("Waiting time to wait for gates to open")
#Setting S_TimeSelectionTime			15 as _("Time to wait before match start")
#Setting S_RequiredPlayers				2
#Setting S_MaxRounds 3
#Setting S_BotBlue	0
#Setting S_BotRed		0
#Setting S_AutoManageAFK False
#Setting S_AFKIdleTimeLimit 60000 as _("In millisecond")
#Setting S_AFKSpawnSelectTimeLimit 120000 as _("In millisecond")

/// <summary>
/// Current Attacking clan.
/// </summary>
/// <remarks>The color are still Blue for atk, and Red for def</remarks>
declare Integer AttackingClan;
/// <summary>
/// Spawns for all players.
/// usage: *[Team][Order]
/// </summary>
declare CSmMapLandmark[][Integer][Text] PlayerSpawns;
declare CSmMapLandmark[Integer] Goals;
declare CSmMapLandmark[][Integer] Gates;
declare CSmMapLandmark[][Integer] Checkpoints;
declare CSmObject[] MapCannons;
declare Integer CurrentGameState;
declare Integer CurrentOrder;
declare Boolean[Integer] RangeCaptured;
declare Boolean get_IsFinalGoal;
declare CSmMapLandmark lastGate;
declare Integer RoundWinner;
declare Integer LastRoundWinner;
declare Integer MapWinner;
declare Boolean IsOvertime;
declare Boolean IsRangedMap;
declare Integer MatchStartTime;
declare Integer OvertimeEndTime;
declare Integer[Integer] RangedProgression;
declare Integer LastTimeBalance;

//< Balancing stuff by ProInfo (provalinf github)
declare Boolean BalancingIsRequired;
declare Integer BalanceType;	// 1:Ranks, 2:Scores
declare Integer TimeStartVote;
declare Text PlayerNameRequestVoting;
declare Text[][] VoteBalanceResult;
declare Boolean AutoServerStartVoteBalance;
declare Real MapMinTime;
declare Integer StartPrevMapTime;

declare CSmPlayer[] spectatorList;
declare Boolean antiBugMapStartRequestedClan;
//>

***Match_StartServer***
***
	AFK::SetIdleTimeLimit(S_AFKIdleTimeLimit);
	AutoServerStartVoteBalance = False;
	BalanceType = 2;	// Type de vote par dÃ©faut si aucun vote entre temps pour l'AutoServerStartVoteBalance

	AttackingClan = MathLib::Rand(1, 2);
	
	Layers::Create("CGame.SpawnInterface", layer_GetSpawnInterface());
	Layers::Create("CGame.GateMarkers", layer_GetGateMarkers());
	Layers::Create("CGame.GoalMarkers", layer_GetGoalMarkers());
	Layers::Create("CGame.Overtime", layer_GetOvertime());
	Layers::Create("CGame.Balance", layer_GetBalance());
	
	Layers::SetType("CGame.GateMarkers", CUILayer::EUILayerType::Markers);
	Layers::SetType("CGame.GoalMarkers", CUILayer::EUILayerType::Markers);
	
	ST2::Load();
	ST2::SetStyle("LibST_SMBaseTeams");
	ST2::SetStyle("LibST_SMBasePoints");
	ST2::Build("SM");
	
	UseMinimap = True;
	ForceNavMapsComputation = True;
	UseClans = True;
	
	declare netwrite NetSrv_Handle for Teams[0] = ["" => -1];
	declare netwrite NetSrv_Message for Teams[0] = ["" => ""];
	
	UIManager.UIAll.NoticesFilter_HideMapInfo = True;
	UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
	
	StormiumSS::SetName("AGE");
	StormiumSS::SetGoal("""Attackers must capture the 2 Checkpoints (STORMIUM Containers) UNDER 5 MINUTES.
If they don't succeed, Defenders win 1 point.
If they succeed they will have to rush to the goal UNDER 60 SECONDS to get a point.
The team who won a defense and an attack round in a streak win the map!""");
	StormiumSS::SetDescription("""â–º In attack or defense, you can choose among 9 kits ! 
You have a main weapon + other weapons/actions.""");
	StormiumSS::SetScoreManialink(GetScoreManialink());
	StormiumIT::Load(StormiumIT::C_ModeAgE);
	StormiumIT::ShowCustomCoutdown(True);
	StormiumIT::ShowCustomScores(True);
	StormiumIT::ShowCustomMarkers(True);
	StormiumIT::SetActive(True);
	
	StormiumITCS::Load();
	
	UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	
	RefreshVoteBalance();
***

***MB_Private_Settings***
***
	MB_Settings_UseDefaultTimer = False;
	MB_Settings_UseDefaultClansScoresUI = False;
	MB_Settings_UseDefaultSpawnScreen = False;
	MB_Settings_UseDefaultPodiumSequence = False;
	MB_Settings_UseDefaultHud = False;
***

***Match_StartMap***
***
	Message::CleanAllMessages();
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";

	ST2::ClearScores();
	ClearScores();
	
	RangedProgression[1] = 0;
	RangedProgression[2] = 0;
	
	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;
	
	LastRoundWinner = 0;

	PlayerSpawns = CSmMapLandmark[][Integer][Text];
	Goals = CSmMapLandmark[Integer];
	Gates = CSmMapLandmark[][Integer];
	Checkpoints = CSmMapLandmark[][Integer];

	UIManager.UIAll.MarkersXML = "";
	foreach (mlm in MapLandmarks)
	{
		if (mlm.PlayerSpawn != Null)
			AddLandmark(mlm.PlayerSpawn, mlm);
		if (mlm.Gauge != Null)
			AddLandmark(mlm.Gauge, mlm);
	}
	
	IsRangedMap = Checkpoints.count > 1;
		
	lastGate = CSmMapLandmark;
	declare lastOrder = 0;
	foreach (gate in MapLandmarks_Gauge)
	{
		if (gate.Tag == "Gate" && gate.Order > lastOrder)
		{
			lastOrder = gate.Order;
			lastGate <=> gate;
		}
	}

	
	CurrentGameState = EGameState_Starting;
	
	UpdateColors();
	
	Layers::Update("CGame.SpawnInterface", layer_GetSpawnInterface());
	
	BalanceStart();
	
	StartTime = Now;
	
	// quick dirty fix
	antiBugMapStartRequestedClan = True;
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	BalanceTeams(1);
	
	Message::SetDefaultStatusMessage("");
	
	CurrentGameState = EGameState_InPlay;
	
	UpdateColors();
	StormiumSS::Reload();
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	
	RefreshCheckpointsInterfaceVariables();
	
	UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	
	if (IsRangedMap)
	{
		UIManager.UIAll.BigMessage = "Multiple gates ranges warning!";
		UIManager.UIAll.StatusMessage = "The first team who win the attack wins the map!";
		
		MB_Sleep(2500);
	}
	
	log("hi");
***

***Match_StartRound***
***
	UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never ;
	UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never ;

	OvertimeEndTime = -1;

	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;

	declare netwrite Net_IsFinalGoal for Teams[0] = False;
	Net_IsFinalGoal = False;
	
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	Message::SetDefaultStatusMessage("");
	
	RangeCaptured = Boolean[Integer];

	CurrentOrder = 0;
	declare i = 0;
	foreach (n in Checkpoints)
	{
		i += 1;
		RangeCaptured[i - 1] = False;
		
		foreach (cp in n)
			cp.Gauge.Speed = -1;
	}
	
	AttackingClan = 3 - AttackingClan;
	declare netwrite Net_AttackingClan for Teams[0] = AttackingClan;
	Net_AttackingClan = AttackingClan;
	
	foreach (player in Players)
	{
		SendSrvMessage(player.Login, "GoRespawnScreen");
		SendSrvMessage(player.Login, "SetPlayerClan");
	}
	
	CurrentGameState = EGameState_Starting;
	UpdateColors();
	
	if (IsRangedMap)
		CurrentOrder = RangedProgression[AttackingClan];
	
	CurrentGameState = EGameState_InPlay;
	UpdateColors();
	UpdateGates();
	
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	RefreshCheckpointsInterfaceVariables();
	
	RoundWinner = 0;
	MapWinner = 0;
	
	EndTime = -1;
	
	IsOvertime = False;
	
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	
	while(Players.count < S_RequiredPlayers)
	{
		yield;
		UIManager.UIAll.StatusMessage = "Required Players: " ^ S_RequiredPlayers ^ " | Current Players count: " ^ Players.count;
		UIManager.UIAll.BigMessage = "Waiting for players...";
	}
	
	Net_MatchIsRunning = True;
	
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	
	EndTime = Now + (S_EndTime * 60000) + (S_TimeSelectionTime * 1000);
	MatchStartTime = Now + (S_TimeSelectionTime * 1000);
	
	foreach (player in Players)
		SendSrvMessage(player.Login, "GoRespawnScreen");

	if (MB_Private_SectionCount_Round < S_MaxRounds)
		Message::SendBigMessage("New round.", 3000, 10);
	else
		Message::SendBigMessage("Last round!", 6000, 10);
		
	if (IsRangedMap)
	{		
		if (CurrentOrder >= Checkpoints.count)
		{
			declare netwrite Net_IsFinalGoal for Teams[0] = True;
			Net_IsFinalGoal = True;
			
			Message::SetDefaultStatusMessage("Rush time!");
			EndTime = (Now + (S_RushTime * 1000)) + S_RushTimeGateDuration;
			UIManager.UIAll.CountdownEndTime = Now + S_RushTimeGateDuration;
			
			Message::SendStatusMessage(Teams[AttackingClan - 1].ColorizedName ^ " will start at rush time!", 4000, 10);
		}
		else
			Message::SendStatusMessage(Teams[AttackingClan - 1].ColorizedName ^ " will start at range #" ^ CurrentOrder, 4000, 10);
	}
***

***OnNewPlayer***
***
	// Debug -- Start
	/*log("Connexion de "^Player.User.Id);*/
	//log("Nouveau joueur "^Player.User.Login^", redirigÃ© vers l'Ã©quipe nÂ°"^dispatchNewOrSpectPlayerClan(Player));
	// Debug -- End
	SetPlayerClan(Player, dispatchNewOrSpectPlayerClan(Player));
***

***Match_Yield***
***
	Users_SetNbFakeUsers(S_BotBlue, S_BotRed);

	Message::Loop();
	StormiumSS::Loop();
	StormiumIT::Loop();
	StormiumITCS::Loop();
	
	Layers::Attach("CGame.GateMarkers");
	Layers::Attach("CGame.GoalMarkers");
	Layers::Attach("CGame.Overtime");
	Layers::Attach("CGame.SpawnInterface");
	Layers::Attach("CGame.Balance");
***

***Match_PlayLoop***
***	
	declare netwrite Net_MatchStartTime for Teams[0] = 0;
	Net_MatchStartTime = MatchStartTime;
	
	RefreshVoteBalance();

	foreach (e in PendingEvents)
	{
		if (e.Type == CSmModeEvent::EType::OnPlayerRequestRespawn)
			PassOn(e);
		if (e.Type == CSmModeEvent::EType::OnCapture)
		{
			PassOn(e);
		}
		if (e.Type == CSmModeEvent::EType::OnHit)
		{
			if (e.Victim != Null && e.Victim != e.Shooter)
				PassOn(e);
		}
		if (e.Type == CSmModeEvent::EType::OnActionEvent)
		{
			+++OnActionEvent+++
			Kits::OnActionEvent(e);
		}
		if (e.Type == CSmModeEvent::EType::OnActionCustomEvent) 
		{
			+++OnActionCustomEvent+++
		}
	}
	
	foreach (player in AllPlayers) {
		if (!player.User.IsFakeUser && !player.IsBot)
			if (player != Null) {
				declare flag1 = Players.exists(player);
				declare flag2 = Spectators.exists(player);
				
				declare isSpectator for player = False;
				if (flag1 && isSpectator) {
					isSpectator = False;
					// Passage de spectateur Ã  joueur
					//spectatorList.remove(player);
					declare Integer PlayerClan for player;
					PlayerClan = dispatchNewOrSpectPlayerClan(player);
					declare TempoPlayerRequestedClan for player = 0;
					TempoPlayerRequestedClan = Now;
					UnspawnPlayer(player);
					SetPlayerClan(player, PlayerClan);	// Important Ã©galement si le round n'est pas actif
					log("Joueur "^player.User.Login^", redirigÃ© vers l'Ã©quipe nÂ°"^PlayerClan);
				} else if (!flag1 && !isSpectator) {
					isSpectator = True;
				}
		}
	}
	
	// quick dirty fix
	declare antiBugRequestedClan = True;

	foreach (player in Players)
	{
		player.Stamina += 1;
		if (Kits::GetPlayerKit(player) == "soldier")
			player.Stamina += 2;
		
		declare Integer AFKatSelectSpawn for player = Now;

		if (player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
		{	
			if (StartTime > AFKatSelectSpawn) AFKatSelectSpawn = -1;
			if (AFKatSelectSpawn == -1) {
				AFKatSelectSpawn = Now;
			} else if (AFKatSelectSpawn + S_AFKSpawnSelectTimeLimit < Now
			&& !player.User.IsFakeUser) {
				Users_RequestSwitchToSpectator(player.User);
				AFKatSelectSpawn = -1;
			}
		
			declare PlayerClan for player = player.RequestedClan;
			declare TempoPlayerRequestedClan for player = 0;
			
			// quick dirty fix
			
			declare Integer prevPlayerClan for player.User;
			if (!antiBugMapStartRequestedClan && TempoPlayerRequestedClan + S_AFKSpawnSelectTimeLimit < Now)
 				PlayerClan = player.RequestedClan;
			else if (prevPlayerClan != 0 && prevPlayerClan != player.RequestedClan && !player.User.IsFakeUser && !player.IsBot)
			{
				antiBugRequestedClan = False;
				PlayerClan = prevPlayerClan;
				log("Res current clan ("^PlayerClan^") for "^player.User.Id);
			}
 			
				
			SetPlayerClan(player, PlayerClan);
			
			PlayerClan = player.CurrentClan;
			
			declare UI <=> UIManager.GetUI(player);
			declare netread Net_playerWantRespawn for UI = False;
			declare netread Net_playerSyncTime for UI = 0;
			declare netread Net_playerLastTime for UI = 0;
			declare netread Net_playerSpawn for UI = 0;
			declare netread Net_playerSpawnOrder for UI = 0;
			declare netread Net_playerWantedKit for UI = "soldier";
			
			declare lastTime for player = 0;
			declare netwrite Net_playerMayChooseThisKit for player = "";
			Net_playerMayChooseThisKit = Net_playerWantedKit;
			
			if ((Net_playerWantRespawn
			|| player.User.IsFakeUser)
			&& MatchStartTime < Now)
			{			
				declare CSmMapLandmark spawn;
				if (MapLandmarks_PlayerSpawn.existskey(Net_playerSpawn))
					spawn <=> MapLandmarks_PlayerSpawn[Net_playerSpawn];
			
				if (get_IsFinalGoal && player.CurrentClan == 3 - AttackingClan)
				{
					spawn <=> PlayerSpawns["SpawnGoal"][0][0];
				}
			
				if (spawn != Null && (IsValidSpawn(spawn, player) || player.User.IsFakeUser))
				{
					player.ArmorMax = 10000;
					player.Armor = 100;
					
					SendSrvMessage(player.Login, "GoRespawnScreen");
					
					if (!player.User.IsFakeUser)
						Kits::SetKit(player, Net_playerWantedKit);
					else
						Kits::SetKit(player, "soldier");
					
					declare respawnTime for player = Now;
					SM::SpawnPlayer(player, player.CurrentClan, player.Armor, spawn.PlayerSpawn, Now);
				}
			}
		} 
		else
		{
			AFKatSelectSpawn = -1;
			if (get_IsFinalGoal)
			{
				if (player.CurrentClan == AttackingClan)
					player.Armor += 2;
				else
					player.Armor += 6;
			}
		}
	}
	
	// quick dirty fix
	if (antiBugRequestedClan) antiBugMapStartRequestedClan = False;
	
	declare nbOfCheckpointsCaptured = 0;
	foreach (clanOrder => order in Checkpoints)
	{
		// Choose the right checkpoint
		if (clanOrder == CurrentOrder)
			foreach (checkpoint in order)
			{
				if (checkpoint.Gauge.Captured 
					|| checkpoint.Gauge.Value == checkpoint.Gauge.Max)
				{
					if (!checkpoint.Gauge.Captured)
						checkpoint.Gauge.Captured = True;
				
					nbOfCheckpointsCaptured += 1;
				}
			
				declare CSmPlayer[] players;
				if (checkpoint.Sector != Null)
					if (checkpoint.Sector.PlayersIds.count > 0)
					{
						foreach (id in checkpoint.Sector.PlayersIds)
						{
							if (Players.existskey(id))
							players.add(Players[id]);
						}
					}
					else
						checkpoint.Gauge.Speed = 0;
						
			
				checkpoint.Gauge.Speed = SpeedValue(checkpoint.Gauge, players);
				if (checkpoint.Gauge.Speed > 0)
				{
					if (IsOvertime)
					{
						UIManager.UIAll.CountdownEndTime = Now + 60000;
						OvertimeEndTime = Now + 5000;
					}
				}
				
				declare lastUIUpdateTime for This = 0;
				if (lastUIUpdateTime + 250 < Now)
				{
					lastUIUpdateTime = Now;
					RefreshCheckpointsInterfaceVariables();
				}
			}
	}
	foreach (I => goal in Goals)
	{
		if (UIManager.UIAll.CountdownEndTime == -1 && get_IsFinalGoal)
		{
			if ((goal.Gauge.Value == 0)
				&& goal.Gauge.Speed == -1)
			{
				goal.Gauge.Speed = 1;
				MB_Yield();
			
				goal.Gauge.Clan = AttackingClan;
				goal.Base.Clan = AttackingClan;
			}
			
			if (goal.Gauge.Value == goal.Gauge.Max
				&& goal.Gauge.Speed == 1)
			{
				if (!goal.Gauge.Captured)
					goal.Gauge.Captured = True;
			}
		
			declare atkClanPresent = False;
			declare defClanPresent = False;
			declare lastDefClanStayTime for This = -1;
			foreach (playerId in goal.Sector.PlayersIds)
			{
				if (Players.existskey(playerId))
				{
					declare player <=> Players[playerId];
					if (player.CurrentClan == AttackingClan)
					{
						atkClanPresent = True;
					}
					else
					{
						defClanPresent = True;
						lastDefClanStayTime = Now;
					}
				}
			}
			
			if (atkClanPresent && lastDefClanStayTime + 750 < Now && goal.Gauge.Speed == 0)
			{
				foreach (playerId in goal.Sector.PlayersIds)
				{
					if (Players.existskey(playerId))
					{
						declare player <=> Players[playerId];
						if (player.CurrentClan == AttackingClan)
						{
							Score::AddPoints(player, 5000);
						}
					}
				}
				foreach (player in Players)
					player.SpeedPower = 0.1;
				Message::SendBigMessage("Victory for " ^ Teams[AttackingClan - 1].ColorizedName ^ "!", 6000, 10);
				
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
				
				RoundWinner = AttackingClan;
				goal.Gauge.Speed = -1;
				goal.Gauge.Value -= 1;
				MB_Yield();
				
				EndTime = Now + 2500;
			}
		}
	}
	
	declare lastNbOfCheckpointsCaptured for This = 0;
	if (nbOfCheckpointsCaptured != lastNbOfCheckpointsCaptured)
	{
		if (nbOfCheckpointsCaptured > lastNbOfCheckpointsCaptured)
		{
			OvertimeEndTime = -1;
			UIManager.UIAll.CountdownEndTime = -1;
		
			Message::SendStatusMessage("Checkpoints " ^ nbOfCheckpointsCaptured ^ "/" ^ Checkpoints[CurrentOrder].count ^ " captured", 4000, 5);
			Message::SendBigMessage("Checkpoint captured!", 4000, 5);
			
			PlaySound(CUIConfig::EUISound::Capture, 1);
			
			RefreshCheckpointsInterfaceVariables();
			
			IsOvertime = False;
			
			if (EndTime == -1)
				EndTime = Now;
			
			EndTime += S_GainTimeOnCapture * 1000;
		}
	
		lastNbOfCheckpointsCaptured = nbOfCheckpointsCaptured;
	}
	
	if (UIManager.UIAll.CountdownEndTime < Now
	&& UIManager.UIAll.CountdownEndTime != -1)
	{
		UIManager.UIAll.CountdownEndTime = -1;
		OvertimeEndTime = -1;
		Message::SendBigMessage("Goal Gates are open!", 4000, 10);
		
		foreach (order in Gates)
		{
			foreach (gate in order)
			{
				gate.Gate.ManualClosed = False;
				
				gate.Gauge.Value = 0;
				gate.Gauge.Max = 0;
			}
		}
	}
	
	if (!get_IsFinalGoal && RangeCaptured.existskey(CurrentOrder) && Checkpoints.existskey(CurrentOrder) && nbOfCheckpointsCaptured == Checkpoints[CurrentOrder].count
		&& !RangeCaptured[CurrentOrder])
	{
		UIManager.UIAll.CountdownEndTime = -1;
		OvertimeEndTime = -1;
	
		RangeCaptured[CurrentOrder] = True;
		Message::SendBigMessage(TextLib::Compose("$<%1$> captured the gate!", Teams[AttackingClan - 1].ColorizedName), 6000, 10);
		Message::SendStatusMessage("Range #"^ CurrentOrder ^" captured!", 6000, 10);
		
		PlaySound(CUIConfig::EUISound::ScoreProgress, 1);
		
		RefreshCheckpointsInterfaceVariables();
		
		CurrentOrder += 1;
		
		RangedProgression[AttackingClan] = CurrentOrder;
		
		if (CurrentOrder >= Checkpoints.count)
		{		
			declare netwrite Net_IsFinalGoal for Teams[0] = True;
			Net_IsFinalGoal = True;
			
			Message::SetDefaultStatusMessage("Rush time!");
			EndTime = (Now + (S_RushTime * 1000)) + S_RushTimeGateDuration;
			UIManager.UIAll.CountdownEndTime = Now + S_RushTimeGateDuration;
			
			foreach (player in Players)
			{
				if (player.CurrentClan == 3 - AttackingClan)
				{
					SendSrvMessage(player.Login, "GoRespawnScreen");
					UnspawnPlayer(player);
					
					declare respawnTime for player = Now;
					respawnTime = Now;
				}
			}
		}
		else
		{
			EndTime += S_GainTimePerNewRange * 1000;
			
			declare netwrite Net_IsFinalGoal for Teams[0] = False;
			Net_IsFinalGoal = False;
		}
		
		UpdateColors();
		UpdateGates();
	}
	else if (get_IsFinalGoal)
	{
		StormiumIT::SetGoalCount(0);
		if ((Now % 1000) == 0)
		{
			PlaySound(CUIConfig::EUISound::Custom4, 0);
		}
	}
	
	if (IsOvertime && (Now % 1000) == 0
	&& OvertimeEndTime != Now + 5000)
	{
		PlaySound(CUIConfig::EUISound::Warning, 1);
	}
	
	if ((EndTime < Now
	&& EndTime != -1)
	|| (OvertimeEndTime < Now
	&& OvertimeEndTime != -1))
	{
		if (!IsOvertime && !get_IsFinalGoal)
		{
			IsOvertime = True;
			OvertimeEndTime = Now + 5000;
			EndTime = -1;
			
			PlaySound(CUIConfig::EUISound::TimeOut, 1);
		}
		else
		{
			MB_StopRound();
			if (RoundWinner == 0)
				RoundWinner = 3 - AttackingClan;
		}
	}
	
	UpdateGetVariables();
***

***Match_EndRound***
***
	UIManager.UIAll.CountdownEndTime = -1;
	
	if (RoundWinner != 0)
	{
		ClanScores[RoundWinner] += 1;
	}

	if (RoundWinner == AttackingClan)
		MB_Sleep(2000);

	EndTime = -1;

	CurrentGameState = EGameState_Starting;
	UpdateColors();
	SM::UnspawnAllPlayers();
	
	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;
	
	MB_Sleep(3000);
	
	if (IsRangedMap && RoundWinner == AttackingClan)
	{
		LastRoundWinner = RoundWinner;		
	}
	
	declare RoundFactor = 1;
	if (IsRangedMap)
		RoundFactor = 2;
	
	if (RoundWinner != 0 && (RoundWinner == LastRoundWinner || MB_Private_SectionCount_Round >= S_MaxRounds * RoundFactor))
	{
		if (MB_Private_SectionCount_Round >= S_MaxRounds && LastRoundWinner == 0)
			LastRoundWinner = 3;
	
		MapWinner = LastRoundWinner;
		MB_StopMap();
	}
	
	LastRoundWinner = RoundWinner;
***

***Match_EndMap***
***
	// quick dirty fix
	foreach (player in Players) // Spectateur exclus
	{
		declare Integer prevPlayerClan for player.User;
		prevPlayerClan = player.CurrentClan;
		log("Sav current clan ("^prevPlayerClan^") for "^player.User.Id);
	}

	if (MapWinner != 0)
	{
		if (MapWinner != 3)
			UIManager.UIAll.BigMessage = """$<{{{Teams[MapWinner - 1].ColorizedName}}}$z$s$> wins the map!""";
		else
			UIManager.UIAll.BigMessage = _("Draw.");
			
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
		
		
		MB_Sleep(6000);
	}
	else
	{
		UIManager.UIAll.BigMessage = "Changing map...";
		MB_Sleep(1000);
	}
***

Void UpdateGates()
{
	foreach (clanOrder => order in Gates)
	{
		foreach (gate in order)
		{
			if (gate.Order < CurrentOrder)
			{
				declare _gate <=> gate.Gate;
				_gate.Automatic = False;
				if (!get_IsFinalGoal && gate.Order + 1 == RangeCaptured.count)
					_gate.ManualClosed = True;
				else
					_gate.ManualClosed = False;
					
				_gate.Clan = 0;
		
				declare gauge <=> gate.Gauge;
				if (gate.Order + 1 == RangeCaptured.count)
				{
					gauge.Value = S_RushTimeGateDuration;
					gauge.Max = S_RushTimeGateDuration;
				}
				else
				{
					gauge.Value = 0;
					gauge.Max = 0;
				}
				gauge.Speed = -1;
				gauge.Captured = False;
				gauge.Clan = 0;			
			}
		}
	}
}

Void PlaySound(CUIConfig::EUISound sound, Integer variant)
{
	UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, sound, variant);
}

Void UpdateGetVariables()
{

	declare netwrite Net_IsFinalGoal for Teams[0] = False;
	get_IsFinalGoal = RangeCaptured.count - 1 < CurrentOrder;
	Net_IsFinalGoal = get_IsFinalGoal;
	
	declare netwrite Net_CurrentOrder for Teams[0] = 0;
	Net_CurrentOrder = CurrentOrder;
	
	declare netwrite Net_IsOvertime for Teams[0] = False;
	Net_IsOvertime = IsOvertime;
	
	declare netwrite Net_OvertimeEndTime for Teams[0] = 0;
	Net_OvertimeEndTime = OvertimeEndTime;
}

Integer GetNbPlayers(Integer clan)
{
	declare count = 0;
	foreach (player in Players)
	{
		declare PlayerClan for player = 0;
		if (PlayerClan == clan)
			count += 1;
	}
	return count;
}

Integer GetTeam()
{
	if (GetNbPlayers(1) > GetNbPlayers(2))
		return 2;
	else if (GetNbPlayers(2) > GetNbPlayers(1))
		return 1;
	return AttackingClan;
}

Void BalanceTeams()
{
	/*LastTimeBalance = Now; 
	
	UIManager.UIAll.SendChat("Teams are now balanced in term of size.");
	foreach (player in Players)
	{	
		declare oldPlayerClan = player.CurrentClan;
		declare PlayerClan for player = GetTeam();
		PlayerClan = GetTeam();
		//yield;
		
		if (oldPlayerClan != PlayerClan)
		{
			UnspawnPlayer(player);
			declare UI <=> UIManager.GetUI(player);
			if (UI != Null)
			{
				UI.SendChat("$999Team notice: $fffYou was redirected to " ^ Teams[PlayerClan - 1].ColorizedName ^ " team"); 
			}
		}
	}*/
}

Boolean IsValidSpawn(CSmMapLandmark spawn, CSmPlayer player)
{
	declare isAvailable = True;

	declare spawnClan for spawn = 0;
	if (spawnClan != spawn.Base.Clan)
		UIManager.UIAll.SendChat(spawnClan ^ " : " ^ spawn.Base.Clan);
	if (spawnClan == player.CurrentClan)
	{
		isAvailable = True;
	}
	else
		isAvailable = False;
		
	if (spawn.Tag == "SpawnGoal" && player.CurrentClan == AttackingClan)
		isAvailable = False;
	if (spawn.Tag == "SpawnAttack" && get_IsFinalGoal)
		isAvailable = False;
	if (spawn.Tag == "SpawnGoal" && player.CurrentClan == 3 - AttackingClan && !get_IsFinalGoal)
		isAvailable = False;
						
	return isAvailable;
}

Integer SpeedValue(CSmMapGauge gauge, CSmPlayer[] players)
{
	declare value = 0;
	foreach (player in players)
	{
		declare lastUpdateTimeForScore for player = 0;
		if (player.CurrentClan == AttackingClan)
		{
			declare netwrite Net_IsDisguise for player = False;
			if (!Net_IsDisguise)
			{
				value += 1;
				
				if (gauge.Value != gauge.Max)
				{
					if (lastUpdateTimeForScore < Now)
					{
						lastUpdateTimeForScore = Now + 100;
						Score::AddPoints(player, 3);
					}
				}
			}
		}
		else
		{ 
			if (gauge.Value != gauge.Max && value > 0)
			{
				if (lastUpdateTimeForScore < Now)
				{
					lastUpdateTimeForScore = Now + 100;
					Score::AddPoints(player, value);
				}
			}
		
			value -= 1;
		}
	}
	
	if (value < 0)
		value = 0;
	if (value > 1 && !S_MultiPlayerFasterCap)
		value = 1;
	
	return value;
}

Text MLPos(Vec3 pos)
{
	return """{{{pos[0]}}} {{{pos[1]}}} {{{pos[2]}}}""";
}

Text layer_GetBalance()
{
	return """
	<manialink version="3">
		<!-- Panneau de vote -->
		<frame pos="-124 76" scale="0.8" z-index="2" id="votePane" hidden="0">
			<label pos="55.8 -0.20" z-index="2" id="LabelVote" size="116 7.6" textprefix="$s" text="xxxx $z$s$fff, requires a balancing of teams according $0D0to xxxx" textsize="2" halign="center" valign="center"/>
			<label pos="-6 0.5" z-index="2" id="countdown" size="7 7" textprefix="$s" text="60" textsize="0.6" halign="center" valign="center" rot="-40" opacity=".9"/>
			<label pos="-6.6 0.6" z-index="2" text=" ï‡›" halign="center" valign="center" textsize="3.2" opacity=".6"/>
			<quad pos="-8.9 3.53" z-index="-1" size="126 18.7" style="Bgs1" substyle="BgButtonGrayed" opacity=".0"/>
			<quad pos="-8.9 3.53" z-index="0" size="126 18.7" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000"/>
			<quad pos="54.1 -0.27" z-index="1" size="126 7.6" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000" halign="center" valign="center"/>
			
			<frame pos="0 0" z-index="1" id="voteYes">
			<!--<label pos="14 -9.5" z-index="2" size="30 7.6" textprefix="$s" text="Yes [F3] - 00" textsize="2" halign="center" valign="center" opacity=".4"/>-->
			<label pos="12 -9.5" z-index="2" size="30 7.6" textprefix="$s$0d0" text="Yes $fff[F3] - " textsize="2" halign="center" valign="center"/>
			<label pos="22.5 -9.5" z-index="2" id="LabelVoteNbYes" size="12 7.6" textprefix="$s" text="0" textsize="2" halign="center" valign="center"/>
			<quad pos="14 -9.5" z-index="1" size="30 7.6" id="QuadBgVoteYes" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000" halign="center" valign="center"/>
			</frame>
			
			<frame pos="40 0" z-index="1" id="voteNo">
			<!--<label pos="14 -9.5" z-index="2" size="30 7.6" textprefix="$s" text="No [F4] - 00" textsize="2" halign="center" valign="center" opacity=".4"/>-->
			<label pos="12 -9.5" z-index="2" size="30 7.6" textprefix="$s$e00" text="No $fff[F4] - " textsize="2" halign="center" valign="center"/>
			<label pos="22 -9.5" z-index="2" id="LabelVoteNbNo" size="12 7.6" textprefix="$s" text="0" textsize="2" halign="center" valign="center"/>
			<quad pos="14 -9.5" z-index="1" size="30 7.6" id="QuadBgVoteNo" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000" halign="center" valign="center"/>
			</frame>
			
			<frame pos="80 0" z-index="1" id="voteScore">
			<!--<label pos="14 -9.5" z-index="2" size="36 7.6" textprefix="$s" text="To scores [F5] - 00" textsize="2" halign="center" valign="center" opacity=".4"/>-->
			<label pos="12 -9.5" z-index="2" size="36 7.6" textprefix="$s$f90" text="To scores $fff[F5] - " textsize="2" halign="center" valign="center" />
			<label pos="27.6 -9.5" z-index="2" id="LabelVoteNbOther" size="12 7.6" textprefix="$s" text="0" textsize="2" halign="center" valign="center"/>
			<quad pos="14 -9.5" z-index="1" size="36 7.6" id="QuadBgVoteOther" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000" halign="center" valign="center"/>
			</frame>
			
			<frame pos="80 0" z-index="1" id="voteRank">
			<!--<label pos="14 -9.5" z-index="2" size="36 7.6" textprefix="$s" text="To ranks [F5] - 00" textsize="2" halign="center" valign="center" opacity=".4"/>-->
			<label pos="12 -9.5" z-index="2" size="36 7.6" textprefix="$s$f90" text="To ranks $fff[F5] - " textsize="2" halign="center" valign="center" />
			<label pos="26.8 -9.5" z-index="2" id="LabelVoteNbOther" size="12 7.6" textprefix="$s" text="0" textsize="2" halign="center" valign="center"/>
			<quad pos="14 -9.5" z-index="1" size="36 7.6" id="QuadBgVoteOther" style="BgsPlayerCard" substyle="ProgressBar" opacity=".6" colorize="000" halign="center" valign="center"/>
			</frame>
		</frame>	

		<script><!--
			Void votePanel(Boolean display) {
				declare CMlFrame votePane = (Page.GetFirstChild("votePane") as CMlFrame);
				
				votePane.Visible = display;
				if (display) {
					declare netread Net_VoteBalanceResult2 for Teams[0] = [Text[],Text[],Text[]];
					
					declare netread Net_PlayerNameRequestVoting for Teams[0] = Text;
					declare netread Net_BalanceType for Teams[0] = Integer;
			
					declare Text BalanceType;
					declare CMlFrame voteScore = (votePane.GetFirstChild("voteScore") as CMlFrame);
					declare CMlFrame voteRank = (votePane.GetFirstChild("voteRank") as CMlFrame);
					declare CMlFrame voteOther;
					if (Net_BalanceType == 1) {
						BalanceType = "ranks$fff.";
						voteRank.Visible = False;
						voteScore.Visible = True;
						voteOther <=> voteScore;
					} else {
						BalanceType = "scores$fff.";
						voteRank.Visible = True;
						voteScore.Visible = False;
						voteOther <=> voteRank;
					}
					
					declare CMlLabel countdown = (votePane.GetFirstChild("countdown") as CMlLabel);
					declare netread Net_CountdownVoteBalance for Teams[0] = Text;
					countdown.Value = Net_CountdownVoteBalance;
					
					declare CMlLabel LabelVote = (Page.GetFirstChild("LabelVote") as CMlLabel);
					LabelVote.Value = Net_PlayerNameRequestVoting^"$z$s$fff, requires a balancing of teams according $0D0to "^BalanceType;
					declare CMlLabel LabelVoteNbYes = (votePane.GetFirstChild("LabelVoteNbYes") as CMlLabel);
					declare CMlQuad QuadBgVoteYes = (votePane.GetFirstChild("QuadBgVoteYes") as CMlQuad);
					declare CMlLabel LabelVoteNbNo = (votePane.GetFirstChild("LabelVoteNbNo") as CMlLabel);
					declare CMlQuad QuadBgVoteNo = (votePane.GetFirstChild("QuadBgVoteNo") as CMlQuad);
					declare CMlLabel LabelVoteNbOther = (voteOther.GetFirstChild("LabelVoteNbOther") as CMlLabel);
					declare CMlQuad QuadBgVoteOther = (voteOther.GetFirstChild("QuadBgVoteOther") as CMlQuad);
					
					declare LabelNbVote = [LabelVoteNbYes, LabelVoteNbNo, LabelVoteNbOther];
					declare QuadBgVote = [QuadBgVoteYes, QuadBgVoteNo, QuadBgVoteOther];
					foreach (key => option in Net_VoteBalanceResult2) {
						if (option.exists(LocalUser.Login)) {
							LabelNbVote[key].Value = "$0a0"^option.count;
							QuadBgVote[key].Colorize = <.2, 1., .2>;
						} else {
							LabelNbVote[key].Value = "$fff"^option.count;
							QuadBgVote[key].Colorize = <0., 0., 0.>;
						}
					}
				}
				
			}
			
			main()
			{
				while(True)
				{
					yield;
				
					declare netread Net_BalancingIsRequired for Teams[0] = False;
					
					foreach (event in PendingEvents)
					{
						if (event.Type == CMlScriptEvent::Type::KeyPress) {
							if (Net_BalancingIsRequired) {
								declare netwrite Net_PlayerVote for UI = 0;
								if (event.KeyName == "F3") {
									Net_PlayerVote += 1;
								} else if (event.KeyName == "F4") {
									Net_PlayerVote += 2;
								} else if (event.KeyName == "F5") {
									Net_PlayerVote += 3;
								}
							}
							
						}
					}

					votePanel(Net_BalancingIsRequired);
				}
			}
		--></script>
	</manialink>
	""";
}

Text layer_GetSpawnInterface()
{
	declare CC = "halign='center' valign='center'";
	declare ml_spawnFrame = """ """;
	declare spawnCount = MapLandmarks_PlayerSpawn.count;
	for (i, 0, 20)
	{
		ml_spawnFrame ^= """
			<frameinstance posn="0 -{{{i*16}}} 0" modelid="fm_Spawn"		id="fi_Spawn({{{i}}})" />
		""";
	}
	
	return """
	<manialink version="2">
	<frame id="MainSelection" posn="0 0 99999">
		<quad posn="0 16 100" halign="center" valign="center" sizen="60 20.25" style="Bgs1InRace" substyle="BgGradTop"/>
		<quad posn="0 -16 100" halign="center" valign="center" sizen="60 20.25" style="Bgs1InRace" substyle="BgGradBottom"/>
		<frame posn="-60 0 10" scale="1" id="FrameViewReady" hidden="1">
			<label posn="0 0 10" textfont="Oswald" halign="center" valign="center2" sizen="60 20" text="Spawn Selection (L)" textsize="4" />
			<quad posn="0 0" halign="center" valign="center" bgcolor="222" bgcolorfocus="333" scriptevents="1" sizen="60 20" id="setSpawnSelection"/>
		</frame>	
		<frame posn="0 16" scale="1" id="FrameViewReady">
			<label posn="0 0 10" textfont="Oswald" halign="center" valign="center2" sizen="60 20" text="GO (F6)" textsize="4" />
			<quad posn="0 0" halign="center" valign="center" bgcolor="222" scriptevents="1" sizen="60 20" id="setReady"/>
		</frame>	
		<frame posn="0 -16" scale="1" id="FrameViewReady">
			<label posn="0 0 10" textfont="Oswald" halign="center" valign="center2" sizen="80 20" text="Kit Selection (K)" textsize="4" />
			<quad posn="0 0" halign="center" valign="center" bgcolor="222" scriptevents="1" bgcolorfocus="333" sizen="60 20" id="setClassSelection"/>
		</frame>	
	</frame>
	
		<framemodel id="fm_Class">
			<label {{{CC}}} posn="-22.5 0 2" id="Label_Icon" text="î¥ª"/>
			<quad posn="0 -6.5 1" id="Quad_Selected" style="BgRaceScore2" rot="-90" substyle="CartoucheLine" halign="left" valign="center" sizen="13 60" colorize="0f0"/>
			<label textfont="Oswald" id="Label_SelectClass" scriptevents="1" posn="0 0 0" halign="center" valign="center" text="SOLDIER" sizen="60 12" textsize="4" />
			<label textfont="RajdhaniMono" id="Label_KitCounter" posn="20 0 0" halign="center" valign="center" text="0" sizen="60 15" textsize="4" />
		</framemodel>
		<framemodel id="fm_Spawn">
			<quad posn="0 -8 1" id="Quad_Selected" style="BgRaceScore2" rot="90" substyle="CartoucheLine" halign="right" valign="center" sizen="16 60" colorize="0f0"/>
			<label textfont="Oswald" id="Label_SelectSpawn" scriptevents="1" posn="0 0 0" halign="center" valign="center" text="SPAWN #1" sizen="60 15" textsize="4" />
		</framemodel>
	<frame id="mainFrame">
		<!--<frame hidden="1">
			<minimap posn="0 0 1" halign="center" valign="center" sizen="75 75" id="Minimap_Main" />
			<quad halign="center" valign="center" sizen="95 95" image="file://Media/Manialinks/Common/StationInfo/WindowBg.dds" />
			<quad halign="center" valign="center" sizen="80 80" image="file://Media/Manialinks/Common/Minimap/MinimapOverlay2.dds" posn="0 0 2" />
		</frame>-->
		
		<frame posn="0 0 0" id="Frame_AtkInfo">
			<label id="Label_AtkInfo" {{{CC}}} text="You are attacking!" textprefix="$s" textfont="OswaldMono"/>
		</frame>
		
		<frame posn="0 0 10" id="Clip_FrameKitInfo" clipsizen="180 80" clip="1" clipposn="0 0" hidden="1">
			<frame posn="0 0" id="FrameKitInfo">
				<label posn="-88 30" halign="left" valign="bottom" textfont="Oswald" textprefix="$t" id="Label_DescClassName" text="Soldier" textsize="8" />
				<quad posn="-90 30" halign="left" valign="bottom" bgcolor="000" opacity="1" sizen="45 10" />
				<quad halign="center" valign="center" bgcolor="000" opacity="0.8" posn="0 -5" sizen="180 70" />
				<label halign="right" valign="center" posn="85 35 5" textprefix="$sï© " text="Press '1' to heal yourself" />	
				
				<frame posn="0 25.75 5" id="FrameDescShootButton" scale="0.95">
					<label posn="-86 0 2" text="î¦ SHOOT BUTTON" halign="left" valign="top" textfont="Oswald" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionShoot" posn="-80 -7.5 0" textprefix="$sï© " text="MultiPlasma / MiniGun" />	
				</frame>
				<frame posn="0 8.5 5" id="FrameDescAction1Button" scale="0.95">
					<label id="Label_Action1Button" posn="-86 0 2" text=" A   BUTTON" halign="left" valign="top" textfont="Oswald" />
					<label posn="-84.5 -1.5 2" text=" ï‡›" halign="center" valign="center" textfont="Oswald" textsize="5" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionAction1" posn="-80 -7.5 0" textprefix="$sï© " text="Switch Weapon between MultiPlasma and MiniGun" />	
				</frame>
				<frame posn="0 -8.5 5" id="FrameDescAction2Button" scale="0.95">
					<label posn="-86 0 2" text=" E   BUTTON" halign="left" valign="top" textfont="Oswald" />
					<label posn="-84.5 -1.5 2" text=" ï‡›" halign="center" valign="center" textfont="Oswald" textsize="5" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionAction2" posn="-80 -7.5 0" textprefix="$sï© " text="Grenade" />	
				</frame>
				
				<label id="Label_DescriptionWarning" posn="-84 -22" sizen="170" autonewline="1" halign="left" valign="top" textprefix="$f00" text="î¤š MultiPlasma is very powerful with 4 amunitions !
î¤š MiniGun can explose if it is used too long !" textsize="2"/>

			</frame>
		</frame>
		
		<frame posn="0 70" id="FrameViewLogo" hidden="1">
			<quad posn="0 -10.75" sizen="60 20" halign="center" valign="center" image="https://cdn.discordapp.com/attachments/244514503323025408/316925411625795587/AgeLogo.png" keepratio="Fit" />	
			<quad posn="0 0 -59" halign="center" valign="center" bgcolor="555" opacity="0.5" sizen="360 40" />	
		</frame>
		
		<frame posn="-130 25" scale="1" id="FrameViewSpawns">
			<quad posn="0 -25 -60" style="Bgs1" substyle="BgEmpty" halign="center" valign="center" sizen="75 100" />
			<label posn="0 -70 1" halign="center" valign="center" style="TextButtonNav" scriptevents="1" text="$sðŸŽ¥ Reset Spawn Selection" sizen="60 10" id="resetView" />
			<label posn="0 32 10" halign="center" valign="center" textfont="Oswald" text="$fff$tSelect your spawn" sizen="40 10" scale="1.5" />
			<quad posn="0 25.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 0.75" />
			<label posn="0 25.5 10" halign="center" valign="center" textcolor="fff" text="$fffâ·" sizen="40 10" scale="2" />
			
			{{{ml_spawnFrame}}}
		</frame>
		
		<frame posn="130 25" id="FrameViewKits" hidden="1">
			<quad posn="0 -25 -60" style="Bgs1" substyle="BgEmpty" halign="center" valign="center" sizen="75 100" />
			<label posn="0 32 10" halign="center" valign="center" textfont="Oswald" text="$fff$tSelect your kit" sizen="40 10" scale="1.5" />
			<quad posn="0 25.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 0.75" />
			<label posn="0 25.5 10" halign="center" valign="center" textcolor="fff" text="$fffâ·" sizen="40 10" scale="2" />
			
			<frame posn="0 -25">
				<frameinstance modelid="fm_Class" id="Frame_Class1" posn="0 42.5"/>
				<frameinstance modelid="fm_Class" id="Frame_Class2" posn="0 30"/>
				<frameinstance modelid="fm_Class" id="Frame_Class3" posn="0 17.5"/>
				<frameinstance modelid="fm_Class" id="Frame_Class4" posn="0 5"/>
				<frameinstance modelid="fm_Class" id="Frame_Class5" posn="0 -7.5"/>
				<frameinstance modelid="fm_Class" id="Frame_Class6" posn="0 -20"/>
				<frameinstance modelid="fm_Class" id="Frame_Class7" posn="0 -32.5"/>
			</frame>
		</frame>
	</frame>
	
	<label id="Label_MatchStartTime" halign='center' valign='center' posn="0 0 -5" textprefix="$s" text="Start in..." textfont="RajdhaniMono" textsize="8"/>
	
	<label id="labelFps" posn="-160 -60" text="FPS" />
		
		<script><!--
			#Include "TextLib" as TL
			#Include "MathLib" as MathLib
			
			#Const C_Quad_IsSelected	"file://Media/Manialinks/Common/WarmUp/ButtonOn.dds"
			#Const C_Quad_IsNotSelected	"file://Media/Manialinks/Common/WarmUp/ButtonOff.dds"
			
			declare CMlFrame[] SpawnsFrame;
			declare CSmMapLandmark CurrentSelectedSpawn;
			
			declare CMlFrame MainSelection;
			
			declare CMlFrame FrameViewSpawns;
			declare CMlFrame FrameViewKits;
			declare CMlFrame FrameViewReady;
			declare CMlFrame FrameViewLogo;
			
			declare CMlLabel Label_AtkInfo;
			
			declare Integer CurrentSelectedState;
			
			Real Lerp(Real a, Real b, Real _t)
			{
				declare t = _t;
				if (t > 1.0)
					t = 1.0;
			
				return a*(1-t) + b*t;
			}
			
			Vec3 Lerp(Vec3 a, Vec3 b, Real _t)
			{
				declare t = _t;
				if (t > 1.0)
					t = 1.0;
			
				declare v1 = a[0]*(1-t) + b[0]*t;
				declare v2 = a[1]*(1-t) + b[1]*t;
				declare v3 = a[2]*(1-t) + b[2]*t;
				
				return <v1, v2, v3>;
			}
		
			Vec3 stringToVec3(Text string)
			{
				log(">" ^ string);
				declare Text[] Members = TL::Split(",", string);
				Members[0] = TL::Replace(Members[0], "<", "");
				Members[2] = TL::Replace(Members[2], ">", "");
				return <TL::ToReal(Members[0]), TL::ToReal(Members[1]), TL::ToReal(Members[2])>;
			}
			
			Void UpdateAvailableSpawns()
			{			
				if (InputPlayer == Null)
					return;
					
				declare netread Net_AttackingClan for Teams[0] = 1;
				declare netread Net_IsFinalGoal for Teams[0] = False;
				declare netread Net_SpawnClan for Teams[0] = Integer[Integer];
				declare netread Net_CurrentOrder for Teams[0] = 0;
			
				declare playerClan = InputPlayer.CurrentClan;
				
				//< Instant spawn
					declare availableCount = 0;
					declare availableIndex = 0;
				//>
				
				if (CurrentSelectedSpawn != Null) 
				{	
					declare spawn <=> CurrentSelectedSpawn;
					declare key = MapLandmarks_PlayerSpawn.keyof(spawn);
					if (spawn.Tag == "SpawnGoal" && playerClan == Net_AttackingClan)
						CurrentSelectedSpawn = Null;
					if (spawn.Tag == "SpawnAttack" && Net_IsFinalGoal)
						CurrentSelectedSpawn = Null;
					if (spawn.Tag == "SpawnGoal" && playerClan == 3 - Net_AttackingClan && !Net_IsFinalGoal)
						CurrentSelectedSpawn = Null;	
					if (!Net_SpawnClan.existskey(key) || Net_SpawnClan[key] != playerClan)
						CurrentSelectedSpawn = Null;

				}

				foreach (i => frame in SpawnsFrame)
				{
					declare isAvailable for frame = True;
					isAvailable = True;
					
					declare CSmMapLandmark spawn;
					if (!MapLandmarks_PlayerSpawn.existskey(i))
						isAvailable = False;
					else
					{
						spawn <=> MapLandmarks_PlayerSpawn[i];
					
						if (spawn.Tag == "SpawnGoal" && playerClan == Net_AttackingClan)
						{	isAvailable = False; }
						if (spawn.Tag == "SpawnAttack" && Net_IsFinalGoal)
						{	isAvailable = False; }
						if (spawn.Tag == "SpawnGoal" && playerClan == 3 - Net_AttackingClan && !Net_IsFinalGoal)
						{	isAvailable = False; }
						if (Net_SpawnClan.existskey(i) && Net_SpawnClan[i] != playerClan)
						{	isAvailable = False; }
						if (playerClan == 3 - Net_AttackingClan && spawn.Order != Net_CurrentOrder)
						{
							isAvailable = False;
						}
						if (playerClan == 3 - Net_AttackingClan && spawn.Tag == "SpawnGoal" && Net_IsFinalGoal)
						{
							isAvailable = True;
						}
					}
					
					frame.Visible = isAvailable;
					
					declare spawnIndex for frame = 0;
					spawnIndex = i;

					if (isAvailable)
					{
						frame.RelativePosition.Y = 16 -(availableCount * 16.); 
						
						availableCount += 1;
						availableIndex = i;
						
						declare nameLabel for frame = CMlLabel;
						declare spawnName = "Spawn #" ^ i;
						declare spawnPosition for frame = Vec3;
						declare metadata LandmarkCustomName for spawn = "";
						if (LandmarkCustomName != "")
							spawnName = LandmarkCustomName;
							
						spawnPosition = spawn.Position;
						
						nameLabel.SetText("$t" ^ spawnName);
						
						if (CurrentSelectedSpawn == Null)
							CurrentSelectedSpawn <=> spawn;
					}
				}
				
				if (availableCount == 1)
				{
					if (MapLandmarks_PlayerSpawn.existskey(availableIndex))
						CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[availableIndex];
				}
			}
			
			Void ManageGameView()
			{
				declare ClientMarkers for LocalUser = Text[Text];
			
				declare ActivePlayer <=> InputPlayer;
				if (GUIPlayer != Null)
					ActivePlayer <=> GUIPlayer;
			
				if (CurrentSelectedSpawn != Null)
				{
					declare p = CurrentSelectedSpawn.Position;
					
					if (ActivePlayer.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
						ClientMarkers["age"] ^= "<marker pos='" ^ p.X ^ " " ^ p.Y + 2.5 ^ " " ^ p.Z ^ "' label='Selected Spawn' color='4f4'/>";
				
					ClientUI.SpectatorForcedTarget = CurrentSelectedSpawn.Id;
					if (ActivePlayer != Null)
						ClientUI.SpectatorForcedClan = ActivePlayer.CurrentClan;
				}
				else
					ClientUI.SpectatorForcedTarget = NullId;
					
				if (GUIPlayer != Null)
				{
					ClientUI.OverlayHideGauges = (InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !IsSpectator);
				}
				
				declare netread Net_AttackingClan for Teams[0] = 1;
				
				declare netread Net_MatchIsRunning for Teams[0] = False;
				
				if (ActivePlayer != Null && Net_MatchIsRunning)
				{
					if (ActivePlayer.CurrentClan == Net_AttackingClan)
						Label_AtkInfo.SetText("You are attacking!");
					else if (ActivePlayer.CurrentClan == 3 - Net_AttackingClan)
						Label_AtkInfo.SetText("You are defending!");
				}
				else
					Label_AtkInfo.SetText("");
			}
			
			Void ManageFramePos(Real deltaTime)
			{
				declare netread Net_MatchIsRunning for Teams[0] = False;
				declare ClassSelectionIsOpen for LocalUser = False;
			
				declare goViewKits_pos = <200., 25., 0.>;
				declare goViewSpawns_pos = <-200., 25., 0.>;
				declare goTopView_pos = <0., 120., 0.>;
				declare goBottomView_pos = <0., -120., 0.>;
				declare goLabelAtkInfo_pos = <0., -60., 0.>;
				declare goMainSelection_pos = <0., 0., 0.>;
				if (InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned
					&& !IsSpectator)
				{
					ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
				
					goViewKits_pos = <130., 25., 0.>;
					goViewSpawns_pos = <-130., 25., 0.>;
					goTopView_pos = <0., 70., 0.>;
					if (GUIPlayer == Null)
						goBottomView_pos = <0., -75., 0.>;
					else
						goBottomView_pos = <0., -90., 0.>;
						
					goLabelAtkInfo_pos = <0., 40., 0.>;
					if (ClassSelectionIsOpen)
					{
						goMainSelection_pos = <0., -9999., 0.>;
						goViewSpawns_pos.X = -300.;
					}
				}
				else
				{
					ClientUI.UISequence = CUIConfig::EUISequence::None;
				
					goMainSelection_pos = <0., -999., 0.>;
				}
					
				FrameViewKits.RelativePosition = Lerp(FrameViewKits.RelativePosition, goViewKits_pos, deltaTime * 10.);
				FrameViewSpawns.RelativePosition = Lerp(FrameViewSpawns.RelativePosition, goViewSpawns_pos, deltaTime * 10.);
				FrameViewLogo.RelativePosition = Lerp(FrameViewLogo.RelativePosition, goTopView_pos, deltaTime * 10.);
				MainSelection.RelativePosition = Lerp(MainSelection.RelativePosition, goMainSelection_pos, deltaTime * 40.);
				//FrameViewReady.RelativePosition = Lerp(FrameViewReady.RelativePosition, goBottomView_pos, deltaTime * 16.);
				
				Label_AtkInfo.RelativePosition = Lerp(Label_AtkInfo.RelativePosition, goLabelAtkInfo_pos, deltaTime * 20.);
			}
			
			Text GetDescShoot(Text kit)
			{
				if (kit == "soldier")
					return "MultiPlasma / MiniGun";
				if (kit == "sniper")
					return "Sniper Gun";
				if (kit == "ninja")
					return "Knife";
				if (kit == "mage")
					return "BumpHell";
				if (kit == "medic")
					return "Nanogun / Medigun (Nanogun Field)";
				if (kit == "engineer")
					return "Shotgun";
				if (kit == "teamlord")
					return "CrossBoom";
				return "???";
			}
			
			Text GetDescAction1(Text kit)
			{
				if (kit == "soldier")
					return "Switch Weapon";
				if (kit == "sniper")
					return "Eagle Eye";
				if (kit == "ninja")
					return "Player Disguise";
				if (kit == "mage")
					return "Curse";
				if (kit == "medic")
					return "Switch Weapon";
				if (kit == "engineer")
					return "Turret";
				if (kit == "teamlord")
					return "Mega Buff (not done yet)";
				return "???";
			}
			
			Text GetDescAction2(Text kit)
			{
				if (kit == "soldier")
					return "Grenade";
				if (kit == "sniper")
					return "Grenade";
				if (kit == "ninja")
					return "Smoke Grenade";
				if (kit == "mage")
					return "Forcefield";
				if (kit == "medic")
					return "Boucing Ball (Heal Allies)";
				if (kit == "engineer")
					return "Grenade";
				if (kit == "teamlord")
					return "Grenade (will use another weapon soon)";
				return "???";
			}
			
			Text GetDescWarning(Text kit)
			{
				if (kit == "soldier")
					return "î¤š The more the MultiPlasma is charged, the more the damage you do!\nî¤š MiniGun can explose if it is used too long!";
				if (kit == "sniper")
					return "î¤š Using Sniper, stop moving at least 3 seconds to get Explosive Bullets! You can do headshot to shoot harder.\nî¤š Eagle Eye gives Resistance, Strength, and faster reloads to you and reveal ennemies!";
				if (kit == "ninja")
					return "î¤š You will heal each time you hit someone with the knife!\nî¤š You can Disguise to look like an ennemy! You loose your disguise when you are shot. You takes damages while being disguised.";
				if (kit == "mage")
					return "î¤š BumpHell pushes players in the air ! It doesn't make a lot of damages thought.\nî¤š Curse gives weakness to the hit player, he takes twice more damages and move slower!\nForcefield create an explosive area around the hit player !";
				if (kit == "medic")
					return "î¤š Nanogun can damage ennemies and heal your allies.\nî¤š The medigun (or nanogun field) can heal multiple target at the same time, but can't deal damage.\nî¤š The Healing Bouncing Ball is a big ball that heal all your teammates around it !";
				if (kit == "engineer")
					return "î¤š Shotgun is more powerful near the ennemy than far ! It can push players pretty far.\nî¤š Turret are placeable everywhere. You can heal your turret by staying next to it ! Turret upgrade when it stays alive.";
				if (kit == "teamlord")
					return "î¤š The CrossBoom can be charged while holding the shoot button to have a bigger shoot power, but it will be innacurate for a short period of time after a shot.\nî¤š The more there are allies near of you, the more you have a boost defense and the more they have a better firerate.";
				return "???";
			}
		
			main()
			{				
				MainSelection <=> (Page.GetFirstChild("MainSelection") as CMlFrame);
				for (I, 0, 20)
				{
					declare frame <=> cast(CMlFrame, Page.GetFirstChild("fi_Spawn("^I^")"));
					SpawnsFrame.add(frame);
					
					declare Vec3 pos;
					
					foreach (spawn in MapLandmarks_PlayerSpawn)
					{
						if (spawn != Null)
						{
							pos = spawn.Position;
						}
					}
					
					declare spawnPosition for frame = pos;
					declare spawnIndex for frame = I;
					
					declare nameLabel for frame = (frame.GetFirstChild("Label_SelectSpawn") as CMlLabel);
					declare quadSelected for frame = (frame.GetFirstChild("Quad_Selected") as CMlQuad);
					
					declare parentFrame for nameLabel = CMlFrame;
					parentFrame = frame;
				}
				
				declare FrameClasses = CMlFrame[];
				for (I, 1, 7)
				{
					declare frame <=> (Page.GetFirstChild("Frame_Class" ^ I) as CMlFrame);
					declare classLabel for frame <=> (frame.GetFirstChild("Label_SelectClass") as CMlLabel);
					declare classIcon for frame <=> (frame.GetFirstChild("Label_Icon") as CMlLabel);
					declare quadSelected for frame <=> (frame.GetFirstChild("Quad_Selected") as CMlQuad);
					declare counterLabel for frame <=> (frame.GetFirstChild("Label_KitCounter") as CMlLabel);
					declare isSelected for classLabel = False;
					
					if (I == 1) { classLabel.Value = "SOLDIER"; classIcon.Value = "î¥ª"; }
					if (I == 2) { classLabel.Value = "SNIPER"; classIcon.Value = "ï›"; }
					if (I == 3) { classLabel.Value = "MAGE"; classIcon.Value = "ïƒ"; }
					if (I == 4) { classLabel.Value = "NINJA"; classIcon.Value = "ðŸƒ"; }
					if (I == 5) { classLabel.Value = "ENGINEER"; classIcon.Value = "ðŸ”§"; }
					if (I == 6) { classLabel.Value = "MEDIC"; classIcon.Value = "ïˆž"; }
					if (I == 7) { classLabel.Value = "TEAMLORD"; classIcon.Value = "ïˆš"; }
					
					declare originalKit for classLabel = TL::ToLowerCase(classLabel.Value);
					
					quadSelected.Colorize = <1., 1., 1.>;
					quadSelected.Opacity = 0.25;
					
					FrameClasses.add(frame);
				}
				
				FrameViewSpawns <=> (Page.GetFirstChild("FrameViewSpawns") as CMlFrame);
				FrameViewKits <=> (Page.GetFirstChild("FrameViewKits") as CMlFrame);
				FrameViewReady <=> (Page.GetFirstChild("FrameViewReady") as CMlFrame);
				FrameViewLogo <=> (Page.GetFirstChild("FrameViewLogo") as CMlFrame);
				
				declare FrameKitInfo <=> (Page.GetFirstChild("FrameKitInfo") as CMlFrame);
				declare Label_DescriptionShoot <=> (FrameKitInfo.GetFirstChild("Label_DescriptionShoot") as CMlLabel);
				declare Label_DescriptionAction1 <=> (FrameKitInfo.GetFirstChild("Label_DescriptionAction1") as CMlLabel);
				declare Label_DescriptionAction2 <=> (FrameKitInfo.GetFirstChild("Label_DescriptionAction2") as CMlLabel);
				declare Label_DescriptionWarning <=> (FrameKitInfo.GetFirstChild("Label_DescriptionWarning") as CMlLabel);
				declare Label_Action1Button <=> (FrameKitInfo.GetFirstChild("Label_Action1Button") as CMlLabel);
				declare Label_DescClassName <=> (FrameKitInfo.GetFirstChild("Label_DescClassName") as CMlLabel);
				Label_AtkInfo <=> (Page.GetFirstChild("Label_AtkInfo") as CMlLabel);
			
				declare netwrite Net_playerWantRespawn for UI = False;
				declare netwrite Net_playerSpawn for UI = 0;
				declare netwrite Net_playerSpawnOrder for UI = 0;
				declare netwrite Net_playerLastTime for UI = Now;
				declare netwrite Net_playerWantedKit for UI = "soldier";
				
				declare netread Net_MatchStartTime for Teams[0] = 0;
				
				declare netread Net_IsFinalGoal for Teams[0] = False;
				
				declare netread NetSrv_Handle for Teams[0] = ["" => -1];
				declare netread NetSrv_Message for Teams[0] = ["" => ""];
				
				declare lastHandle = ["ALL" => -2, LocalUser.Login => -2];
				
				declare netread NetServ_Dest for Teams[0] = Text[];
				
				declare labelFps = cast(CMlLabel, Page.GetFirstChild("labelFps"));
				
				// Reset
				Net_playerWantRespawn = False;
				Net_playerLastTime = Now;
				Net_playerSpawn = -1;
				
				if (LocalUser != Null)
					UpdateAvailableSpawns();
				
				declare refreshFrames = Now;
				
				declare MainFrame = cast(CMlFrame, Page.GetFirstChild("mainFrame"));
				
				declare QuadReady = cast(CMlQuad, Page.GetFirstChild("setReady"));
				declare Label_MatchStartTime = cast(CMlLabel, Page.GetFirstChild("Label_MatchStartTime"));
				
				declare lastTimeDelta = Now;
				declare TimeDelta = Now + 0.;
				declare lastLog = Now;
				
				declare ClientMarkers for LocalUser = Text[Text];
				
				declare ClassSelectionIsOpen for LocalUser = False;
				CurrentSelectedState = -1;
				
				while(True)
				{
					yield;
					
					TimeDelta = -(lastTimeDelta - Now) / 1000.;
					lastTimeDelta = Now;
					
					ClientMarkers["age"] = "";
					
					if (Net_MatchStartTime > ArenaNow)
					{
						Label_MatchStartTime.SetText("Start in... " ^ MathLib::FloorInteger((Net_MatchStartTime - ArenaNow) * 0.001) ^ "s"); 
					}
					else
					{
						declare netread Net_MatchIsRunning for Teams[0] = False;
						
						if (Net_MatchIsRunning)
							Label_MatchStartTime.SetText("");
						else
							Label_MatchStartTime.SetText("Please wait...");
					}
					
					ManageFramePos(TimeDelta);
					
					if (LocalUser == Null || InputPlayer == Null)
					{
						CurrentSelectedState = -1;
						FrameKitInfo.RelativePosition = Lerp(FrameKitInfo.RelativePosition, <0., -90., 0.>, TimeDelta * 50.);
						continue;
					}
										
					if (lastLog < Now)
					{
						lastLog = Now - 1;
						labelFps.SetText("FPS: " ^ 1 / TimeDelta);
					}
						
					/*MainFrame.Visible = Net_IsFinalGoal || InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned;
					Minimap.Visible = Net_IsFinalGoal || InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned;*/	
					
					if (!ClassSelectionIsOpen && CurrentSelectedState == 1)
					{
						ClassSelectionIsOpen = True;
						CurrentSelectedState = -1;
					}
					
					if (LocalUser.Language == "fr")
					{
						Label_Action1Button.SetText(" A   BUTTON");
					}
					else
						Label_Action1Button.SetText(" Q   BUTTON");
					
					declare LOGINS = ["ALL", LocalUser.Login];
					foreach (LOGIN in LOGINS)
					if (NetSrv_Handle.existskey(LOGIN) && NetSrv_Handle[LOGIN] != lastHandle[LOGIN])
					{
						lastHandle[LOGIN] = NetSrv_Handle[LOGIN];
						
						//declare isForMe = NetServ_Dest.exists(LOGIN) || NetServ_Dest.exists(LocalUser.Login);
						
						log("received!" ^ NetSrv_Message[LOGIN]);
						
						if (NetSrv_Message[LOGIN] == "GoRespawnScreen")
						{							
							Net_playerSpawn = -1;
							Net_playerLastTime = Now;
							Net_playerWantRespawn = False;
							
							if (InputPlayer.CurrentClan == 1)
							{
								JoinTeam1();
							}
							else
								JoinTeam2();
						}
						if (NetSrv_Message[LOGIN] == "SetPlayerClan" && InputPlayer != Null)
						{

						}
					}
					
					if (Now > refreshFrames)
					{
						refreshFrames = Now + 100;
						
						UpdateAvailableSpawns();
					}
					
					/*Minimap.Size = <75., 75.>;
					//Minimap.ZoomFactor = 1.;
					//Minimap.MapPosition = <1., 0.5>;
					Minimap.MapYaw = 0.;*/
					
					declare PosKitInfo = <0., -120., 10.>;
					
					foreach (frame in SpawnsFrame)
					{
						declare spawnIndex for frame = 0;
						declare quadSelected for frame = CMlQuad;
						
						if (CurrentSelectedSpawn != Null
							&& spawnIndex == MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn))
						{
							quadSelected.Colorize = <0., 1., 0.>;
							quadSelected.Opacity = 1.;
						}
						else
						{
							quadSelected.Colorize = <1., 1., 1.>;
							quadSelected.Opacity = 0.25;
						}
					}
										
					ManageGameView();
					
					foreach (frame in FrameClasses)
					{
						declare quadSelected for frame = CMlQuad;
						declare classLabel for frame = CMlLabel;
						declare originalKit for classLabel = "";
						declare counterLabel for frame = CMlLabel;
						
						if (originalKit == Net_playerWantedKit)
						{
							quadSelected.Colorize = <0., 1., 0.>;
							quadSelected.Opacity = 1.;
						}
						else
						{
							quadSelected.Colorize = <1., 1., 1.>;
							quadSelected.Opacity = 0.25;
						}
						
						declare counter = 0;
						declare ActivePlayer = CSmPlayer;
						if (InputPlayer != Null)
							ActivePlayer <=> InputPlayer;
						if (GUIPlayer != Null)
							ActivePlayer <=> GUIPlayer;
						
						foreach (player in Players)
						{
							if (player.CurrentClan == ActivePlayer.CurrentClan)
							{
								declare netread Net_playerMayChooseThisKit for player = "";
								if (Net_playerMayChooseThisKit == originalKit)
									counter += 1;
							}
						}
						
						if (classLabel.IsFocused)
						{
							PosKitInfo = <0., 0., 10.>;
								
							Label_DescriptionShoot.Value = GetDescShoot(originalKit);
							Label_DescriptionAction1.Value = GetDescAction1(originalKit);
							Label_DescriptionAction2.Value = GetDescAction2(originalKit);
							Label_DescriptionWarning.Value = GetDescWarning(originalKit);
							Label_DescClassName.Value = originalKit;
						}
						
						counterLabel.SetText("" ^ counter);
					}
					
					FrameKitInfo.RelativePosition = Lerp(FrameKitInfo.RelativePosition, PosKitInfo, TimeDelta * 8.5);
					
					/*if (CurrentSelectedSpawn != Null)
					{
						declare pos = CurrentSelectedSpawn.Position;
						
						Minimap.WorldPosition = Lerp(Minimap.WorldPosition, pos, TimeDelta / 0.25);
						Minimap.ZoomFactor = Lerp(Minimap.ZoomFactor, 5., TimeDelta / 0.25);
					}
					else
					{
						Minimap.WorldPosition = Lerp(Minimap.WorldPosition, <192., 0., 192.>, TimeDelta / 0.25);
						Minimap.ZoomFactor = Lerp(Minimap.ZoomFactor, 1., TimeDelta / 0.25);
					}*/
					
					if (Net_playerWantRespawn)
					{
						Net_playerLastTime = Now;
						Net_playerSpawn = MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn);
						
						QuadReady.BgColor = <0., 0.25, 0.>;
						if (QuadReady.IsFocused)
							QuadReady.BgColor = <0.1, 0.20, 0.>;
					}
					else
					{
						QuadReady.BgColor = <0.25, 0.1, 0.1>;
						if (QuadReady.IsFocused)
							QuadReady.BgColor = <0.20, 0.15, 0.>;
					}
					
					if (InputPlayer != Null && InputPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned)
					{
						CurrentSelectedState = -1;
					}
					
					foreach (event in PendingEvents)
					{
						if (event.Type == CMlScriptEvent::Type::KeyPress)
						{
							if (event.KeyName == "F6" && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned
									&& !IsSpectator)
							{
								Net_playerWantRespawn = !Net_playerWantRespawn;
								
									if (CurrentSelectedSpawn != Null) {
										Net_playerLastTime = Now;
										Net_playerSpawn = MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn);
									}								
							}
						}
						if (event.Type == CMlEvent::Type::MouseClick)
						{
							declare control <=> event.Control;
							if (control.ControlId == "selectSpawn")
							{
								declare parentFrame for control = CMlFrame;
								declare spawnIndex for parentFrame = 0;
								declare isAvailable for parentFrame = False;
								
								if (isAvailable)
								{
									CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[spawnIndex];
								}
							}
							if (control.ControlId == "resetView")
								CurrentSelectedSpawn = Null;
								
							if (control.ControlId == "setReady")
							{
								CurrentSelectedState = -1;
							
								Net_playerWantRespawn = !Net_playerWantRespawn;
								
								if (CurrentSelectedSpawn != Null)
								{
									Net_playerLastTime = Now;
									Net_playerSpawn = MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn);
								}
							}
							
							if (control.ControlId == "setSpawnSelection")
							{
								CurrentSelectedState = 0;
							}
							if (control.ControlId == "setClassSelection")
							{
								CurrentSelectedState = 1;
							}
							
							
							if (control.ControlId == "Label_SelectClass")
							{
								declare originalKit for control = "";
								Net_playerWantedKit = originalKit;
							}			
							
							if (control.ControlId == "Label_SelectSpawn")
							{
								declare parentFrame for control = CMlFrame;
								declare spawnIndex for parentFrame = 0;
								if (MapLandmarks_PlayerSpawn.existskey(spawnIndex))
									CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[spawnIndex];
							}			
						}
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Text layer_GetOvertime()
{
	declare CC = "halign='center' valign='center'";

	return """
	<manialink version="3">
		<frame pos="0 58" z-index="-10" id="Frame_Overtime">
			<label {{{CC}}} pos="0 6.25" text="$sâ³" scale="1.75"/>
			<label {{{CC}}} text="$sOVERTIME" textfont="Oswald"/>
			<label {{{CC}}} id="Label_OvertimeEndTime" pos="0 -5" textprefix="$s$f00" text="0" textfont="Oswald"/>
		</frame>
		
		<script><!--
			#Include "MathLib" as MathLib
		
			main()
			{
				declare frame <=> (Page.GetFirstChild("Frame_Overtime") as CMlFrame);
				declare Label_OvertimeEndTime <=> (Page.GetFirstChild("Label_OvertimeEndTime") as CMlLabel);
				declare netread Net_IsOvertime for Teams[0] = False;
				declare netread Net_OvertimeEndTime for Teams[0] = 0;
				
				while(True)
				{	
					yield;
					frame.Visible = Net_IsOvertime;
					
					Label_OvertimeEndTime.Value = MathLib::FloorInteger((Net_OvertimeEndTime - ArenaNow) / 1000.) ^ " SECONDS";
				}
			}
		--></script>
	</manialink>
	""";
}

Text GetScoreManialink()
{
	return """
	<quad pos="0 20" size="1.5 25" bgcolor="999" halign="center" valign="center" />
	<label pos="-10 20" text="0" textcolor="0dd" opacity="0.75" halign="right" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="-150 20" text="â„ Cryo" textcolor="0dd" opacity="0.75" halign="left" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="10 20" text="0" textcolor="e80" opacity="0.75" halign="left" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="150 20" text="ðŸ”¥ Meteor" textcolor="e80" opacity="0.75" halign="right" valign="center" textsize="17.5" textfont="OswaldMono" />
	""";
}

Text layer_GetGateMarkers()
{
	declare CC = "halign='center' valign='center'";
	declare Instances = "";
	for (i, 0, 15)
	{
		Instances ^= """<frameinstance id="GateMarkers_Instance_{{{i}}}" modelid="FrameModel_Marker" />""";
	}

	return """
	<manialink version="3">
		<framemodel id="FrameModel_Marker" scale="0.75">
			<label {{{CC}}} id="Label_Name" pos="0 4" textprefix="$s$n" text="Gate" textsize="3" textfont="Oswald" />
			<label {{{CC}}} id="Label_Icon" pos="0 0" textprefix="$s$n" text="â·" textsize="4" />
		</framemodel>
		
		{{{Instances}}}
		
		<script><!--
			main()
			{
				declare ClientMarkers for LocalUser = Text[Text];
				declare netread Net_CurrentOrder for Teams[0] = 0; 
				declare netread Net_IsFinalGoal for Teams[0] = False;
				
				declare ValidatedMarkers for LocalUser = Boolean[Text];
				
				declare CMlFrame[] Instances;
				for (i, 0, 15)
				{
					declare frame <=> (Page.GetFirstChild("GateMarkers_Instance_" ^ i) as CMlFrame);
					declare label_Name for frame <=> (frame.GetFirstChild("Label_Name") as CMlLabel);
					declare label_Icon for frame <=> (frame.GetFirstChild("Label_Icon") as CMlLabel);
					
					Instances.add(frame);
				}
				
				while(True)
				{
					yield;
					
					ClientMarkers["gatemarker"] = "";
					
					foreach (frame in Instances)
					{
						declare tempIsVisible for frame = False;
						tempIsVisible = False;
					}
				
					declare i = 0;
					foreach (gate in MapLandmarks_Gate)
					{
						if (gate.Order + 0 == Net_CurrentOrder || (Net_IsFinalGoal && gate.Order + 1 == Net_CurrentOrder))
						{
							declare Pos = gate.Position;
							Pos.Y += 6.;
						
							ClientMarkers["gatemarker"] ^= "<marker pos='" ^ Pos.X ^ " " ^ Pos.Y ^ " " ^ Pos.Z ^ "' manialinkframeid='GateMarkers_Instance_" ^ i ^ "' />";
							
							declare metadata LandmarkCustomName for gate = "";
							declare frame <=> Instances[i];
							declare label_Name for frame = CMlLabel;
							declare label_Icon for frame = CMlLabel;
							
							label_Name.Value = "$fff";
							if (Net_IsFinalGoal)
								label_Name.Value = "$2d2";
							
							if (!Net_IsFinalGoal)
							{
								if (LandmarkCustomName != "")
									label_Name.Value ^= LandmarkCustomName;
								else
									label_Name.Value ^= "Gate";
							}
							else
								label_Name.Value ^= "Access to goal";
								
							label_Icon.Value = "$fffâ·";
							if (Net_IsFinalGoal)
								label_Icon.Value = "$2d2â·";
							
							declare tempIsVisible for frame = False;
							tempIsVisible = True;
						} 
					}
					
					foreach (frame in Instances)
					{
						declare tempIsVisible for frame = False;
						frame.Visible = tempIsVisible;
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Text layer_GetGoalMarkers()
{
	declare CC = "halign='center' valign='center'";

	return """
	<manialink version="3">
		<frame id="Frame_GoalMarker" scale="0.75">
			<label {{{CC}}} pos="0 4.5" textprefix="$s$n" text="$0f0GOAL" textfont="Oswald" size="100 10"/>
			<label {{{CC}}} pos="0 0" textprefix="$s" text="$0f0â·" textsize="4" />
		</frame>
		
<script><!--
			main()
			{
				declare ClientMarkers for LocalUser = Text[Text];
				declare netread Net_IsFinalGoal for Teams[0] = False; 
				
				declare ValidatedMarkers for LocalUser = Boolean[Text];
				
				declare Instance <=> (Page.GetFirstChild("Frame_GoalMarker") as CMlFrame);
				
				while(True)
				{
					yield;
					
					Instance.Visible = Net_IsFinalGoal;
					
					ClientMarkers["goalmarker"] = "";
					foreach (goal in MapLandmarks)
					{
						if (goal.Tag == "Goal" && Instance.Visible)
						{
							declare Pos = goal.Position;
							Pos.Y += 26.;
						
							ClientMarkers["goalmarker"] ^= "<marker pos='" ^ Pos.X ^ " " ^ Pos.Y ^ " " ^ Pos.Z ^ "' manialinkframeid='Frame_GoalMarker' />";
						} 
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Void SendSrvMessage(Text PlayerLogin, Text MessageType)
{
	declare netwrite NetSrv_Handle for Teams[0] = ["" => -1];
	declare netwrite NetSrv_Message for Teams[0] = ["" => ""];
	if (!NetSrv_Handle.existskey(PlayerLogin))
		NetSrv_Handle[PlayerLogin] = 1;
	if (!NetSrv_Message.existskey(PlayerLogin))
		NetSrv_Message[PlayerLogin] = MessageType;
		
	NetSrv_Handle[PlayerLogin] += 1;
	NetSrv_Message[PlayerLogin] = MessageType;
	
}

Void AddLandmark(CNod nod, CSmMapLandmark originalLandmark)
{
	if (nod is CSmMapPlayerSpawn)
	{
		declare spawn <=> cast(CSmMapPlayerSpawn, nod);
		
		if (!PlayerSpawns.existskey(originalLandmark.Tag))
		{
			PlayerSpawns[originalLandmark.Tag] = CSmMapLandmark[][Integer];
		}
		if (!PlayerSpawns[originalLandmark.Tag].existskey(originalLandmark.Order))
		{
			PlayerSpawns[originalLandmark.Tag][originalLandmark.Order] = CSmMapLandmark[];
		}

		PlayerSpawns[originalLandmark.Tag][originalLandmark.Order].add(originalLandmark);
	}
	if (nod is CSmMapGauge)
	{
		declare gauge <=> cast(CSmMapGauge, nod);
		declare isGoal = originalLandmark.Tag == "Goal";
		declare isGate = originalLandmark.Tag == "Gate";
		
		if (isGoal)
			Goals[originalLandmark.Order] <=> originalLandmark;
		else if (!isGate)
		{
			if (!Checkpoints.existskey(originalLandmark.Order))
			{
				Checkpoints[originalLandmark.Order] = [Null];
				Checkpoints[originalLandmark.Order].clear();
			}
			
			Checkpoints[originalLandmark.Order].add(originalLandmark);
		}
		else
		{
			if (!Gates.existskey(originalLandmark.Order))
			{
				Gates[originalLandmark.Order] = [Null];
				Gates[originalLandmark.Order].clear();
			}
			
			Gates[originalLandmark.Order].add(originalLandmark);
		}
	}
}

Void RefreshCheckpointsInterfaceVariables()
{
	if (Checkpoints.existskey(CurrentOrder) && !get_IsFinalGoal)
	{
		StormiumIT::SetGoalCount(Checkpoints[CurrentOrder].count);
		foreach (i => checkpoint in Checkpoints[CurrentOrder])
		{
			StormiumIT::SetGoalColorDef(i, Teams[checkpoint.Base.Clan - 1].ColorPrimary);
			StormiumIT::SetGoalColorAtk(i, Teams[checkpoint.Gauge.Clan - 1].ColorPrimary);
			StormiumIT::SetGoalValue(i, checkpoint.Gauge.ValueReal);
			
			declare metadata LandmarkCustomName for checkpoint = "";
			declare Pos = checkpoint.Position;
			Pos.Y += 3.;
			
			StormiumIT::SetGoalName(i, LandmarkCustomName);
			StormiumIT::SetGoalPosition(i, Pos);
		}
	}
	else
	{
		StormiumIT::SetGoalCount(0);
	}
}


Void UpdateColors()
{
	if (CurrentGameState == EGameState_Starting)
	{
		foreach (clanName => order in PlayerSpawns)
		{
			declare clanInt = 0;
			if (clanName == "SpawnAttack")
				clanInt = AttackingClan;
			else
				clanInt = 3 - AttackingClan;
			foreach (spawns in order)
			{				
				foreach (spawn in spawns)
				{
					declare spawnClan for spawn = 0;
					spawnClan = clanInt;
				
					declare base <=> spawn.Base;
					if (base != Null)
					{
						base.IsActive = True;
						base.Clan = spawnClan;
					}
				}
			}
		}
		
		
		foreach (goal in Goals)
		{
			declare base <=> goal.Base;
			if (base != Null)
			{
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
			}
				
			declare gauge <=> goal.Gauge;
			gauge.Value = 750;
			gauge.Max = 750;
			gauge.Clan = 3 - AttackingClan;	
			gauge.Captured = True;		
			gauge.Speed = 0;
		}
		
		foreach (clanOrder => order in Checkpoints)
		{
			foreach (checkpoint in order)
			{
				declare base <=> checkpoint.Base;
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
				
				declare gauge <=> checkpoint.Gauge;
				gauge.Value = 0;
				gauge.Max = S_TimeToCaptureCheckpoint * 1000;
				gauge.Clan = AttackingClan;
			}
		}
		
		foreach (clanOrder => order in Gates)
		{
			foreach (gate in order)
			{
				declare _gate <=> gate.Gate;
				_gate.Automatic = False;
				_gate.ManualClosed = True;
				_gate.Clan = 0;
		
				declare gauge <=> gate.Gauge;
				gauge.Value = 10000;
				gauge.Max = 10000;
				gauge.Captured = False;
				gauge.Clan = 3 - AttackingClan;
				gauge.Speed = 0;
			}
		}
	}
	
	if (CurrentGameState == EGameState_InPlay)
	{
		foreach (clanName => order in PlayerSpawns)
		{
			declare clanInt = 1;
			if (clanName == "SpawnAttack")
				clanInt = AttackingClan;
			else
			{
				clanInt = 3 - AttackingClan;
			}
		
			foreach (spawns in order)
			foreach (spawn in spawns)
			{
				declare spawnClan for spawn = 0;
				spawnClan = clanInt;
				if (spawn.Order <= CurrentOrder - 1
					&& spawn.Tag != "SpawnGoal")
					spawnClan = AttackingClan;
				
				declare base <=> spawn.Base;
				if (base != Null)
				{
					base.IsActive = True;
					base.Clan = spawnClan;
					
					if (spawn.Order <= CurrentOrder)
						base.Clan = spawnClan;
					else
					{
						spawnClan = 0;
						base.Clan = 0;
					}
				}
			}
		}
		
		foreach (clanOrder => order in Checkpoints)
		{
			foreach (checkpoint in order)
			{
				declare base <=> checkpoint.Base;
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
				
				if (checkpoint.Order <= CurrentOrder - 1)
					base.Clan = AttackingClan;

			}
		}
		
		foreach (clanOrder => order in Gates)
		{	
			foreach (gate in order)
			{
					declare _gate <=> gate.Gate;
					_gate.Automatic = False;
					_gate.ManualClosed = True;
					
					/*if (CurrentOrder < clanOrder + 1)
						_gate.Clan = 3 - AttackingClan;
					else
						_gate.Clan = AttackingClan;*/
					_gate.Clan = 0;
		
					declare gauge <=> gate.Gauge;
					gauge.Value = S_RushTimeGateDuration + 1;
					gauge.Max = S_RushTimeGateDuration + 1;
					gauge.Captured = gauge.Value != gauge.Max;
					
					if (gate.Order < CurrentOrder
						&& gate.Order + 2 < RangeCaptured.count)
					{
						gauge.Value = 0;
						gauge.Max = 0;
						gauge.Captured = False;
						_gate.Automatic = False;
						_gate.ManualClosed = False;
					} 
					
					if (CurrentOrder < clanOrder + 1)
						gauge.Clan = 3 - AttackingClan;
					else
						gauge.Clan = AttackingClan;
			}	
		}
	}
	
	declare netwrite Net_SpawnClan for Teams[0] = Integer[Integer];
	foreach (I => spawn in MapLandmarks_PlayerSpawn)
	{
	
		declare spawnClan for spawn = 0;
		Net_SpawnClan[I] = spawnClan;
	}
}

// ------------------------------
// BALANCE STUFF
// ------------------------------

/*
 * Somme des ranks de la liste d'id joueurs
 *
 * @params : identsClan : Liste d'id joueurs
 */
Integer RankClan(Ident[] identsClan) {
	declare sumRank = 0;
	foreach (id in identsClan)
		if(Users[id].LadderRank >= 0)
			sumRank += Users[id].LadderRank;
	
	return sumRank;
}

/*
 * Somme des scores de la liste d'id joueurs
 *
 * @params : identsClan : Liste d'id joueurs
 */
Integer ScoreClan(Ident[] identsClan) {
	declare sumScore = 0;
	foreach (id in identsClan)
		foreach (player in AllPlayers)
			if (player.User.Id == id)
				if (AutoServerStartVoteBalance) {
					declare oldScoreMap for player = 0;
					sumScore += oldScoreMap;
				} else {
					sumScore += player.Score.Points + player.Score.RoundPoints;
				}
	
	return sumScore;
}

Ident[] CpyList(Ident[] list) {
	declare Ident[] sort;
	foreach (val in list)
		sort.add(val);
	
	return sort;
}

declare Ident[] playersClan1;
declare Ident[] playersClan2;

/*
 * Version 2, algo d'Ã©quilibrage des Ã©quipes (par rapport aux rank)
 * NÃ©cessite les joueurs triÃ©s de faÃ§on dÃ©croissantes (rank)
 *
 * @params : 
 * @return : Boolean, True si interversion d'un joueur utile, False sinon.
 */
Boolean BalanceSearchRanks(Ident[] identsPlayers, Integer deltaRankInit, Integer keyPlayerStart) {
	if ((keyPlayerStart % 10) == 0) yield;
	
	//sleep(100);		// Debug
	if (keyPlayerStart < identsPlayers.count) {
		//UIManager.UIAll.SendChat("accÃ¨s : "^identsPlayers[keyPlayerStart]^" : "^keyPlayerStart);	// Debug
		
		declare id = identsPlayers[keyPlayerStart];
		declare tmpClan1 = CpyList(playersClan1);
		declare tmpClan2 = CpyList(playersClan2);
		
		if (playersClan1.exists(id)) {
			tmpClan1.remove(id);
			tmpClan2.add(id);
		} else {
			tmpClan2.remove(id);
			tmpClan1.add(id);
		}
		
		declare Integer rankFound = MathLib::Abs(RankClan(tmpClan1) - RankClan(tmpClan2));

		if (rankFound < deltaRankInit) {
			playersClan1 = tmpClan1;
			playersClan2 = tmpClan2;
		}
		
		return rankFound < deltaRankInit || BalanceSearchRanks(identsPlayers, rankFound, keyPlayerStart+1);
	}
	
	return False;
}

Boolean BalanceSearchScores(Ident[] identsPlayers, Integer deltaScoreInit, Integer keyPlayerStart) {
	if ((keyPlayerStart % 10) == 0) yield;
	
	//sleep(100);		// Debug
	if (keyPlayerStart < identsPlayers.count) {
		//UIManager.UIAll.SendChat("accÃ¨s : "^identsPlayers[keyPlayerStart]^" : "^keyPlayerStart);	// Debug
		
		declare id = identsPlayers[keyPlayerStart];
		declare tmpClan1 = CpyList(playersClan1);
		declare tmpClan2 = CpyList(playersClan2);
		
		if (playersClan1.exists(id)) {
			tmpClan1.remove(id);
			tmpClan2.add(id);
		} else {
			tmpClan2.remove(id);
			tmpClan1.add(id);
		}
		
		declare Integer scoreFound = MathLib::Abs(ScoreClan(tmpClan1) - ScoreClan(tmpClan2));

		if (scoreFound < deltaScoreInit) {
			playersClan1 = tmpClan1;
			playersClan2 = tmpClan2;
		}
		
		return scoreFound < deltaScoreInit || BalanceSearchScores(identsPlayers, scoreFound, keyPlayerStart+1);
	}
	
	return False;
}

Boolean BalanceSearch(Integer[Ident] idPlayersWithRankOrScore, Integer balanceType) {
	declare tmp = idPlayersWithRankOrScore.sort();

	declare Ident[] identsPlayers;
	foreach (key => val in tmp) {
		identsPlayers.add(key);
	}
	
	declare Ident[] idPlayersDesc;
	for(i, 0, identsPlayers.count-1) {
		declare j = identsPlayers.count-1 - i;
		idPlayersDesc.add(identsPlayers[j]);
	}
	
	if (balanceType == 1) return BalanceSearchRanks(idPlayersDesc, MathLib::Abs(RankClan(playersClan1) - RankClan(playersClan2)), 0);
	return BalanceSearchScores(idPlayersDesc, MathLib::Abs(ScoreClan(playersClan1) - ScoreClan(playersClan2)), 0);
}

/*
 * Version 1, algo d'Ã©quilibrage des Ã©quipes (par rapport aux rank)
 * (rapide jusqu'Ã  4vs4, puis 10s Ã  5vs5, le double Ã  6vs6 etc.)
 *
 * @params : 
 * @return : Boolean, True si interversion d'un joueur utile, False sinon.
 */
/*Boolean BalanceSearch(Ident[] identsPlayers, *//*Ident[] playersClan1, Ident[] playersClan2,*//* Integer keyPlayerStart) {
	if ((keyPlayerStart % 10) == 0) yield;
	declare Integer rankFound;
	declare Integer deltaRankInit;
	//sleep(100);		// Debug
	if (keyPlayerStart < identsPlayers.count) {
		UIManager.UIAll.SendChat("accÃ¨s :"^keyPlayerStart);		// Debug
	
		deltaRankInit = MathLib::Abs(RankClan(playersClan1) - RankClan(playersClan2));
		rankFound = deltaRankInit;
		
		declare id = identsPlayers[keyPlayerStart];
		declare clan1Init = playersClan1;
		declare clan2Init = playersClan2;
		declare tmpClan1 = CpyList(playersClan1);
		declare tmpClan2 = CpyList(playersClan2);
		
		if (BalanceSearch(identsPlayers, keyPlayerStart+1))
				rankFound = MathLib::Abs(RankClan(playersClan1) - RankClan(playersClan2));
		
		if (playersClan1.exists(id)) {
			tmpClan1.remove(id);
			tmpClan2.add(id);
		} else {
			tmpClan2.remove(id);
			tmpClan1.add(id);
		}
		
		playersClan1 = tmpClan1;
		playersClan2 = tmpClan2;
		
		if (!BalanceSearch(identsPlayers, keyPlayerStart+1)
				&& MathLib::Abs(RankClan(playersClan1) - RankClan(playersClan2)) > rankFound){
			playersClan1 = clan1Init;
			playersClan2 = clan2Init;
		}
	}
	
	return rankFound < deltaRankInit;
}*/


/*
 * Ã‰quilibrage des Ã©quipes
 *
 * @params : balanceType : 1 ranks, 2 scores
 */
Void BalanceTeams(Integer balanceType) {
	declare Integer[Ident] idPlayers;
	playersClan1.clear();
	playersClan2.clear();
	
	foreach (player in Players) {
		if (balanceType == 1) {
			if (player.User.LadderRank < 0) idPlayers[player.User.Id] = 0;
			else idPlayers[player.User.Id] = player.User.LadderRank;
		} else {
			if (AutoServerStartVoteBalance) {
				declare oldScoreMap for player = 0;
				idPlayers[player.User.Id] = oldScoreMap;
			} else {
				idPlayers[player.User.Id] = player.Score.Points + player.Score.RoundPoints;
			}
		}
		
		declare Integer PlayerClan for player;
		if (PlayerClan == 1)
			playersClan1.add(player.User.Id);
		else
			playersClan2.add(player.User.Id);
	}
	
	BalanceSearch(idPlayers, balanceType);
	if (balanceType == 1)
		UIManager.UIAll.SendChat("Teams are now balanced in term of ranks.");
	else
		UIManager.UIAll.SendChat("Teams are now balanced in term of scores.");
	
	foreach (player in Players) {	
		declare oldPlayerClan = player.CurrentClan;
		declare Integer PlayerClan for player;
		
		if(playersClan1.exists(player.User.Id))
			PlayerClan = 1;
		else if (playersClan2.exists(player.User.Id))
			PlayerClan = 2;
		
		if (oldPlayerClan != PlayerClan) {
			UnspawnPlayer(player);
			declare TempoPlayerRequestedClan for player = 0;
			TempoPlayerRequestedClan = Now+10000;
			declare UI <=> UIManager.GetUI(player);
			if (UI != Null) {
				UI.SendChat("$999Team notice: $fffYou was redirected to " ^ Teams[PlayerClan - 1].ColorizedName ^ " team"); 
			}
		}
	}
	
	//LastTimeBalance = Now;
}

/*
 * Ã‰quilibrage d'un nouveau joueur
 * valable pour un nouvel arrivant ou une bascule spectateur -> joueur
 *
 * @params : Player : Joueur concernÃ©
 */
Integer dispatchNewOrSpectPlayerClan(CSmPlayer Player) {
	declare Ident[] playersClan1;
	declare Ident[] playersClan2;
	foreach (player in Players) {
		declare Integer PlayerClan for player;
		if (player.User.Id != Player.User.Id) {
			if (PlayerClan == 1)
				playersClan1.add(player.User.Id);
			else
				playersClan2.add(player.User.Id);
		}
	}
	
	// check si tout est bien Ã©quillibrÃ© niveau nombre joueur
	/*declare diffTeams = MathLib::Abs(GetNbPlayers(1) - GetNbPlayers(2));
	if (diffTeams > 0)
	{
		if (GetNbPlayers(1) > GetNbPlayers(2))
			return 2;
		else
			return 1;
	}*/

	declare playerScore = Player.Score.Points + Player.Score.RoundPoints;
	if (playerScore > 0) {
		// Ã‰quilibrage par score (probable passage de spectateur Ã  joueur)
		if (MathLib::Abs((ScoreClan(playersClan1)+playerScore) - ScoreClan(playersClan2))
				<= MathLib::Abs(ScoreClan(playersClan1) - (ScoreClan(playersClan2)+playerScore)))
			return 1;
		return 2;			
	}

	// Ã‰quilibrage par rank (probable nouvelle connexion)
	declare playerRank = Player.User.LadderRank;
	if (MathLib::Abs((RankClan(playersClan1)+playerRank) - RankClan(playersClan2))
			<= MathLib::Abs(RankClan(playersClan1) - (RankClan(playersClan2)+playerRank)))
		return 1;
	return 2;
}

Boolean isBalanced(CSmPlayer player, Integer teamRequest)
{
	declare team = dispatchNewOrSpectPlayerClan(player);
	if (team == teamRequest)
		return True;
	return False;
}

/*
 * Lance/actualise le vote pour l'Ã©quilibrage des Ã©quipes
 * Si AutoServerStartVoteBalance : vote automatique lancÃ© par le serveur
 */
Void RefreshVoteBalance() {
	if (VoteBalanceResult.count != 3) {	// Lancement du serveur
		BalancingIsRequired = False;
		VoteBalanceResult = [Text[],Text[],Text[]];
	}

	if (AutoServerStartVoteBalance && !BalancingIsRequired) {
		BalancingIsRequired = True;
		VoteBalanceResult[0].clear();	// Yes option
		VoteBalanceResult[1].clear();	// No option
		VoteBalanceResult[2].clear();	// Other option
		// BalanceType = 2; // MÃªme type que le vote prÃ©cÃ©dent
		PlayerNameRequestVoting = "AgE server";
		VoteBalanceResult[0].add(PlayerNameRequestVoting);
		TimeStartVote = Now;
	}
	
	foreach (player in AllPlayers) {	// Spectateur inclus
		declare UI <=> UIManager.GetUI(player);		
		if (UI != Null) {
			declare netread Net_CallForBalance for UI = 0;
			declare _lastCallForBalance for UI = 0;
			
			if (_lastCallForBalance != Net_CallForBalance) {
				
				if (!BalancingIsRequired && (Net_CallForBalance - _lastCallForBalance) != 0) {
					BalancingIsRequired = True;
					VoteBalanceResult[0].clear();	// Yes option
					VoteBalanceResult[1].clear();	// No option
					VoteBalanceResult[2].clear();	// Other option
					BalanceType = Net_CallForBalance - _lastCallForBalance;	// 1:Ranks, 2:Scores
					PlayerNameRequestVoting = player.User.Name;
					TimeStartVote = Now;
					
					VoteBalanceResult[0].add(player.User.Login);
				}
				_lastCallForBalance = Net_CallForBalance;
			}
			
			declare netread Net_PlayerVote for UI = 0;	// /!\ option+1
			declare _PlayerVote for UI = 0;
			if (_PlayerVote != Net_PlayerVote) {
				declare Integer playerVote;
				playerVote = (Net_PlayerVote - _PlayerVote) - 1;
				//UIManager.UIAll.SendChat("playervote"^playerVote^" player : "^player.User.Login);
				if (!VoteBalanceResult[playerVote].exists(player.User.Login)) {
					foreach (key => elem in VoteBalanceResult) {	// UtilitÃ© plus que limitÃ© // fuck maniascript
						if (key == playerVote) {
							VoteBalanceResult[key].add(player.User.Login);
							//elem.add(player.User.Login);			// fuck maniascript
						} else if (elem.exists(player.User.Login)) {
							//elem.remove(player.User.Login);	// fuck maniascript
							VoteBalanceResult[key].remove(player.User.Login);
						}
					}
				}
				_PlayerVote = Net_PlayerVote;
			}
		}					
	}

	if (BalancingIsRequired /*&& TimeStartVote + S_TimeToVoteBalance < Now*/) {	// End vote
		declare Real nbVotant = 0.;
		foreach (option in VoteBalanceResult) nbVotant += option.count;
		declare AllplayersNoBotCount = 0;
		foreach (player in AllPlayers) if (!player.IsBot && !player.IsFakePlayer) AllplayersNoBotCount +=1;
		
		if (TimeStartVote + S_TimeToVoteBalance < Now
			 || (AutoServerStartVoteBalance && nbVotant - 1 == AllplayersNoBotCount)
			 || (!AutoServerStartVoteBalance && nbVotant == AllplayersNoBotCount)) {
			
			BalancingIsRequired = False;
			/*UIManager.UIAll.SendChat("Le vote est passÃ©");
			UIManager.UIAll.SendChat("Yes "^VoteBalanceResult[0].count);
			UIManager.UIAll.SendChat("No "^VoteBalanceResult[1].count);
			UIManager.UIAll.SendChat("Other "^VoteBalanceResult[2].count);*/
		
			if (nbVotant > 0) {	// Dans le cas oÃ¹ le serveur n'aurait pas de voix
				declare Real[] tmpRatio;
				foreach (option in VoteBalanceResult)
					tmpRatio.add(option.count / nbVotant);

				if (tmpRatio[0] >= tmpRatio[2] && tmpRatio[0]+tmpRatio[2] >= S_RatioToValideVoteBalance) {
					// vote equilibrage par option defaut
					UIManager.UIAll.SendChat("The vote was accepted");
					if (BalanceType == 1) {
						//UIManager.UIAll.SendChat("Ã‰quilibrage par ranks");
						BalanceTeams(1);
					} else {
						//UIManager.UIAll.SendChat("Ã‰quilibrage par scores");
						BalanceTeams(2);
					}
				} else if (tmpRatio[2] > tmpRatio[0] && tmpRatio[0]+tmpRatio[2] >= S_RatioToValideVoteBalance) {
					// vote equilibrage par option "inverse"/Other
					UIManager.UIAll.SendChat("The vote was accepted with the other balancing option");
					if (BalanceType == 1) {
						//UIManager.UIAll.SendChat("Ã‰quilibrage par scores");
						BalanceTeams(2);
					} else {
						//UIManager.UIAll.SendChat("Ã‰quilibrage par ranks");
						BalanceTeams(1);
					}
				} else {
					//log("Ã‰quilibrage refusÃ©");
					UIManager.UIAll.SendChat("The vote was canceled");
				}
			}
			AutoServerStartVoteBalance = False;
		}
	}
	
	declare netwrite Net_BalancingIsRequired for Teams[0] = BalancingIsRequired;
	Net_BalancingIsRequired = BalancingIsRequired;
	
	if (BalancingIsRequired) {
		declare netwrite Net_PlayerNameRequestVoting for Teams[0] = PlayerNameRequestVoting;
		Net_PlayerNameRequestVoting = PlayerNameRequestVoting;
	
		declare netwrite Net_BalanceType for Teams[0] = BalanceType;
		Net_BalanceType = BalanceType;
	
		declare netwrite Net_VoteBalanceResult2 for Teams[0] = VoteBalanceResult;
		Net_VoteBalanceResult2 = VoteBalanceResult;
		
		declare netwrite Net_CountdownVoteBalance for Teams[0] = Text;
		Net_CountdownVoteBalance = TextLib::ToText(MathLib::FloorInteger(((TimeStartVote + S_TimeToVoteBalance) - Now)/1000.));
	}
}

Void BalanceStart()
{
	if (!BalancingIsRequired && MapWinner != 0)
		if (MapMinTime + StartPrevMapTime > Now) {
			AutoServerStartVoteBalance = True;
			RefreshVoteBalance();
			log("Temps minimum non dÃ©passÃ©, partie trop courte : "^(StartPrevMapTime + MapMinTime)/1000^"s, Now: "^Now/1000^"s");
		} else {
			log("Temps minimum dÃ©passÃ©, partie ok : "^(StartPrevMapTime + MapMinTime)/1000^"s, Now: "^Now/1000^"s");
		}
	
	declare nbChecksOnMap = 1; // 1 pour le pole de rush, permet d'Ã©quilibrer le calcul (dÃ©placement du joueur sur la map non comptÃ©...)
	foreach (checksRound in Checkpoints) nbChecksOnMap += checksRound.count;
	
	declare serverTimes = S_TimeSelectionTime * 1000 + S_RushTimeGateDuration + 100000;	// ~100000 somme des temporisations de parties
	MapMinTime = S_TimeToCaptureCheckpoint * nbChecksOnMap * S_CoeffTimeLimitCaptureCheckpointAutoTeamBalanceVote * 1000;
	if (!IsRangedMap) MapMinTime += S_EndTime * 60000;
	else MapMinTime -= 20000;
	MapMinTime += serverTimes;
	log("Temps mapMinTime : "^MapMinTime/1000^"s");
	
	StartPrevMapTime = Now;
}

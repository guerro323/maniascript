

/*
 *	Mode melee
 */

#Extends "Modes/ShootMania/Base/ModeShootmania.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/MiniMap2.Script.txt" as MiniMap
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Stormium/SpawnScreen.Script.txt" as StormiumSS
#Include "Libs/Stormium/Interface.Script.txt" as StormiumIT
#Include "Libs/Nadeo/ScoresTable2.Script.txt" as ST2
#Include "Libs/Stormium/Kits.Script.txt" as Kits

#Const	CompatibleMapTypes	"TeamDeathmatchArena, AgeArena"
#Const	Version				"2014-07-25"
#Const	ScriptName			"Melee.Script.txt"

#Const m_MiniMapSize <60., 60.>
#Const m_MiniMapPos <92., 0., 0.>

#Const EGameState_Starting 	0
#Const EGameState_InPlay 	1

#Setting S_TimeToCaptureCheckpoint 60 as _("Time to capture a checkpoint (s)")
#Setting S_MultiPlayerFasterCap True as _("Allow faster capture")
#Setting S_EndTime				5	as _("Time to finish a round (minute)")
#Setting S_RushTime				60	as _("Time to rush the goal (s)")
#Setting S_GainTimePerNewRange 	30 as _("Gain time per new range")
#Setting S_GainTimeOnCapture			20 as _("Gain time per capture")
#Setting S_RushTimeGateDuration	15000 as _("Waiting time to wait for gates to open")
#Setting S_TimeSelectionTime			15 as _("Time to wait before match start")
#Setting S_RequiredPlayers				2
#Setting S_MaxRounds 4
#Setting S_BotBlue	0
#Setting S_BotRed		0

/// <summary>
/// Current Attacking clan.
/// </summary>
/// <remarks>The color are still Blue for atk, and Red for def</remarks>
declare Integer AttackingClan;
/// <summary>
/// Spawns for all players.
/// usage: *[Team][Order]
/// </summary>
declare CSmMapLandmark[][Integer][Text] PlayerSpawns;
declare CSmMapLandmark[Integer] Goals;
declare CSmMapLandmark[][Integer] Gates;
declare CSmMapLandmark[][Integer] Checkpoints;
declare CSmObject[] MapCannons;
declare Integer CurrentGameState;
declare Integer CurrentOrder;
declare Boolean[Integer] RangeCaptured;
declare Boolean get_IsFinalGoal;
declare CSmMapLandmark lastGate;
declare Integer RoundWinner;
declare Integer LastRoundWinner;
declare Integer MapWinner;
declare Boolean IsOvertime;
declare Boolean IsRangedMap;
declare Integer MatchStartTime;
declare Integer OvertimeEndTime;
declare Integer[Integer] RangedProgression;
declare Integer LastTimeBalance;

***Match_StartServer***
***
	AttackingClan = MathLib::Rand(1, 2);
	
	Layers::Create("CGame.SpawnInterface", layer_GetSpawnInterface());
	Layers::Create("CGame.GateMarkers", layer_GetGateMarkers());
	Layers::Create("CGame.GoalMarkers", layer_GetGoalMarkers());
	Layers::Create("CGame.Overtime", layer_GetOvertime());
	
	Layers::SetType("CGame.GateMarkers", CUILayer::EUILayerType::Markers);
	Layers::SetType("CGame.GoalMarkers", CUILayer::EUILayerType::Markers);
	
	ST2::Load();
	ST2::SetStyle("LibST_SMBaseTeams");
	ST2::SetStyle("LibST_SMBasePoints");
	ST2::Build("SM");
	
	UseMinimap = True;
	ForceNavMapsComputation = True;
	UseClans = True;
	
	declare netwrite NetSrv_Handle for Teams[0] = ["" => -1];
	declare netwrite NetSrv_Message for Teams[0] = ["" => ""];
	
	UIManager.UIAll.NoticesFilter_HideMapInfo = True;
	UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
	
	StormiumSS::SetName("AgE");
	StormiumSS::SetGoal("""Attackers must capture the 2 Checkpoints (STORMIUM Containers) UNDER 5 MINUTES.
If they succed, they win 1 points. If they don't, Defenders win 1 point.
If they succed they will have to rush to the goal UNDER 30 SECONDS to get a SECOND POINT.
The team with a number of 6 points win.""");
	StormiumSS::SetDescription("""‚ñ∫ In attack or defense, you can choose among 5 kits ! 
You have a main weapon + other weapons/actions.

‚ñ∫ In each game, 2 players are selected randomly to be the $0dd‚ùÑKing of Cryo$fff (in Attackers team),
and the $e80üî• King of Meteor$fff (in Defenders team).
They have a great power thanks to STORMIUM ! 
They have 300HP and mass destruction weapons !""");
	StormiumSS::SetScoreManialink(GetScoreManialink());
	StormiumIT::Load(StormiumIT::C_ModeAgE);
	StormiumIT::ShowCustomCoutdown(True);
	StormiumIT::ShowCustomScores(True);
	StormiumIT::ShowCustomMarkers(True);
	StormiumIT::SetActive(True);
	
	UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
***

***MB_Private_Settings***
***
	MB_Settings_UseDefaultTimer = False;
	MB_Settings_UseDefaultClansScoresUI = False;
	MB_Settings_UseDefaultSpawnScreen = False;
	MB_Settings_UseDefaultPodiumSequence = False;
	MB_Settings_UseDefaultHud = False;
***

***Match_StartMap***
***
	Message::CleanAllMessages();
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";

	ST2::ClearScores();
	ClearScores();
	
	RangedProgression[1] = 0;
	RangedProgression[2] = 0;
	
	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;
	
	LastRoundWinner = 0;

	PlayerSpawns = CSmMapLandmark[][Integer][Text];
	Goals = CSmMapLandmark[Integer];
	Gates = CSmMapLandmark[][Integer];
	Checkpoints = CSmMapLandmark[][Integer];

	UIManager.UIAll.MarkersXML = "";
	foreach (mlm in MapLandmarks)
	{
		if (mlm.PlayerSpawn != Null)
			AddLandmark(mlm.PlayerSpawn, mlm);
		if (mlm.Gauge != Null)
			AddLandmark(mlm.Gauge, mlm);
	}
	
	IsRangedMap = Checkpoints.count > 1;
		
	lastGate = CSmMapLandmark;
	declare lastOrder = 0;
	foreach (gate in MapLandmarks_Gauge)
	{
		if (gate.Tag == "Gate" && gate.Order > lastOrder)
		{
			lastOrder = gate.Order;
			lastGate <=> gate;
		}
	}

	
	CurrentGameState = EGameState_Starting;
	
	UpdateColors();
	
	Layers::Update("CGame.SpawnInterface", layer_GetSpawnInterface());
	
	StartTime = Now;
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	BalanceTeams();
	
	Message::SetDefaultStatusMessage("");
	
	CurrentGameState = EGameState_InPlay;
	
	UpdateColors();
	StormiumSS::Reload();
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	
	RefreshCheckpointsInterfaceVariables();
	
	UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	
	if (IsRangedMap)
	{
		UIManager.UIAll.BigMessage = "Multiple gates ranges warning!";
		UIManager.UIAll.StatusMessage = "The first team who win the attack wins the map!";
		
		MB_Sleep(5000);
	}
***

***Match_StartRound***
***
	if (MathLib::Abs(GetNbPlayers(1) - GetNbPlayers(2)) > 1)
	{
		BalanceTeams();
	}

	UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never ;
	UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never ;

	OvertimeEndTime = -1;

	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;

	declare netwrite Net_IsFinalGoal for Teams[0] = False;
	Net_IsFinalGoal = False;
	
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	Message::SetDefaultStatusMessage("");
	
	RangeCaptured = Boolean[Integer];

	CurrentOrder = 0;
	declare i = 0;
	foreach (n in Checkpoints)
	{
		i += 1;
		RangeCaptured[i - 1] = False;
		
		foreach (cp in n)
			cp.Gauge.Speed = -1;
	}
	
	AttackingClan = 3 - AttackingClan;
	declare netwrite Net_AttackingClan for Teams[0] = AttackingClan;
	Net_AttackingClan = AttackingClan;
	
	foreach (player in Players)
	{
		SendSrvMessage(player.Login, "GoRespawnScreen");
		SendSrvMessage(player.Login, "SetPlayerClan");
	}
	
	CurrentGameState = EGameState_Starting;
	UpdateColors();
	
	if (IsRangedMap)
		CurrentOrder = RangedProgression[AttackingClan];
	
	CurrentGameState = EGameState_InPlay;
	UpdateColors();
	UpdateGates();
	
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	RefreshCheckpointsInterfaceVariables();
	
	RoundWinner = 0;
	MapWinner = 0;
	
	EndTime = -1;
	
	IsOvertime = False;
	
	StormiumIT::SetGoalCount(Checkpoints[0].count);
	
	while(Players.count < S_RequiredPlayers)
	{
		yield;
		UIManager.UIAll.StatusMessage = "Required Players: " ^ S_RequiredPlayers ^ " | Current Players count: " ^ Players.count;
		UIManager.UIAll.BigMessage = "Waiting for players...";
	}
	
	Net_MatchIsRunning = True;
	
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	
	EndTime = Now + (S_EndTime * 60000) + (S_TimeSelectionTime * 1000);
	MatchStartTime = Now + (S_TimeSelectionTime * 1000);
	
	foreach (player in Players)
		SendSrvMessage(player.Login, "GoRespawnScreen");

	if (MB_Private_SectionCount_Round < S_MaxRounds)
		Message::SendBigMessage("New round.", 3000, 10);
	else
		Message::SendBigMessage("Last round!", 6000, 10);
		
	if (IsRangedMap)
	{		
		if (CurrentOrder >= Checkpoints.count)
		{
			declare netwrite Net_IsFinalGoal for Teams[0] = True;
			Net_IsFinalGoal = True;
			
			Message::SetDefaultStatusMessage("Rush time!");
			EndTime = (Now + (S_RushTime * 1000)) + S_RushTimeGateDuration;
			UIManager.UIAll.CountdownEndTime = Now + S_RushTimeGateDuration;
			
			Message::SendStatusMessage(Teams[AttackingClan - 1].ColorizedName ^ " will start at rush time!", 4000, 10);
		}
		else
			Message::SendStatusMessage(Teams[AttackingClan - 1].ColorizedName ^ " will start at range #" ^ CurrentOrder, 4000, 10);
	}
***

***OnNewPlayer***
***
	declare respawnTime for Player = Now;
	SetPlayerClan(Player, GetTeam());
	declare PlayerClan for Player = Player.CurrentClan;
	PlayerClan = Player.CurrentClan;
	
	SendSrvMessage(Player.Login, "GoRespawnScreen");
	SendSrvMessage(player.Login, "SetPlayerClan", PlayerClan);
***

***Match_Yield***
***
	Users_SetNbFakeUsers(S_BotBlue, S_BotRed);

	Message::Loop();
	StormiumSS::Loop();
	StormiumIT::Loop();
	
	Layers::Attach("CGame.GateMarkers");
	Layers::Attach("CGame.GoalMarkers");
	Layers::Attach("CGame.Overtime");
	Layers::Attach("CGame.SpawnInterface");
***

***Match_PlayLoop***
***	
	declare netwrite Net_MatchStartTime for Teams[0] = 0;
	Net_MatchStartTime = MatchStartTime;

	/*if (LastTimeBalance + 3000 < Now && MathLib::Abs(GetNbPlayers(1) - GetNbPlayers(2)) > 1)
	{
		BalanceTeams();
	}*/

	foreach (e in PendingEvents)
	{
		if (e.Type == CSmModeEvent::EType::OnPlayerRequestRespawn)
			PassOn(e);
		if (e.Type == CSmModeEvent::EType::OnCapture)
		{
			PassOn(e);
		}
		if (e.Type == CSmModeEvent::EType::OnHit)
		{
			if (e.Victim != Null && e.Victim != e.Shooter)
				PassOn(e);
		}
		if (e.Type == CSmModeEvent::EType::OnActionEvent)
		{
			+++OnActionEvent+++
			Kits::OnActionEvent(e);
		}
		if (e.Type == CSmModeEvent::EType::OnActionCustomEvent) 
		{
			+++OnActionCustomEvent+++
		}
	}

	foreach (player in Players)
	{
		player.Stamina += 1;
	
		if (player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
		{	
			declare PlayerClan for player = player.RequestedClan;
			if (LastTimeBalance + 20000 < Now)
			{
				PlayerClan = player.RequestedClan;
			}
			/*if (MathLib::Abs(GetNbPlayers(1) - GetNbPlayers(2)) <= 2)
				PlayerClan = player.RequestedClan;
			if (PlayerClan == 0)
				PlayerClan = GetTeam();
				
			if (MathLib::Abs(GetNbPlayers(1) - GetNbPlayers(2)) >= 2)
				PlayerClan = GetTeam();
			
				
			declare oldPlayerClan = player.CurrentClan;
			
			if (oldPlayerClan != PlayerClan)
			{
				declare UI <=> UIManager.GetUI(player);
				if (UI != Null)
				{
					UI.SendChat("$999Team notice: $fffYou was redirected to " ^ Teams[PlayerClan - 1].ColorizedName ^ " team"); 
				}
			}*/
				
			SetPlayerClan(player, PlayerClan);
			
			declare UI <=> UIManager.GetUI(player);
			declare netread Net_playerWantRespawn for UI = False;
			declare netread Net_playerSyncTime for UI = 0;
			declare netread Net_playerLastTime for UI = 0;
			declare netread Net_playerSpawn for UI = 0;
			declare netread Net_playerSpawnOrder for UI = 0;
			declare netread Net_playerWantedKit for UI = "soldier";
			
			declare lastTime for player = 0;
			declare netwrite Net_playerMayChooseThisKit for player = "";
			Net_playerMayChooseThisKit = Net_playerWantedKit;
			
			if ((Net_playerWantRespawn
			|| player.User.IsFakeUser)
			&& MatchStartTime < Now)
			{			
				declare CSmMapLandmark spawn;
				if (MapLandmarks_PlayerSpawn.existskey(Net_playerSpawn))
					spawn <=> MapLandmarks_PlayerSpawn[Net_playerSpawn];
			
				if (get_IsFinalGoal && player.CurrentClan == 3 - AttackingClan)
				{
					spawn <=> PlayerSpawns["SpawnGoal"][0][0];
				}
			
				if (spawn != Null && (IsValidSpawn(spawn, player) || player.User.IsFakeUser))
				{
					player.ArmorMax = 10000;
					player.Armor = player.ArmorMax;
					
					SendSrvMessage(player.Login, "GoRespawnScreen");
					
					Kits::SetKit(player, Net_playerWantedKit);
					
					declare respawnTime for player = Now;
					SM::SpawnPlayer(player, player.CurrentClan, player.Armor, spawn.PlayerSpawn, Now);
					
					/*if (player.User.IsFakeUser)
						player.Armor = 100;*/
				}
			}
		} 
		/*else
			Layers::Detach("CGame.SpawnInterface", player);*/
	}
	
	declare nbOfCheckpointsCaptured = 0;
	foreach (clanOrder => order in Checkpoints)
	{
		// Choose the right checkpoint
		if (clanOrder == CurrentOrder)
			foreach (checkpoint in order)
			{
				if (checkpoint.Gauge.Captured 
					|| checkpoint.Gauge.Value == checkpoint.Gauge.Max)
				{
					if (!checkpoint.Gauge.Captured)
						checkpoint.Gauge.Captured = True;
				
					nbOfCheckpointsCaptured += 1;
				}
			
				declare CSmPlayer[] players;
				if (checkpoint.Sector != Null)
					if (checkpoint.Sector.PlayersIds.count > 0)
					{
						foreach (id in checkpoint.Sector.PlayersIds)
						{
							if (Players.existskey(id))
							players.add(Players[id]);
						}
					}
					else
						checkpoint.Gauge.Speed = 0;
						
			
				checkpoint.Gauge.Speed = SpeedValue(checkpoint.Gauge, players);
				if (checkpoint.Gauge.Speed > 0)
				{
					if (IsOvertime)
					{
						UIManager.UIAll.CountdownEndTime = Now + 60000;
						OvertimeEndTime = Now + 5000;
					}
				}
				
				declare lastUIUpdateTime for This = 0;
				if (lastUIUpdateTime + 250 < Now)
				{
					lastUIUpdateTime = Now;
					RefreshCheckpointsInterfaceVariables();
				}
			}
	}
	foreach (I => goal in Goals)
	{
		if (UIManager.UIAll.CountdownEndTime == -1 && get_IsFinalGoal)
		{
			if ((goal.Gauge.Value == 0)
				&& goal.Gauge.Speed == -1)
			{
				goal.Gauge.Speed = 1;
				MB_Yield();
			
				goal.Gauge.Clan = AttackingClan;
				goal.Base.Clan = AttackingClan;
			}
			
			if (goal.Gauge.Value == goal.Gauge.Max
				&& goal.Gauge.Speed == 1)
			{
				if (!goal.Gauge.Captured)
					goal.Gauge.Captured = True;
			}
		
			declare atkClanPresent = False;
			declare defClanPresent = False;
			declare lastDefClanStayTime for This = -1;
			foreach (playerId in goal.Sector.PlayersIds)
			{
				if (Players.existskey(playerId))
				{
					declare player <=> Players[playerId];
					if (player.CurrentClan == AttackingClan)
						atkClanPresent = True;
					else
					{
						defClanPresent = True;
						lastDefClanStayTime = Now;
					}
				}
			}
			
			if (atkClanPresent && lastDefClanStayTime + 250 < Now && goal.Gauge.Speed == 0)
			{
				foreach (player in Players)
					player.SpeedPower = 0.1;
				Message::SendBigMessage("Victory for " ^ Teams[AttackingClan - 1].ColorizedName ^ "!", 6000, 10);
				
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
				
				RoundWinner = AttackingClan;
				goal.Gauge.Speed = -1;
				goal.Gauge.Value -= 1;
				MB_Yield();
				
				EndTime = Now + 2500;
			}
		}
	}
	
	declare lastNbOfCheckpointsCaptured for This = 0;
	if (nbOfCheckpointsCaptured != lastNbOfCheckpointsCaptured)
	{
		if (nbOfCheckpointsCaptured > lastNbOfCheckpointsCaptured)
		{
			OvertimeEndTime = -1;
			UIManager.UIAll.CountdownEndTime = -1;
		
			Message::SendStatusMessage("Checkpoints " ^ nbOfCheckpointsCaptured ^ "/" ^ Checkpoints[CurrentOrder].count ^ " captured", 4000, 5);
			Message::SendBigMessage("Checkpoint captured!", 4000, 5);
			
			PlaySound(CUIConfig::EUISound::Capture, 1);
			
			RefreshCheckpointsInterfaceVariables();
			
			IsOvertime = False;
			
			if (EndTime == -1)
				EndTime = Now;
			
			EndTime += S_GainTimeOnCapture * 1000;
		}
	
		lastNbOfCheckpointsCaptured = nbOfCheckpointsCaptured;
	}
	
	if (UIManager.UIAll.CountdownEndTime < Now
	&& UIManager.UIAll.CountdownEndTime != -1)
	{
		UIManager.UIAll.CountdownEndTime = -1;
		OvertimeEndTime = -1;
		Message::SendBigMessage("Goal Gates are open!", 4000, 10);
		
		foreach (order in Gates)
		{
			foreach (gate in order)
			{
				gate.Gate.ManualClosed = False;
				
				gate.Gauge.Value = 0;
				gate.Gauge.Max = 0;
			}
		}
	}
	
	if (!get_IsFinalGoal && RangeCaptured.existskey(CurrentOrder) && Checkpoints.existskey(CurrentOrder) && nbOfCheckpointsCaptured == Checkpoints[CurrentOrder].count
		&& !RangeCaptured[CurrentOrder])
	{
		UIManager.UIAll.CountdownEndTime = -1;
		OvertimeEndTime = -1;
	
		RangeCaptured[CurrentOrder] = True;
		Message::SendBigMessage(TextLib::Compose("$<%1$> captured the gate!", Teams[AttackingClan - 1].ColorizedName), 6000, 10);
		Message::SendStatusMessage("Range #"^ CurrentOrder ^" captured!", 6000, 10);
		
		PlaySound(CUIConfig::EUISound::ScoreProgress, 1);
		
		RefreshCheckpointsInterfaceVariables();
		
		CurrentOrder += 1;
		
		RangedProgression[AttackingClan] = CurrentOrder;
		
		if (CurrentOrder >= Checkpoints.count)
		{		
			declare netwrite Net_IsFinalGoal for Teams[0] = True;
			Net_IsFinalGoal = True;
			
			Message::SetDefaultStatusMessage("Rush time!");
			EndTime = (Now + (S_RushTime * 1000)) + S_RushTimeGateDuration;
			UIManager.UIAll.CountdownEndTime = Now + S_RushTimeGateDuration;
			
			foreach (player in Players)
			{
				if (player.CurrentClan == 3 - AttackingClan)
				{
					SendSrvMessage(player.Login, "GoRespawnScreen");
					UnspawnPlayer(player);
					
					declare respawnTime for player = Now;
					respawnTime = Now;
				}
			}
		}
		else
		{
			EndTime += S_GainTimePerNewRange * 1000;
			
			declare netwrite Net_IsFinalGoal for Teams[0] = False;
			Net_IsFinalGoal = False;
		}
		
		UpdateColors();
		UpdateGates();
	}
	else if (get_IsFinalGoal)
	{
		StormiumIT::SetGoalCount(0);
		if ((Now % 1000) == 0)
		{
			PlaySound(CUIConfig::EUISound::Custom4, 0);
		}
	}
	
	if (IsOvertime && (Now % 1000) == 0
	&& OvertimeEndTime != Now + 5000)
	{
		PlaySound(CUIConfig::EUISound::Warning, 1);
	}
	
	if ((EndTime < Now
	&& EndTime != -1)
	|| (OvertimeEndTime < Now
	&& OvertimeEndTime != -1))
	{
		if (!IsOvertime && !get_IsFinalGoal)
		{
			IsOvertime = True;
			OvertimeEndTime = Now + 5000;
			EndTime = -1;
			
			PlaySound(CUIConfig::EUISound::TimeOut, 1);
		}
		else
		{
			MB_StopRound();
			if (RoundWinner == 0)
				RoundWinner = 3 - AttackingClan;
		}
	}
	
	UpdateGetVariables();
***

***Match_EndRound***
***
	UIManager.UIAll.CountdownEndTime = -1;
	
	if (RoundWinner != 0)
	{
		ClanScores[RoundWinner] += 1;
	}

	if (RoundWinner == AttackingClan)
		MB_Sleep(2000);

	EndTime = -1;

	CurrentGameState = EGameState_Starting;
	UpdateColors();
	SM::UnspawnAllPlayers();
	
	declare netwrite Net_MatchIsRunning for Teams[0] = False;
	Net_MatchIsRunning = False;
	
	MB_Sleep(3000);
	
	if (IsRangedMap && RoundWinner == AttackingClan)
	{
		LastRoundWinner = RoundWinner;		
	}
	
	declare RoundFactor = 1;
	if (IsRangedMap)
		RoundFactor = 2;
	
	if (RoundWinner != 0 && (RoundWinner == LastRoundWinner || MB_Private_SectionCount_Round >= S_MaxRounds * RoundFactor))
	{
		if (MB_Private_SectionCount_Round >= S_MaxRounds && LastRoundWinner == 0)
			LastRoundWinner = 3;
	
		MapWinner = LastRoundWinner;
		MB_StopMap();
	}
	
	LastRoundWinner = RoundWinner;
***

***Match_EndMap***
***
	if (MapWinner != 0)
	{
		if (MapWinner != 3)
			UIManager.UIAll.BigMessage = """$<{{{Teams[MapWinner - 1].ColorizedName}}}$z$s$> wins the map!""";
		else
			UIManager.UIAll.BigMessage = _("Draw.");
			
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
		
		
		MB_Sleep(6000);
	}
	else
	{
		UIManager.UIAll.BigMessage = "Changing map...";
		MB_Sleep(1000);
	}
***

Void UpdateGates()
{
	foreach (clanOrder => order in Gates)
	{
		foreach (gate in order)
		{
			if (gate.Order < CurrentOrder)
			{
				declare _gate <=> gate.Gate;
				_gate.Automatic = False;
				if (!get_IsFinalGoal && gate.Order + 1 == RangeCaptured.count)
					_gate.ManualClosed = True;
				else
					_gate.ManualClosed = False;
					
				_gate.Clan = 0;
		
				declare gauge <=> gate.Gauge;
				if (gate.Order + 1 == RangeCaptured.count)
				{
					gauge.Value = S_RushTimeGateDuration;
					gauge.Max = S_RushTimeGateDuration;
				}
				else
				{
					gauge.Value = 0;
					gauge.Max = 0;
				}
				gauge.Speed = -1;
				gauge.Captured = False;
				gauge.Clan = 0;			
			}
		}
	}
}

Void PlaySound(CUIConfig::EUISound sound, Integer variant)
{
	UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, sound, variant);
}

Void UpdateGetVariables()
{

	declare netwrite Net_IsFinalGoal for Teams[0] = False;
	get_IsFinalGoal = RangeCaptured.count - 1 < CurrentOrder;
	Net_IsFinalGoal = get_IsFinalGoal;
	
	declare netwrite Net_CurrentOrder for Teams[0] = 0;
	Net_CurrentOrder = CurrentOrder;
	
	declare netwrite Net_IsOvertime for Teams[0] = False;
	Net_IsOvertime = IsOvertime;
	
	declare netwrite Net_OvertimeEndTime for Teams[0] = 0;
	Net_OvertimeEndTime = OvertimeEndTime;
}

Integer GetNbPlayers(Integer clan)
{
	declare count = 0;
	foreach (player in Players)
	{
		declare PlayerClan for player = 0;
		if (PlayerClan == clan)
			count += 1;
	}
	return count;
}

Integer GetTeam()
{
	if (GetNbPlayers(1) > GetNbPlayers(2))
		return 2;
	else if (GetNbPlayers(2) > GetNbPlayers(1))
		return 1;
	return AttackingClan;
}

Void BalanceTeams()
{
	LastTimeBalance = Now; 
	
	UIManager.UIAll.SendChat("Teams are now balanced in term of size.");
	foreach (player in Players)
	{	
		declare oldPlayerClan = player.CurrentClan;
		declare PlayerClan for player = GetTeam();
		PlayerClan = GetTeam();
		//yield;
		
		if (oldPlayerClan != PlayerClan)
		{
			UnspawnPlayer(player);
			declare UI <=> UIManager.GetUI(player);
			if (UI != Null)
			{
				UI.SendChat("$999Team notice: $fffYou was redirected to " ^ Teams[PlayerClan - 1].ColorizedName ^ " team"); 
			}
		}
	}
}

Boolean IsValidSpawn(CSmMapLandmark spawn, CSmPlayer player)
{
	declare isAvailable = True;

	declare spawnClan for spawn = 0;
	if (spawnClan != spawn.Base.Clan)
		UIManager.UIAll.SendChat(spawnClan ^ " : " ^ spawn.Base.Clan);
	if (spawnClan == player.CurrentClan)
	{
		isAvailable = True;
	}
	else
		isAvailable = False;
		
	if (spawn.Tag == "SpawnGoal" && player.CurrentClan == AttackingClan)
		isAvailable = False;
	if (spawn.Tag == "SpawnAttack" && get_IsFinalGoal)
		isAvailable = False;
	if (spawn.Tag == "SpawnGoal" && player.CurrentClan == 3 - AttackingClan && !get_IsFinalGoal)
		isAvailable = False;
						
	return isAvailable;
}

Integer SpeedValue(CSmMapGauge gauge, CSmPlayer[] players)
{
	declare value = 0;
	foreach (player in players)
	{
		if (player.CurrentClan == AttackingClan)
		{
			declare netwrite Net_IsDisguise for player = False;
			if (!Net_IsDisguise)
				value += 1;
		}
		else value -= 1;
	}
	
	if (value < 0)
		value = 0;
	if (value > 1 && !S_MultiPlayerFasterCap)
		value = 1;
	
	return value;
}

Text MLPos(Vec3 pos)
{
	return """{{{pos[0]}}} {{{pos[1]}}} {{{pos[2]}}}""";
}

Text layer_GetSpawnInterface()
{
	declare CC = "halign='center' valign='center'";
	declare ml_spawnFrame = """ """;
	declare spawnCount = MapLandmarks_PlayerSpawn.count;
	for (i, 0, 20)
	{
		ml_spawnFrame ^= """
			<frameinstance posn="0 -{{{i*16}}} 0" modelid="fm_Spawn"		id="fi_Spawn({{{i}}})" />
		""";
	}
	
	return """
	<manialink version="2">
		<framemodel id="fm_Class">
			<label {{{CC}}} posn="-22.5 0 2" id="Label_Icon" text="Ó•™"/>
			<quad posn="0 -8 1" id="Quad_Selected" style="BgRaceScore2" rot="-90" substyle="CartoucheLine" halign="left" valign="center" sizen="16 60" colorize="0f0"/>
			<label textfont="Oswald" id="Label_SelectClass" scriptevents="1" posn="0 0 0" halign="center" valign="center" text="SOLDIER" sizen="60 15" textsize="4" />
			<label textfont="RajdhaniMono" id="Label_KitCounter" posn="20 0 0" halign="center" valign="center" text="0" sizen="60 15" textsize="4" />
		</framemodel>
		<framemodel id="fm_Spawn">
			<quad posn="0 -8 1" id="Quad_Selected" style="BgRaceScore2" rot="90" substyle="CartoucheLine" halign="right" valign="center" sizen="16 60" colorize="0f0"/>
			<label textfont="Oswald" id="Label_SelectSpawn" scriptevents="1" posn="0 0 0" halign="center" valign="center" text="SPAWN #1" sizen="60 15" textsize="4" />
		</framemodel>
	<frame id="mainFrame">
		<!--<frame hidden="1">
			<minimap posn="0 0 1" halign="center" valign="center" sizen="75 75" id="Minimap_Main" />
			<quad halign="center" valign="center" sizen="95 95" image="file://Media/Manialinks/Common/StationInfo/WindowBg.dds" />
			<quad halign="center" valign="center" sizen="80 80" image="file://Media/Manialinks/Common/Minimap/MinimapOverlay2.dds" posn="0 0 2" />
		</frame>-->
		
		<frame posn="0 0 0" id="Frame_AtkInfo">
			<label id="Label_AtkInfo" {{{CC}}} text="You are attacking!" textprefix="$s" textfont="OswaldMono"/>
		</frame>
		
		<frame posn="0 0 10" id="Clip_FrameKitInfo" clipsizen="180 80" clip="1" clipposn="0 0">
			<frame posn="0 0" id="FrameKitInfo">
				<label posn="-88 30" halign="left" valign="bottom" textfont="Oswald" textprefix="$t" id="Label_DescClassName" text="Soldier" textsize="8" />
				<quad posn="-90 30" halign="left" valign="bottom" bgcolor="000" opacity="1" sizen="45 10" />
				<quad halign="center" valign="center" bgcolor="000" opacity="0.8" posn="0 -5" sizen="180 70" />
				<label halign="right" valign="center" posn="85 35 5" textprefix="$sÔÅ© " text="Press '1' to heal yourself" />	
				
				<frame posn="0 25.75 5" id="FrameDescShootButton" scale="0.95">
					<label posn="-86 0 2" text="Ó¶è SHOOT BUTTON" halign="left" valign="top" textfont="Oswald" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionShoot" posn="-80 -7.5 0" textprefix="$sÔÅ© " text="MultiPlasma / MiniGun" />	
				</frame>
				<frame posn="0 8.5 5" id="FrameDescAction1Button" scale="0.95">
					<label id="Label_Action1Button" posn="-86 0 2" text=" A   BUTTON" halign="left" valign="top" textfont="Oswald" />
					<label posn="-84.5 -1.5 2" text=" Ôáõ" halign="center" valign="center" textfont="Oswald" textsize="5" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionAction1" posn="-80 -7.5 0" textprefix="$sÔÅ© " text="Switch Weapon between MultiPlasma and MiniGun" />	
				</frame>
				<frame posn="0 -8.5 5" id="FrameDescAction2Button" scale="0.95">
					<label posn="-86 0 2" text=" E   BUTTON" halign="left" valign="top" textfont="Oswald" />
					<label posn="-84.5 -1.5 2" text=" Ôáõ" halign="center" valign="center" textfont="Oswald" textsize="5" />
					<quad posn="-88 2 1" sizen="175 7.5" bgcolor="000" opacity="0.5" />
					<quad posn="-88 2 0" sizen="175 15" bgcolor="000" opacity="0.25" />		
					<label id="Label_DescriptionAction2" posn="-80 -7.5 0" textprefix="$sÔÅ© " text="Grenade" />	
				</frame>
				
				<label id="Label_DescriptionWarning" posn="-84 -22" sizen="170" autonewline="1" halign="left" valign="top" textprefix="$f00" text="Ó§ö MultiPlasma is very powerful with 4 amunitions !
Ó§ö MiniGun can explose if it is used too long !" textsize="2"/>

			</frame>
		</frame>
		
		<frame posn="0 70" id="FrameViewLogo">
			<quad posn="0 -10.75" sizen="60 20" halign="center" valign="center" image="https://cdn.discordapp.com/attachments/244514503323025408/316925411625795587/AgeLogo.png" keepratio="Fit" />	
			<quad posn="0 0 -59" halign="center" valign="center" bgcolor="555" opacity="0.5" sizen="360 40" />	
		</frame>
		
		<frame posn="-130 25" scale="1" id="FrameViewSpawns">
			<quad posn="0 -25 -60" style="Bgs1" substyle="BgEmpty" halign="center" valign="center" sizen="75 100" />
			<label posn="0 -70 1" halign="center" valign="center" style="TextButtonNav" scriptevents="1" text="$süé• Reset Spawn Selection" sizen="60 10" id="resetView" />
			<label posn="0 32 10" halign="center" valign="center" textfont="Oswald" text="$fff$tSelect your spawn" sizen="40 10" scale="1.5" />
			<quad posn="0 25.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 0.75" />
			<label posn="0 25.5 10" halign="center" valign="center" textcolor="fff" text="$fff‚è∑" sizen="40 10" scale="2" />
			
			{{{ml_spawnFrame}}}
		</frame>
		
		<frame posn="130 25" id="FrameViewKits">
			<quad posn="0 -25 -60" style="Bgs1" substyle="BgEmpty" halign="center" valign="center" sizen="75 100" />
			<label posn="0 32 10" halign="center" valign="center" textfont="Oswald" text="$fff$tSelect your kit" sizen="40 10" scale="1.5" />
			<quad posn="0 25.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 0.75" />
			<label posn="0 25.5 10" halign="center" valign="center" textcolor="fff" text="$fff‚è∑" sizen="40 10" scale="2" />
			
			<frame posn="0 -25">
				<frameinstance modelid="fm_Class" id="Frame_Class1" posn="0 40"/>
				<frameinstance modelid="fm_Class" id="Frame_Class2" posn="0 24"/>
				<frameinstance modelid="fm_Class" id="Frame_Class3" posn="0 8"/>
				<frameinstance modelid="fm_Class" id="Frame_Class4" posn="0 -8"/>
				<frameinstance modelid="fm_Class" id="Frame_Class5" posn="0 -24"/>
				<frameinstance modelid="fm_Class" id="Frame_Class6" posn="0 -40"/>
			</frame>
		</frame>
		
		<frame posn="0 -75" scale="1" id="FrameViewReady">
			<quad posn="0 5 -59" halign="center" valign="center" bgcolor="555" opacity="0.5" sizen="360 40" />	
			<quad posn="0 24.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 1" />
			<quad posn="0 5.5 10" halign="center" valign="center" bgcolor="eee" opacity="1." sizen="60 1" />
			<label posn="0 17 10" textfont="Oswald" halign="center" valign="center2" sizen="60 20" text="READY" textsize="8" />
			<label posn="0 10 10" textfont="Oswald" halign="center" valign="center2" sizen="60 20" text="to spawn" textsize="4" />
			<quad posn="0 15" halign="center" valign="center" bgcolor="222" scriptevents="1" sizen="60 20" id="setReady"/>
		</frame>
	</frame>
	
	<label id="Label_MatchStartTime" halign='center' valign='center' posn="0 0 5" textprefix="$s" text="Start in..." textfont="RajdhaniMono" textsize="8"/>
	
	<label id="labelFps" posn="-160 -60" text="FPS" />
		
		<script><!--
			#Include "TextLib" as TL
			#Include "MathLib" as MathLib
			
			#Const C_Quad_IsSelected	"file://Media/Manialinks/Common/WarmUp/ButtonOn.dds"
			#Const C_Quad_IsNotSelected	"file://Media/Manialinks/Common/WarmUp/ButtonOff.dds"
			
			declare CMlFrame[] SpawnsFrame;
			declare CSmMapLandmark CurrentSelectedSpawn;
			
			declare CMlFrame FrameViewSpawns;
			declare CMlFrame FrameViewKits;
			declare CMlFrame FrameViewReady;
			declare CMlFrame FrameViewLogo;
			
			declare CMlLabel Label_AtkInfo;
			
			Real Lerp(Real a, Real b, Real t)
			{
				return a*(1-t) + b*t;
			}
			
			Vec3 Lerp(Vec3 a, Vec3 b, Real t)
			{
				declare v1 = a[0]*(1-t) + b[0]*t;
				declare v2 = a[1]*(1-t) + b[1]*t;
				declare v3 = a[2]*(1-t) + b[2]*t;
				
				return <v1, v2, v3>;
			}
		
			Vec3 stringToVec3(Text string)
			{
				log(">" ^ string);
				declare Text[] Members = TL::Split(",", string);
				Members[0] = TL::Replace(Members[0], "<", "");
				Members[2] = TL::Replace(Members[2], ">", "");
				return <TL::ToReal(Members[0]), TL::ToReal(Members[1]), TL::ToReal(Members[2])>;
			}
			
			Void UpdateAvailableSpawns()
			{			
				if (InputPlayer == Null)
					return;
					
				declare netread Net_AttackingClan for Teams[0] = 1;
				declare netread Net_IsFinalGoal for Teams[0] = False;
				declare netread Net_SpawnClan for Teams[0] = Integer[Integer];
				declare netread Net_CurrentOrder for Teams[0] = 0;
			
				declare playerClan = InputPlayer.CurrentClan;
				
				//< Instant spawn
					declare availableCount = 0;
					declare availableIndex = 0;
				//>
				
				if (CurrentSelectedSpawn != Null) 
				{	
					declare spawn <=> CurrentSelectedSpawn;
					declare key = MapLandmarks_PlayerSpawn.keyof(spawn);
					if (spawn.Tag == "SpawnGoal" && playerClan == Net_AttackingClan)
						CurrentSelectedSpawn = Null;
					if (spawn.Tag == "SpawnAttack" && Net_IsFinalGoal)
						CurrentSelectedSpawn = Null;
					if (spawn.Tag == "SpawnGoal" && playerClan == 3 - Net_AttackingClan && !Net_IsFinalGoal)
						CurrentSelectedSpawn = Null;	
					if (!Net_SpawnClan.existskey(key) || Net_SpawnClan[key] != playerClan)
						CurrentSelectedSpawn = Null;

				}

				foreach (i => frame in SpawnsFrame)
				{
					declare isAvailable for frame = True;
					isAvailable = True;
					
					declare CSmMapLandmark spawn;
					if (!MapLandmarks_PlayerSpawn.existskey(i))
						isAvailable = False;
					else
					{
						spawn <=> MapLandmarks_PlayerSpawn[i];
					
						if (spawn.Tag == "SpawnGoal" && playerClan == Net_AttackingClan)
							isAvailable = False;
						if (spawn.Tag == "SpawnAttack" && Net_IsFinalGoal)
							isAvailable = False;
						if (spawn.Tag == "SpawnGoal" && playerClan == 3 - Net_AttackingClan && !Net_IsFinalGoal)
							isAvailable = False;	
						if (Net_SpawnClan.existskey(i) && Net_SpawnClan[i] != playerClan)
							isAvailable = False;	
						if (playerClan == 3 - Net_AttackingClan && spawn.Order != Net_CurrentOrder)
						{
							isAvailable = False;
						}
						if (playerClan == 3 - Net_AttackingClan && spawn.Tag == "SpawnGoal" && Net_IsFinalGoal)
						{
							isAvailable = True;
						}
					}
					
					frame.Visible = isAvailable;
					
					declare spawnIndex for frame = 0;
					spawnIndex = i;

					if (isAvailable)
					{
						frame.RelativePosition.Y = 16 -(availableCount * 16.); 
						
						availableCount += 1;
						availableIndex = i;
						
						declare nameLabel for frame = CMlLabel;
						declare spawnName = "Spawn #" ^ i;
						declare spawnPosition for frame = Vec3;
						declare metadata LandmarkCustomName for spawn = "";
						if (LandmarkCustomName != "")
							spawnName = LandmarkCustomName;
							
						spawnPosition = spawn.Position;
						
						nameLabel.SetText("$t" ^ spawnName);
					}
				}
				
				if (availableCount == 1)
				{
					if (MapLandmarks_PlayerSpawn.existskey(availableIndex))
						CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[availableIndex];
				}
			}
			
			Void ManageGameView()
			{
				declare ClientMarkers for LocalUser = Text[Text];
			
				declare ActivePlayer <=> InputPlayer;
				if (GUIPlayer != Null)
					ActivePlayer <=> GUIPlayer;
			
				if (CurrentSelectedSpawn != Null)
				{
					declare p = CurrentSelectedSpawn.Position;
					
					if (ActivePlayer.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
						ClientMarkers["age"] ^= "<marker pos='" ^ p.X ^ " " ^ p.Y + 2.5 ^ " " ^ p.Z ^ "' label='Selected Spawn' color='4f4'/>";
				
					ClientUI.SpectatorForcedTarget = CurrentSelectedSpawn.Id;
					if (ActivePlayer != Null)
						ClientUI.SpectatorForcedClan = ActivePlayer.CurrentClan;
				}
				else
					ClientUI.SpectatorForcedTarget = NullId;
					
				if (GUIPlayer != Null)
				{
					ClientUI.OverlayHideGauges = (InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !IsSpectator);
				}
				
				declare netread Net_AttackingClan for Teams[0] = 1;
				
				declare netread Net_MatchIsRunning for Teams[0] = False;
				
				if (ActivePlayer != Null && Net_MatchIsRunning)
				{
					if (ActivePlayer.CurrentClan == Net_AttackingClan)
						Label_AtkInfo.SetText("You are attacking!");
					else if (ActivePlayer.CurrentClan == 3 - Net_AttackingClan)
						Label_AtkInfo.SetText("You are defending!");
				}
				else
					Label_AtkInfo.SetText("");
			}
			
			Void ManageFramePos(Real deltaTime)
			{
				declare netread Net_MatchIsRunning for Teams[0] = False;
			
				declare goViewKits_pos = <200., 25., 0.>;
				declare goViewSpawns_pos = <-200., 25., 0.>;
				declare goTopView_pos = <0., 120., 0.>;
				declare goBottomView_pos = <0., -120., 0.>;
				declare goLabelAtkInfo_pos = <0., -60., 0.>;
				if (InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned
					&& !IsSpectator
					&& Net_MatchIsRunning)
				{
					goViewKits_pos = <130., 25., 0.>;
					goViewSpawns_pos = <-130., 25., 0.>;
					goTopView_pos = <0., 70., 0.>;
					if (GUIPlayer == Null)
						goBottomView_pos = <0., -75., 0.>;
					else
						goBottomView_pos = <0., -90., 0.>;
						
					goLabelAtkInfo_pos = <0., 40., 0.>;
				}
					
				FrameViewKits.RelativePosition = Lerp(FrameViewKits.RelativePosition, goViewKits_pos, deltaTime * 10.);
				FrameViewSpawns.RelativePosition = Lerp(FrameViewSpawns.RelativePosition, goViewSpawns_pos, deltaTime * 10.);
				FrameViewLogo.RelativePosition = Lerp(FrameViewLogo.RelativePosition, goTopView_pos, deltaTime * 10.);
				FrameViewReady.RelativePosition = Lerp(FrameViewReady.RelativePosition, goBottomView_pos, deltaTime * 16.);
				
				Label_AtkInfo.RelativePosition = Lerp(Label_AtkInfo.RelativePosition, goLabelAtkInfo_pos, deltaTime * 20.);
			}
			
			Text GetDescShoot(Text kit)
			{
				if (kit == "soldier")
					return "MultiPlasma / MiniGun";
				if (kit == "sniper")
					return "Sniper Gun";
				if (kit == "ninja")
					return "Knife";
				if (kit == "mage")
					return "BumpHell";
				if (kit == "medic")
					return "ADN / MediGun";
				if (kit == "engineer")
					return "Shotgun";
				return "???";
			}
			
			Text GetDescAction1(Text kit)
			{
				if (kit == "soldier")
					return "Switch Weapon";
				if (kit == "sniper")
					return "Eagle Eye";
				if (kit == "ninja")
					return "Player Disguise";
				if (kit == "mage")
					return "Curse";
				if (kit == "medic")
					return "Switch Weapon";
				if (kit == "engineer")
					return "Turret";
				return "???";
			}
			
			Text GetDescAction2(Text kit)
			{
				if (kit == "soldier")
					return "Grenade";
				if (kit == "sniper")
					return "Grenade";
				if (kit == "ninja")
					return "Smoke Grenade";
				if (kit == "mage")
					return "Forcefield";
				if (kit == "medic")
					return "Boucing Ball (Heal Allies)";
				if (kit == "engineer")
					return "Grenade";
				return "???";
			}
			
			Text GetDescWarning(Text kit)
			{
				if (kit == "soldier")
					return "Ó§ö The more the MultiPlasma is charged, the more the damage you do!\nÓ§ö MiniGun can explose if it is used too long!";
				if (kit == "sniper")
					return "Ó§ö Using Sniper, stop moving at least 3 seconds to get Explosive Bullets! You can do headshot to shoot harder.\nÓ§ö Eagle Eye gives Resistance, Strength, and faster reloads to you and reveal ennemies!";
				if (kit == "ninja")
					return "Ó§ö You will heal each time you hit someone with the knife!\nÓ§ö You can Disguise to look like an ennemy! You loose your disguise when you are shot. You takes damages while being disguised.";
				if (kit == "mage")
					return "Ó§ö BumpHell pushes players in the air ! It doesn't make a lot of damages thought.\nÓ§ö Curse gives weakness to the hit player, he takes twice more damages and move slower!\nForcefield create an explosive area around the hit player !";
				if (kit == "medic")
					return "Ó§ö ADN isn't very powerful but it is enough to defend yourself.\nÓ§ö MediGun is useful to heal your teammates during the battle! But you can't heal yourself with it.\nÓ§ö The Healing Bouncing Ball is a big ball that heal all your teammates around it !";
				if (kit == "engineer")
					return "Ó§ö Shotgun is more powerful near the ennemy than far ! It can push players pretty far.\nÓ§ö Turret are placeable everywhere. You can heal your turret by staying next to it ! Turret upgrade when it stays alive.";
				return "???";
			}
		
			main()
			{				
				for (I, 0, 20)
				{
					declare frame <=> cast(CMlFrame, Page.GetFirstChild("fi_Spawn("^I^")"));
					SpawnsFrame.add(frame);
					
					declare Vec3 pos;
					
					foreach (spawn in MapLandmarks_PlayerSpawn)
					{
						if (spawn != Null)
						{
							pos = spawn.Position;
						}
					}
					
					declare spawnPosition for frame = pos;
					declare spawnIndex for frame = I;
					
					declare nameLabel for frame = (frame.GetFirstChild("Label_SelectSpawn") as CMlLabel);
					declare quadSelected for frame = (frame.GetFirstChild("Quad_Selected") as CMlQuad);
					
					declare parentFrame for nameLabel = CMlFrame;
					parentFrame = frame;
				}
				
				declare FrameClasses = CMlFrame[];
				for (I, 1, 6)
				{
					declare frame <=> (Page.GetFirstChild("Frame_Class" ^ I) as CMlFrame);
					declare classLabel for frame <=> (frame.GetFirstChild("Label_SelectClass") as CMlLabel);
					declare classIcon for frame <=> (frame.GetFirstChild("Label_Icon") as CMlLabel);
					declare quadSelected for frame <=> (frame.GetFirstChild("Quad_Selected") as CMlQuad);
					declare counterLabel for frame <=> (frame.GetFirstChild("Label_KitCounter") as CMlLabel);
					declare isSelected for classLabel = False;
					
					if (I == 1) { classLabel.Value = "SOLDIER"; classIcon.Value = "Ó•™"; }
					if (I == 2) { classLabel.Value = "SNIPER"; classIcon.Value = "ÔÅõ"; }
					if (I == 3) { classLabel.Value = "MAGE"; classIcon.Value = "ÔÉê"; }
					if (I == 4) { classLabel.Value = "NINJA"; classIcon.Value = "üèÉ"; }
					if (I == 5) { classLabel.Value = "ENGINEER"; classIcon.Value = "üîß"; }
					if (I == 6) { classLabel.Value = "MEDIC"; classIcon.Value = "Ôàû"; }
					
					declare originalKit for classLabel = TL::ToLowerCase(classLabel.Value);
					
					quadSelected.Colorize = <1., 1., 1.>;
					quadSelected.Opacity = 0.25;
					
					FrameClasses.add(frame);
				}
				
				FrameViewSpawns <=> (Page.GetFirstChild("FrameViewSpawns") as CMlFrame);
				FrameViewKits <=> (Page.GetFirstChild("FrameViewKits") as CMlFrame);
				FrameViewReady <=> (Page.GetFirstChild("FrameViewReady") as CMlFrame);
				FrameViewLogo <=> (Page.GetFirstChild("FrameViewLogo") as CMlFrame);
				
				declare FrameKitInfo <=> (Page.GetFirstChild("FrameKitInfo") as CMlFrame);
				declare Label_DescriptionShoot <=> (FrameKitInfo.GetFirstChild("Label_DescriptionShoot") as CMlLabel);
				declare Label_DescriptionAction1 <=> (FrameKitInfo.GetFirstChild("Label_DescriptionAction1") as CMlLabel);
				declare Label_DescriptionAction2 <=> (FrameKitInfo.GetFirstChild("Label_DescriptionAction2") as CMlLabel);
				declare Label_DescriptionWarning <=> (FrameKitInfo.GetFirstChild("Label_DescriptionWarning") as CMlLabel);
				declare Label_Action1Button <=> (FrameKitInfo.GetFirstChild("Label_Action1Button") as CMlLabel);
				declare Label_DescClassName <=> (FrameKitInfo.GetFirstChild("Label_DescClassName") as CMlLabel);
				Label_AtkInfo <=> (Page.GetFirstChild("Label_AtkInfo") as CMlLabel);
			
				declare netwrite Net_playerWantRespawn for UI = False;
				declare netwrite Net_playerSpawn for UI = 0;
				declare netwrite Net_playerSpawnOrder for UI = 0;
				declare netwrite Net_playerLastTime for UI = Now;
				declare netwrite Net_playerWantedKit for UI = "soldier";
				
				declare netread Net_MatchStartTime for Teams[0] = 0;
				
				declare netread Net_IsFinalGoal for Teams[0] = False;
				
				declare netread NetSrv_Handle for Teams[0] = ["" => -1];
				declare netread NetSrv_Message for Teams[0] = ["" => ""];
				
				declare lastHandle = ["ALL" => -2, LocalUser.Login => -2];
				
				declare netread NetServ_Dest for Teams[0] = Text[];
				
				declare labelFps = cast(CMlLabel, Page.GetFirstChild("labelFps"));
				
				// Reset
				Net_playerWantRespawn = False;
				Net_playerLastTime = Now;
				Net_playerSpawn = -1;
				
				if (LocalUser != Null)
					UpdateAvailableSpawns();
				
				declare refreshFrames = Now;
				
				declare MainFrame = cast(CMlFrame, Page.GetFirstChild("mainFrame"));
				
				declare QuadReady = cast(CMlQuad, Page.GetFirstChild("setReady"));
				declare Label_MatchStartTime = cast(CMlLabel, Page.GetFirstChild("Label_MatchStartTime"));
				
				declare lastTimeDelta = Now;
				declare TimeDelta = Now + 0.;
				declare lastLog = Now;
				
				declare ClientMarkers for LocalUser = Text[Text];
				
				while(True)
				{
					yield;
					
					TimeDelta = -(lastTimeDelta - Now) / 1000.;
					lastTimeDelta = Now;
					
					ClientMarkers["age"] = "";
					
					if (Net_MatchStartTime > ArenaNow)
					{
						Label_MatchStartTime.SetText("Start in... " ^ MathLib::FloorInteger((Net_MatchStartTime - ArenaNow) * 0.001) ^ "s"); 
					}
					else
					{
						declare netread Net_MatchIsRunning for Teams[0] = False;
						
						if (Net_MatchIsRunning)
							Label_MatchStartTime.SetText("");
						else
							Label_MatchStartTime.SetText("Please wait...");
					}
					
					ManageFramePos(TimeDelta);
					
					if (LocalUser == Null || InputPlayer == Null)
					{
						FrameKitInfo.RelativePosition = Lerp(FrameKitInfo.RelativePosition, <0., -90., 0.>, TimeDelta * 50.);
						continue;
					}
										
					if (lastLog < Now)
					{
						lastLog = Now - 1;
						labelFps.SetText("FPS: " ^ 1 / TimeDelta);
					}
						
					/*MainFrame.Visible = Net_IsFinalGoal || InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned;
					Minimap.Visible = Net_IsFinalGoal || InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned;*/	
					
					if (LocalUser.Language == "fr")
					{
						Label_Action1Button.SetText(" A   BUTTON");
					}
					else
						Label_Action1Button.SetText(" Q   BUTTON");
					
					declare LOGINS = ["ALL", LocalUser.Login];
					foreach (LOGIN in LOGINS)
					if (NetSrv_Handle.existskey(LOGIN) && NetSrv_Handle[LOGIN] != lastHandle[LOGIN])
					{
						lastHandle[LOGIN] = NetSrv_Handle[LOGIN];
						
						//declare isForMe = NetServ_Dest.exists(LOGIN) || NetServ_Dest.exists(LocalUser.Login);
						
						log("received!" ^ NetSrv_Message[LOGIN]);
						
						if (NetSrv_Message[LOGIN] == "GoRespawnScreen")
						{							
							Net_playerSpawn = -1;
							Net_playerLastTime = Now;
							Net_playerWantRespawn = False;
							
							if (InputPlayer.CurrentClan == 1)
							{
								JoinTeam1();
							}
							else
								JoinTeam2();
						}
						if (NetSrv_Message[LOGIN] == "SetPlayerClan" && InputPlayer != Null)
						{

						}
					}
					
					if (Now > refreshFrames)
					{
						refreshFrames = Now + 100;
						
						UpdateAvailableSpawns();
					}
					
					/*Minimap.Size = <75., 75.>;
					//Minimap.ZoomFactor = 1.;
					//Minimap.MapPosition = <1., 0.5>;
					Minimap.MapYaw = 0.;*/
					
					declare PosKitInfo = <0., -120., 10.>;
					
					foreach (frame in SpawnsFrame)
					{
						declare spawnIndex for frame = 0;
						declare quadSelected for frame = CMlQuad;
						
						if (CurrentSelectedSpawn != Null
							&& spawnIndex == MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn))
						{
							quadSelected.Colorize = <0., 1., 0.>;
							quadSelected.Opacity = 1.;
						}
						else
						{
							quadSelected.Colorize = <1., 1., 1.>;
							quadSelected.Opacity = 0.25;
						}
					}
										
					ManageGameView();
					
					foreach (frame in FrameClasses)
					{
						declare quadSelected for frame = CMlQuad;
						declare classLabel for frame = CMlLabel;
						declare originalKit for classLabel = "";
						declare counterLabel for frame = CMlLabel;
						
						if (originalKit == Net_playerWantedKit)
						{
							quadSelected.Colorize = <0., 1., 0.>;
							quadSelected.Opacity = 1.;
						}
						else
						{
							quadSelected.Colorize = <1., 1., 1.>;
							quadSelected.Opacity = 0.25;
						}
						
						declare counter = 0;
						declare ActivePlayer = CSmPlayer;
						if (InputPlayer != Null)
							ActivePlayer <=> InputPlayer;
						if (GUIPlayer != Null)
							ActivePlayer <=> GUIPlayer;
						
						foreach (player in Players)
						{
							if (player.CurrentClan == ActivePlayer.CurrentClan)
							{
								declare netread Net_playerMayChooseThisKit for player = "";
								if (Net_playerMayChooseThisKit == originalKit)
									counter += 1;
							}
						}
						
						if (classLabel.IsFocused)
						{
							PosKitInfo = <0., 0., 10.>;
								
							Label_DescriptionShoot.Value = GetDescShoot(originalKit);
							Label_DescriptionAction1.Value = GetDescAction1(originalKit);
							Label_DescriptionAction2.Value = GetDescAction2(originalKit);
							Label_DescriptionWarning.Value = GetDescWarning(originalKit);
							Label_DescClassName.Value = originalKit;
						}
						
						counterLabel.SetText("" ^ counter);
					}
					
					FrameKitInfo.RelativePosition = Lerp(FrameKitInfo.RelativePosition, PosKitInfo, TimeDelta * 8.5);
					
					/*if (CurrentSelectedSpawn != Null)
					{
						declare pos = CurrentSelectedSpawn.Position;
						
						Minimap.WorldPosition = Lerp(Minimap.WorldPosition, pos, TimeDelta / 0.25);
						Minimap.ZoomFactor = Lerp(Minimap.ZoomFactor, 5., TimeDelta / 0.25);
					}
					else
					{
						Minimap.WorldPosition = Lerp(Minimap.WorldPosition, <192., 0., 192.>, TimeDelta / 0.25);
						Minimap.ZoomFactor = Lerp(Minimap.ZoomFactor, 1., TimeDelta / 0.25);
					}*/
					
					if (Net_playerWantRespawn)
					{
						Net_playerLastTime = Now;
						Net_playerSpawn = MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn);
						
						QuadReady.BgColor = <0., 0.25, 0.>;
						if (QuadReady.IsFocused)
							QuadReady.BgColor = <0.1, 0.20, 0.>;
					}
					else
					{
						QuadReady.BgColor = <0.25, 0.1, 0.1>;
						if (QuadReady.IsFocused)
							QuadReady.BgColor = <0.20, 0.15, 0.>;
					}
					
					foreach (event in PendingEvents)
					{
						if (event.Type == CMlEvent::Type::MouseClick)
						{
							declare control <=> event.Control;
							if (control.ControlId == "selectSpawn")
							{
								declare parentFrame for control = CMlFrame;
								declare spawnIndex for parentFrame = 0;
								declare isAvailable for parentFrame = False;
								
								if (isAvailable)
								{
									CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[spawnIndex];
								}
							}
							if (control.ControlId == "resetView")
								CurrentSelectedSpawn = Null;
								
							if (control.ControlId == "setReady")
							{
								Net_playerWantRespawn = !Net_playerWantRespawn;
								
								if (CurrentSelectedSpawn != Null)
								{
									Net_playerLastTime = Now;
									Net_playerSpawn = MapLandmarks_PlayerSpawn.keyof(CurrentSelectedSpawn);
								}
							}
							
							if (control.ControlId == "Label_SelectClass")
							{
								declare originalKit for control = "";
								Net_playerWantedKit = originalKit;
							}			
							
							if (control.ControlId == "Label_SelectSpawn")
							{
								declare parentFrame for control = CMlFrame;
								declare spawnIndex for parentFrame = 0;
								if (MapLandmarks_PlayerSpawn.existskey(spawnIndex))
									CurrentSelectedSpawn <=> MapLandmarks_PlayerSpawn[spawnIndex];
							}			
						}
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Text layer_GetOvertime()
{
	declare CC = "halign='center' valign='center'";

	return """
	<manialink version="3">
		<frame pos="0 58" z-index="-10" id="Frame_Overtime">
			<label {{{CC}}} pos="0 6.25" text="$s‚è≥" scale="1.75"/>
			<label {{{CC}}} text="$sOVERTIME" textfont="Oswald"/>
			<label {{{CC}}} id="Label_OvertimeEndTime" pos="0 -5" textprefix="$s$f00" text="0" textfont="Oswald"/>
		</frame>
		
		<script><!--
			#Include "MathLib" as MathLib
		
			main()
			{
				declare frame <=> (Page.GetFirstChild("Frame_Overtime") as CMlFrame);
				declare Label_OvertimeEndTime <=> (Page.GetFirstChild("Label_OvertimeEndTime") as CMlLabel);
				declare netread Net_IsOvertime for Teams[0] = False;
				declare netread Net_OvertimeEndTime for Teams[0] = 0;
				
				while(True)
				{	
					yield;
					frame.Visible = Net_IsOvertime;
					
					Label_OvertimeEndTime.Value = MathLib::FloorInteger((Net_OvertimeEndTime - ArenaNow) / 1000.) ^ " SECONDS";
				}
			}
		--></script>
	</manialink>
	""";
}

Text GetScoreManialink()
{
	return """
	<quad pos="0 20" size="1.5 25" bgcolor="999" halign="center" valign="center" />
	<label pos="-10 20" text="0" textcolor="0dd" opacity="0.75" halign="right" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="-150 20" text="‚ùÑ Cryo" textcolor="0dd" opacity="0.75" halign="left" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="10 20" text="0" textcolor="e80" opacity="0.75" halign="left" valign="center" textsize="17.5" textfont="OswaldMono" />
	<label pos="150 20" text="üî• Meteor" textcolor="e80" opacity="0.75" halign="right" valign="center" textsize="17.5" textfont="OswaldMono" />
	""";
}

Text layer_GetGateMarkers()
{
	declare CC = "halign='center' valign='center'";
	declare Instances = "";
	for (i, 0, 15)
	{
		Instances ^= """<frameinstance id="GateMarkers_Instance_{{{i}}}" modelid="FrameModel_Marker" />""";
	}

	return """
	<manialink version="3">
		<framemodel id="FrameModel_Marker" scale="0.75">
			<label {{{CC}}} id="Label_Name" pos="0 4" textprefix="$s$n" text="Gate" textsize="3" textfont="Oswald" />
			<label {{{CC}}} id="Label_Icon" pos="0 0" textprefix="$s$n" text="‚è∑" textsize="4" />
		</framemodel>
		
		{{{Instances}}}
		
		<script><!--
			main()
			{
				declare ClientMarkers for LocalUser = Text[Text];
				declare netread Net_CurrentOrder for Teams[0] = 0; 
				declare netread Net_IsFinalGoal for Teams[0] = False;
				
				declare ValidatedMarkers for LocalUser = Boolean[Text];
				
				declare CMlFrame[] Instances;
				for (i, 0, 15)
				{
					declare frame <=> (Page.GetFirstChild("GateMarkers_Instance_" ^ i) as CMlFrame);
					declare label_Name for frame <=> (frame.GetFirstChild("Label_Name") as CMlLabel);
					declare label_Icon for frame <=> (frame.GetFirstChild("Label_Icon") as CMlLabel);
					
					Instances.add(frame);
				}
				
				while(True)
				{
					yield;
					
					ClientMarkers["gatemarker"] = "";
					
					foreach (frame in Instances)
					{
						declare tempIsVisible for frame = False;
						tempIsVisible = False;
					}
				
					declare i = 0;
					foreach (gate in MapLandmarks_Gate)
					{
						if (gate.Order + 0 == Net_CurrentOrder || (Net_IsFinalGoal && gate.Order + 1 == Net_CurrentOrder))
						{
							declare Pos = gate.Position;
							Pos.Y += 6.;
						
							ClientMarkers["gatemarker"] ^= "<marker pos='" ^ Pos.X ^ " " ^ Pos.Y ^ " " ^ Pos.Z ^ "' manialinkframeid='GateMarkers_Instance_" ^ i ^ "' />";
							
							declare metadata LandmarkCustomName for gate = "";
							declare frame <=> Instances[i];
							declare label_Name for frame = CMlLabel;
							declare label_Icon for frame = CMlLabel;
							
							label_Name.Value = "$fff";
							if (Net_IsFinalGoal)
								label_Name.Value = "$2d2";
							
							if (!Net_IsFinalGoal)
							{
								if (LandmarkCustomName != "")
									label_Name.Value ^= LandmarkCustomName;
								else
									label_Name.Value ^= "Gate";
							}
							else
								label_Name.Value ^= "Access to goal";
								
							label_Icon.Value = "$fff‚è∑";
							if (Net_IsFinalGoal)
								label_Icon.Value = "$2d2‚è∑";
							
							declare tempIsVisible for frame = False;
							tempIsVisible = True;
						} 
					}
					
					foreach (frame in Instances)
					{
						declare tempIsVisible for frame = False;
						frame.Visible = tempIsVisible;
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Text layer_GetGoalMarkers()
{
	declare CC = "halign='center' valign='center'";

	return """
	<manialink version="3">
		<frame id="Frame_GoalMarker" scale="0.75">
			<label {{{CC}}} pos="0 4.5" textprefix="$s$n" text="$0f0GOAL" textfont="Oswald" size="100 10"/>
			<label {{{CC}}} pos="0 0" textprefix="$s" text="$0f0‚è∑" textsize="4" />
		</frame>
		
<script><!--
			main()
			{
				declare ClientMarkers for LocalUser = Text[Text];
				declare netread Net_IsFinalGoal for Teams[0] = False; 
				
				declare ValidatedMarkers for LocalUser = Boolean[Text];
				
				declare Instance <=> (Page.GetFirstChild("Frame_GoalMarker") as CMlFrame);
				
				while(True)
				{
					yield;
					
					Instance.Visible = Net_IsFinalGoal;
					
					ClientMarkers["goalmarker"] = "";
					foreach (goal in MapLandmarks)
					{
						if (goal.Tag == "Goal" && Instance.Visible)
						{
							declare Pos = goal.Position;
							Pos.Y += 26.;
						
							ClientMarkers["goalmarker"] ^= "<marker pos='" ^ Pos.X ^ " " ^ Pos.Y ^ " " ^ Pos.Z ^ "' manialinkframeid='Frame_GoalMarker' />";
						} 
					}
				}
			}
		--></script>
	</manialink>
	""";
}

Void SendSrvMessage(Text PlayerLogin, Text MessageType)
{
	declare netwrite NetSrv_Handle for Teams[0] = ["" => -1];
	declare netwrite NetSrv_Message for Teams[0] = ["" => ""];
	if (!NetSrv_Handle.existskey(PlayerLogin))
		NetSrv_Handle[PlayerLogin] = 1;
	if (!NetSrv_Message.existskey(PlayerLogin))
		NetSrv_Message[PlayerLogin] = MessageType;
		
	NetSrv_Handle[PlayerLogin] += 1;
	NetSrv_Message[PlayerLogin] = MessageType;
	
}

Void AddLandmark(CNod nod, CSmMapLandmark originalLandmark)
{
	if (nod is CSmMapPlayerSpawn)
	{
		declare spawn <=> cast(CSmMapPlayerSpawn, nod);
		
		if (!PlayerSpawns.existskey(originalLandmark.Tag))
		{
			PlayerSpawns[originalLandmark.Tag] = CSmMapLandmark[][Integer];
		}
		if (!PlayerSpawns[originalLandmark.Tag].existskey(originalLandmark.Order))
		{
			PlayerSpawns[originalLandmark.Tag][originalLandmark.Order] = CSmMapLandmark[];
		}

		PlayerSpawns[originalLandmark.Tag][originalLandmark.Order].add(originalLandmark);
	}
	if (nod is CSmMapGauge)
	{
		declare gauge <=> cast(CSmMapGauge, nod);
		declare isGoal = originalLandmark.Tag == "Goal";
		declare isGate = originalLandmark.Tag == "Gate";
		
		if (isGoal)
			Goals[originalLandmark.Order] <=> originalLandmark;
		else if (!isGate)
		{
			if (!Checkpoints.existskey(originalLandmark.Order))
			{
				Checkpoints[originalLandmark.Order] = [Null];
				Checkpoints[originalLandmark.Order].clear();
			}
			
			Checkpoints[originalLandmark.Order].add(originalLandmark);
		}
		else
		{
			if (!Gates.existskey(originalLandmark.Order))
			{
				Gates[originalLandmark.Order] = [Null];
				Gates[originalLandmark.Order].clear();
			}
			
			Gates[originalLandmark.Order].add(originalLandmark);
		}
	}
}

Void RefreshCheckpointsInterfaceVariables()
{
	if (Checkpoints.existskey(CurrentOrder) && !get_IsFinalGoal)
	{
		StormiumIT::SetGoalCount(Checkpoints[CurrentOrder].count);
		foreach (i => checkpoint in Checkpoints[CurrentOrder])
		{
			StormiumIT::SetGoalColorDef(i, Teams[checkpoint.Base.Clan - 1].ColorPrimary);
			StormiumIT::SetGoalColorAtk(i, Teams[checkpoint.Gauge.Clan - 1].ColorPrimary);
			StormiumIT::SetGoalValue(i, checkpoint.Gauge.ValueReal);
			
			declare metadata LandmarkCustomName for checkpoint = "";
			declare Pos = checkpoint.Position;
			Pos.Y += 3.;
			
			StormiumIT::SetGoalName(i, LandmarkCustomName);
			StormiumIT::SetGoalPosition(i, Pos);
		}
	}
	else
	{
		StormiumIT::SetGoalCount(0);
	}
}


Void UpdateColors()
{
	if (CurrentGameState == EGameState_Starting)
	{
		foreach (clanName => order in PlayerSpawns)
		{
			declare clanInt = 0;
			if (clanName == "SpawnAttack")
				clanInt = AttackingClan;
			else
				clanInt = 3 - AttackingClan;
			foreach (spawns in order)
			{				
				foreach (spawn in spawns)
				{
					declare spawnClan for spawn = 0;
					spawnClan = clanInt;
				
					declare base <=> spawn.Base;
					if (base != Null)
					{
						base.IsActive = True;
						base.Clan = spawnClan;
					}
				}
			}
		}
		
		
		foreach (goal in Goals)
		{
			declare base <=> goal.Base;
			if (base != Null)
			{
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
			}
				
			declare gauge <=> goal.Gauge;
			gauge.Value = 750;
			gauge.Max = 750;
			gauge.Clan = 3 - AttackingClan;	
			gauge.Captured = True;		
			gauge.Speed = 0;
		}
		
		foreach (clanOrder => order in Checkpoints)
		{
			foreach (checkpoint in order)
			{
				declare base <=> checkpoint.Base;
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
				
				declare gauge <=> checkpoint.Gauge;
				gauge.Value = 0;
				gauge.Max = S_TimeToCaptureCheckpoint * 1000;
				gauge.Clan = AttackingClan;
			}
		}
		
		foreach (clanOrder => order in Gates)
		{
			foreach (gate in order)
			{
				declare _gate <=> gate.Gate;
				_gate.Automatic = False;
				_gate.ManualClosed = True;
				_gate.Clan = 0;
		
				declare gauge <=> gate.Gauge;
				gauge.Value = 10000;
				gauge.Max = 10000;
				gauge.Captured = False;
				gauge.Clan = 3 - AttackingClan;
				gauge.Speed = 0;
			}
		}
	}
	
	if (CurrentGameState == EGameState_InPlay)
	{
		foreach (clanName => order in PlayerSpawns)
		{
			declare clanInt = 1;
			if (clanName == "SpawnAttack")
				clanInt = AttackingClan;
			else
			{
				clanInt = 3 - AttackingClan;
			}
		
			foreach (spawns in order)
			foreach (spawn in spawns)
			{
				declare spawnClan for spawn = 0;
				spawnClan = clanInt;
				if (spawn.Order <= CurrentOrder - 1
					&& spawn.Tag != "SpawnGoal")
					spawnClan = AttackingClan;
				
				declare base <=> spawn.Base;
				if (base != Null)
				{
					base.IsActive = True;
					base.Clan = spawnClan;
					
					if (spawn.Order <= CurrentOrder)
						base.Clan = spawnClan;
					else
					{
						spawnClan = 0;
						base.Clan = 0;
					}
				}
			}
		}
		
		foreach (clanOrder => order in Checkpoints)
		{
			foreach (checkpoint in order)
			{
				declare base <=> checkpoint.Base;
				base.IsActive = True;
				base.Clan = 3 - AttackingClan;
				
				if (checkpoint.Order <= CurrentOrder - 1)
					base.Clan = AttackingClan;

			}
		}
		
		foreach (clanOrder => order in Gates)
		{	
			foreach (gate in order)
			{
					declare _gate <=> gate.Gate;
					_gate.Automatic = False;
					_gate.ManualClosed = True;
					
					/*if (CurrentOrder < clanOrder + 1)
						_gate.Clan = 3 - AttackingClan;
					else
						_gate.Clan = AttackingClan;*/
					_gate.Clan = 0;
		
					declare gauge <=> gate.Gauge;
					gauge.Value = S_RushTimeGateDuration + 1;
					gauge.Max = S_RushTimeGateDuration + 1;
					gauge.Captured = gauge.Value != gauge.Max;
					
					if (gate.Order < CurrentOrder
						&& gate.Order + 2 < RangeCaptured.count)
					{
						gauge.Value = 0;
						gauge.Max = 0;
						gauge.Captured = False;
						_gate.Automatic = False;
						_gate.ManualClosed = False;
					} 
					
					if (CurrentOrder < clanOrder + 1)
						gauge.Clan = 3 - AttackingClan;
					else
						gauge.Clan = AttackingClan;
			}	
		}
	}
	
	declare netwrite Net_SpawnClan for Teams[0] = Integer[Integer];
	foreach (I => spawn in MapLandmarks_PlayerSpawn)
	{
	
		declare spawnClan for spawn = 0;
		Net_SpawnClan[I] = spawnClan;
	}
}